<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Deprecated js库</title>
    <url>/2019/05/24/2019-20190524-Deprecated-Js/</url>
    <content><![CDATA[<p>我们在install一些库的时候， 可能会看到一些提示， 表明这个js库已经废弃了， 让大家去用xx库的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">0524$ </span><span class="language-bash">npm i jQuery</span> </span><br><span class="line">npm WARN deprecated jQuery@1.7.4: This is deprecated. Please use &#x27;jquery&#x27; (all lowercase).</span><br><span class="line">npm WARN saveError ENOENT: no such file or directory, open &#x27;/Volumes/Code/test/0524/package.json&#x27;</span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class="line">npm WARN enoent ENOENT: no such file or directory, open &#x27;/Volumes/Code/test/0524/package.json&#x27;</span><br><span class="line">npm WARN 0524 No description</span><br><span class="line">npm WARN 0524 No repository field.</span><br><span class="line">npm WARN 0524 No README data</span><br><span class="line">npm WARN 0524 No license field.</span><br><span class="line"></span><br><span class="line">+ jQuery@1.7.4</span><br><span class="line">added 1 package from 1 contributor in 0.298s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<hr>
<p>其实很简单， 发布前在package.json中添加一个字段 deprecated，就可以了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;deprecated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is deprecated. Please use &#x27;jquery&#x27; (all lowercase).&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>开盘了</title>
    <url>/2019/05/23/2018-201805-helloWorld/</url>
    <content><![CDATA[<h1 id="终于开盘了"><a href="#终于开盘了" class="headerlink" title="终于开盘了"></a>终于开盘了</h1><p><strong>Hello EveryOne!</strong></p>
<p>很久以前就萌生了要创建一个独立的个人博客，由于个人的懒惰，迟迟没有付诸实现。在此之前， 在QQ空间、百度空间、chinaUnix博客、简书上零零散散的发布着文章， 终了感觉还是需要一个属于自己搭建的专业的博客，经过漫长的岁月，近期终于铆足了劲，花了些时间在github上搭建好博客了。同时也创建了自己的个人公众号。从此就有一个发布个人博文的小天地了，不再流浪。</p>
<blockquote>
<p>ChinaUnix博客地址： <a href="http://blog.chinaunix.net/uid/24459558.html">http://blog.chinaunix.net/uid/24459558.html</a></p>
</blockquote>
<blockquote>
<p>简书地址： <a href="https://www.jianshu.com/u/1eaa68a7efc1">https://www.jianshu.com/u/1eaa68a7efc1</a></p>
</blockquote>
<p>开篇是一个立Flag的时机， 嗯， 这个博客用来记录分享个人技术生涯的一些学习总结、经验分享以及想法杂谈，欢迎拍砖。</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei (IT攻城狮小明)，欢迎沟通交流。</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>fork库Git代码同步</title>
    <url>/2019/06/04/2019-20190604-synGitRepo/</url>
    <content><![CDATA[<p>做RN开发，需要fork一份官网的库，来做一些修修改改以满足业务需求。同样的， 在开发中也需要fork一些库，然后就修改。在源库不断演进之后，我们需要同步自身库的代码。 就需要进行代码同步了。</p>
<span id="more"></span>
<ol>
<li><p>clone当前库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:fishmwei/react-native.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置源库 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v </span><br><span class="line">git remote add upstream https://github.com/facebook/react-native.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取远程仓库修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch upstream </span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到master库， 合并远程库修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git merge upstream/master </span><br></pre></td></tr></table></figure>
</li>
<li><p>把本地库推送上去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push </span><br><span class="line">git push --tag </span><br></pre></td></tr></table></figure></li>
</ol>
<p>同步完成。</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>Git</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaLumberJack源码学习</title>
    <url>/2019/05/29/2019-20190529-lumberjack-iOS/</url>
    <content><![CDATA[<p>CocoaLumberJack是一个用于mac或者iOS的日志库，简单易用， 可扩展。</p>
<p>可以通过设置Logger，分别把日志写入文件、终端、系统日志中。</p>
<p>DDLogLevel   7个等级</p>
<p>库不大，代码结构比较清晰。</p>
<span id="more"></span>

<hr>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我用的cocopods、oc。</p>
<p>修改podfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// podfile </span><br><span class="line"></span><br><span class="line">pod &#x27;CocoaLumberjack&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#import &lt;CocoaLumberjack/CocoaLumberjack.h&gt; // 引用头文件</span><br><span class="line"></span><br><span class="line">static DDLogLevel ddLogLevel = DDLogLevelAll; // 定义全局变量</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    DDLogInfo(@&quot;message&quot;);</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>主要代码类可以参考GitHub给出的图。</p>
<p><img src="https://raw.githubusercontent.com/CocoaLumberjack/CocoaLumberjack/master/Documentation/CocoaLumberjackClassDiagram.png" alt="CocoaLumberjackClassDiagram.png"></p>
<h3 id="DDLog"><a href="#DDLog" class="headerlink" title="DDLog"></a>DDLog</h3><p>这个是对外的接口， 所有API都是直接调用这个接口的类方法进行写日志的。</p>
<p>有一个单例和一个队列。 所有写日志操作，最终都是在同一个队列进行操作的。 </p>
<p>日志可以写到不同的输出终端， 通过DDLogger协议来控制， DDLog可以添加多个DDLogger协议的对象(具体的都是抽象类DDAbstractLogger的子类)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// _loggingQueue</span><br><span class="line"></span><br><span class="line">// _loggingGroup</span><br><span class="line"></span><br><span class="line">// _queueSemaphore</span><br><span class="line"></span><br><span class="line">// _numProcessors</span><br><span class="line"></span><br><span class="line">_loggingGroup 用于并发输出</span><br><span class="line"></span><br><span class="line">UIApplicationWillTerminateNotification 执行 flushLog</span><br><span class="line">applicationWillTerminate</span><br></pre></td></tr></table></figure>
<h3 id="DDLogMessage"><a href="#DDLogMessage" class="headerlink" title="DDLogMessage"></a>DDLogMessage</h3><p>日志信息 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // Direct accessors to be used only for performance</span><br><span class="line">    @public</span><br><span class="line">    NSString *_message;  // 内容</span><br><span class="line">    DDLogLevel _level;      // 等级</span><br><span class="line">    DDLogFlag _flag;      // 用于过滤等级的信息， 只有   _level &amp; _flag == 1 才会输出</span><br><span class="line">    NSInteger _context;     // 可以用来过滤， 参考 DDContextWhitelistFilterLogFormatter</span><br><span class="line">    NSString *_file;        // 输出文件路径</span><br><span class="line">    NSString *_fileName;    // 输出文件名</span><br><span class="line">    NSString *_function;    //  ?? </span><br><span class="line">    NSUInteger _line;       </span><br><span class="line">    id _tag;        // ?? </span><br><span class="line">    DDLogMessageOptions _options;</span><br><span class="line">    NSDate *_timestamp;</span><br><span class="line">    NSString *_threadID;</span><br><span class="line">    NSString *_threadName;</span><br><span class="line">    NSString *_queueLabel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_loggerQueue</p>
<h2 id="DDAbstractLogger"><a href="#DDAbstractLogger" class="headerlink" title="DDAbstractLogger"></a>DDAbstractLogger</h2><p>抽象的logger， </p>
<p>可以设置logFormatter、loggerQueue</p>
<p>logFormatter可以对输出的日志再格式化。</p>
<h2 id="DDLoggerNode-用于记录logger的信息"><a href="#DDLoggerNode-用于记录logger的信息" class="headerlink" title="DDLoggerNode 用于记录logger的信息"></a>DDLoggerNode 用于记录logger的信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface DDLoggerNode : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    // Direct accessors to be used only for performance</span><br><span class="line">    @public</span><br><span class="line">    id &lt;DDLogger&gt; _logger;</span><br><span class="line">    DDLogLevel _level;</span><br><span class="line">    dispatch_queue_t _loggerQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) id &lt;DDLogger&gt; logger;</span><br><span class="line">@property (nonatomic, readonly) DDLogLevel level;</span><br><span class="line">@property (nonatomic, readonly) dispatch_queue_t loggerQueue;</span><br></pre></td></tr></table></figure>

<p>不同的logger输出， 又在各自的queue中操作。</p>
<h2 id="DDLogger-protocol"><a href="#DDLogger-protocol" class="headerlink" title="DDLogger protocol"></a>DDLogger protocol</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)logMessage:(DDLogMessage *)logMessage NS_SWIFT_NAME(log(message:));</span><br><span class="line"> </span><br><span class="line">@property (nonatomic, strong) id &lt;DDLogFormatter&gt; logFormatter;</span><br></pre></td></tr></table></figure>

<h2 id="DDTTYLogger"><a href="#DDTTYLogger" class="headerlink" title="DDTTYLogger"></a>DDTTYLogger</h2><p>写到tty的logger</p>
<h2 id="DDOSLogger"><a href="#DDOSLogger" class="headerlink" title="DDOSLogger"></a>DDOSLogger</h2><p>usr&#x2F;include&#x2F;os&#x2F;log.h</p>
<p>os_log_create<br>os_log_error<br>os_log_info</p>
<h2 id="DDASLLogger"><a href="#DDASLLogger" class="headerlink" title="DDASLLogger"></a>DDASLLogger</h2><p>asl.h &#x2F;&#x2F; 废弃了， 使用 usr&#x2F;include&#x2F;os&#x2F;log.h</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_client = asl_open(NULL, &quot;com.apple.console&quot;, 0);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        const char *msg = [message UTF8String];</span><br><span class="line"></span><br><span class="line">        size_t aslLogLevel;</span><br><span class="line">        switch (logMessage-&gt;_flag) &#123;</span><br><span class="line">            // Note: By default ASL will filter anything above level 5 (Notice).</span><br><span class="line">            // So our mappings shouldn&#x27;t go above that level.</span><br><span class="line">            case DDLogFlagError     : aslLogLevel = ASL_LEVEL_CRIT;     break;</span><br><span class="line">            case DDLogFlagWarning   : aslLogLevel = ASL_LEVEL_ERR;      break;</span><br><span class="line">            case DDLogFlagInfo      : aslLogLevel = ASL_LEVEL_WARNING;  break; // Regular NSLog&#x27;s level</span><br><span class="line">            case DDLogFlagDebug     :</span><br><span class="line">            case DDLogFlagVerbose   :</span><br><span class="line">            default                 : aslLogLevel = ASL_LEVEL_NOTICE;   break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static char const *const level_strings[] = &#123; &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot; &#125;;</span><br><span class="line"></span><br><span class="line">        // NSLog uses the current euid to set the ASL_KEY_READ_UID.</span><br><span class="line">        uid_t const readUID = geteuid();</span><br><span class="line"></span><br><span class="line">        char readUIDString[16];</span><br><span class="line">#ifndef NS_BLOCK_ASSERTIONS</span><br><span class="line">        size_t l = (size_t)snprintf(readUIDString, sizeof(readUIDString), &quot;%d&quot;, readUID);</span><br><span class="line">#else</span><br><span class="line">        snprintf(readUIDString, sizeof(readUIDString), &quot;%d&quot;, readUID);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        NSAssert(l &lt; sizeof(readUIDString),</span><br><span class="line">                 @&quot;Formatted euid is too long.&quot;);</span><br><span class="line">        NSAssert(aslLogLevel &lt; (sizeof(level_strings) / sizeof(level_strings[0])),</span><br><span class="line">                 @&quot;Unhandled ASL log level.&quot;);</span><br><span class="line"></span><br><span class="line">        aslmsg m = asl_new(ASL_TYPE_MSG);</span><br><span class="line">        if (m != NULL) &#123;</span><br><span class="line">            if (asl_set(m, ASL_KEY_LEVEL, level_strings[aslLogLevel]) == 0 &amp;&amp;</span><br><span class="line">                asl_set(m, ASL_KEY_MSG, msg) == 0 &amp;&amp;</span><br><span class="line">                asl_set(m, ASL_KEY_READ_UID, readUIDString) == 0 &amp;&amp;</span><br><span class="line">                asl_set(m, kDDASLKeyDDLog, kDDASLDDLogValue) == 0) &#123;</span><br><span class="line">                asl_send(_client, m);</span><br><span class="line">            &#125;</span><br><span class="line">            asl_free(m);</span><br><span class="line">        &#125;</span><br><span class="line">        //TODO handle asl_* failures non-silently?</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>OS_OBJECT_USE_OBJC 用于判断系统是否是6.0以前的？ 6.0之后才定义了这个宏。</p>
</blockquote>
<p>dispatch_group_async</p>
<h2 id="DDLoggerInformation"><a href="#DDLoggerInformation" class="headerlink" title="DDLoggerInformation"></a>DDLoggerInformation</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // Direct accessors to be used only for performance</span><br><span class="line">    @public</span><br><span class="line">    id &lt;DDLogger&gt; _logger;</span><br><span class="line">    DDLogLevel _level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="DDExtractFileNameWithoutExtension-提取文件名"><a href="#DDExtractFileNameWithoutExtension-提取文件名" class="headerlink" title="DDExtractFileNameWithoutExtension 提取文件名"></a>DDExtractFileNameWithoutExtension 提取文件名</h2><p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开源代码</tag>
      </tags>
  </entry>
  <entry>
    <title>React-Native Sample代码运行</title>
    <url>/2019/06/04/2019-20190604-RNTester-RN/</url>
    <content><![CDATA[<p>React-Native官方<a href="https://github.com/facebook/react-native">GitHub库</a>，提供了各个API及控件的示例代码， 在根目录下的RNTester目录中。要运行示例代码只需要如下步骤：</p>
<span id="more"></span>

<h2 id="安装js依赖"><a href="#安装js依赖" class="headerlink" title="安装js依赖"></a>安装js依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//根目录执行</span><br><span class="line">npm install </span><br><span class="line">npm start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解压第三方库"><a href="#解压第三方库" class="headerlink" title="解压第三方库"></a>解压第三方库</h2><p>React-Native依赖了 folly、glog等第三方库， 需要下载解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd scripts</span><br><span class="line">sh ios-install-third-party.sh </span><br></pre></td></tr></table></figure>

<h2 id="安装iOS依赖"><a href="#安装iOS依赖" class="headerlink" title="安装iOS依赖"></a>安装iOS依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd RNTester</span><br><span class="line">pod update // 更新.lock中的依赖</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>以上步骤完成， XCode运行RNTester.workspace</p>
<p><img src="/images/RNTester.gif"></p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugly RN调用栈 - C的弱符号</title>
    <url>/2019/06/11/2019-20190611-weak-attribute-C/</url>
    <content><![CDATA[<p><strong>react-native: 0.49.3</strong></p>
<p>推广RN之后， 经常收到Bugly指派过来的bug， 只是因为调用栈中包含了RN的一个符号 RCTFBQuickPerformanceLoggerConfigureHooks。</p>
<!---- more ----->

<p>看了一下代码， RCTFBQuickPerformanceLoggerConfigureHooks这个函数是个空函数， 没有任何实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RCTBridget.m</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCTFBQuickPerformanceLoggerConfigureHooks</span><span class="params">(__unused JSGlobalContextRef ctx)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RCTBridge+Private.h</span></span><br><span class="line"></span><br><span class="line">RCT_EXTERN __attribute__((weak)) <span class="type">void</span> <span class="title function_">RCTFBQuickPerformanceLoggerConfigureHooks</span><span class="params">(JSGlobalContextRef ctx)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在头文件中， 通过 <strong>attribute</strong>((weak)) 修饰了函数声明。 </p>
<p>将本模块的RCTFBQuickPerformanceLoggerConfigureHooks转成弱符号类型，如果遇到强符号类型（即外部模块定义了RCTFBQuickPerformanceLoggerConfigureHooks），那么我们在本模块执行的RCTFBQuickPerformanceLoggerConfigureHooks将会是外部模块定义的RCTFBQuickPerformanceLoggerConfigureHooks。</p>
<p>如果外部模块没有定义，那么，将会调用这个弱符号，也就是在本地定义的RCTFBQuickPerformanceLoggerConfigureHooks </p>
<p>相当于增加了一个默认函数。</p>
<p>原理：链接器发现同时存在弱符号和强符号，优先选择强符号，如果发现不存在强符号，只存在弱符号，则选择弱符号。如果都不存在：静态链接，恭喜，编译时报错，动态链接：对不起，系统无法启动。</p>
<p>我们通过machoView可以看到即使是release的二进制文件， 符号中也存在RCTFBQuickPerformanceLoggerConfigureHooks这个符号。</p>
<p><img src="/images/machoview-weak.png"></p>
<p>堆栈符号化是根据地址相离最近的符号来解析的， 在没有上传符号表时，许多堆栈都会解析成 RCTFBQuickPerformanceLoggerConfigureHooks + 偏移地址。无形中加大了RN维护人员的问题定位的时间成本。</p>
<p>删掉这个RCTFBQuickPerformanceLoggerConfigureHooks函数的声明与实现。从此，再没有bug来骚扰。 </p>
<p>另外，最新版本的react-native已经删除RCTFBQuickPerformanceLoggerConfigureHooks的实现了。<br>github删除该段代码的记录:<br><a href="https://github.com/facebook/react-native/commit/c49d3653ef35bb3b932055027af0c0a6bab91d84#diff-3694567fdb59b754cc845377d26f6ee2">https://github.com/facebook/react-native/commit/c49d3653ef35bb3b932055027af0c0a6bab91d84#diff-3694567fdb59b754cc845377d26f6ee2</a></p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>React-Native</tag>
        <tag>Bugly</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS知识点(1) - NSCache</title>
    <url>/2019/06/19/2019-20190619-NSCache-iOS/</url>
    <content><![CDATA[<p>最近在详细阅读React-Native源码，准备出一系列React-Native源码的解析及实现原理的连载文章，后续一一发布。 同时对遇到的iOS知识点进行梳理。基于React-Native 0.59.9版本的代码讲解。</p>
<p>本文讲的是NSCache，在RCTImage库中使用到的， 具体可以看 RCTImage&#x2F;RCTImageCache.m中_decodedImageCache的使用。</p>
<p>RCTImage把获取到的图片缓存到RCTImageCache中，具体保存在_decodedImageCache。对于没有loaderHandler处理的url的图片， 会先从cache中查找，否则就从网络下载。</p>
<span id="more"></span>

<p>NSCache是一个用于临时存储键数据的可变集合，当内存紧张时可以自动释放对象，避免高内存。NSCache是线程安全的，可以从任何线程添加、删除、查询对象。<br>NSCache不会拷贝key，不同于NSdictionary。</p>
<p>包含可以释放的内容的对象可以实现NSDiscardableContent协议，来优化缓存管理。默认实现了该协议的对象，在内容被删除时会自动移除。移除之前，会调用discardContentIfPossible方法。</p>
<p>NSCache主要有几个属性 及 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@property NSUInteger totalCostLimit; // 最大缓存空间， 为0则不限制</span><br><span class="line"></span><br><span class="line">@property NSUInteger countLimit; // 缓存对象的个数限制， 为0则不限制</span><br><span class="line"></span><br><span class="line">@property BOOL evictsObjectsWithDiscardedContent; // 是否主动移除内容过期的对象，默认YES， 配合 NSDiscardableContent协议使用</span><br><span class="line"></span><br><span class="line">- (nullable ObjectType)objectForKey:(KeyType)key;  // 获取key的缓存</span><br><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key; // 0 cost 添加缓存对象， 占用空间0</span><br><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g; // 添加缓存对象， 占用空间g</span><br><span class="line"></span><br><span class="line">- (void)removeObjectForKey:(KeyType)key;  // 手动移除缓存</span><br><span class="line"></span><br><span class="line">- (void)removeAllObjects; // 移除所有缓存对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>NSCache 通过设置totalCostLimit的值限制最大的缓存空间， 在添加缓存对象时会指定缓存对象的占用空间， 为0则不限制，默认为0。如果总的占用空间超过totalCostLimit。 NSCache会自动释放一些对象直到空间小于totalCostLimit。哪个对象会被释放是不确定的、释放时机也是不确定的，依赖NSCache的实现。</p>
<p>同样的 countLimit是对缓存的对象个数进行限制， 为0则不限制，默认为0. 当对象个数超过countLImit时，某些对象就会被释放掉。释放的时机和具体的对象也是不确定的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)downloadDataForURL:(NSURL *)url&#123;</span><br><span class="line">    NSPurgeableData *cachedData = [_cache objectForKey:url];  // 实现NSDiscardableContent协议的对象</span><br><span class="line">    if(cachedData)&#123;</span><br><span class="line">        //Stop the data being purged</span><br><span class="line">        [cachedData beginContentAccess];</span><br><span class="line">        </span><br><span class="line">        //Use the cached data</span><br><span class="line">        [self useData:cachedData];</span><br><span class="line">        </span><br><span class="line">        //Mark that the data may be purged again</span><br><span class="line">        [cachedData endContentAccess];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //Cache miss</span><br><span class="line">        EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc]initWithURL:url];</span><br><span class="line">        [fetcher startWithCompletionHandler:^(NSData *data) &#123;</span><br><span class="line">            NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data];</span><br><span class="line">            [_cache setObject:purgeableData forKey:url cost:data.length];</span><br><span class="line">            </span><br><span class="line">            //Don&#x27;t need to beginContentAccess as it begins</span><br><span class="line">            //with access already marked</span><br><span class="line">            </span><br><span class="line">            //Use the retrieved data</span><br><span class="line">            [self useData:data];</span><br><span class="line">            </span><br><span class="line">            //Mark that the data may be purged now</span><br><span class="line">            [purgeableData endContentAccess];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在RCTImage中设置缓存最大限制大小为20MB， 还根据NSURLResponse的缓存字段对缓存进行控制， 在获取缓存时，如果过期则主动删除缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_decodedImageCache.totalCostLimit = 20 * 1024 * 1024; // 20 MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (UIImage *)imageForUrl:(NSString *)url</span><br><span class="line">                    size:(CGSize)size</span><br><span class="line">                   scale:(CGFloat)scale</span><br><span class="line">              resizeMode:(RCTResizeMode)resizeMode</span><br><span class="line">&#123;</span><br><span class="line">  NSString *cacheKey = RCTCacheKeyForImage(url, size, scale, resizeMode);</span><br><span class="line">  @synchronized(_cacheStaleTimes) &#123;</span><br><span class="line">    id staleTime = _cacheStaleTimes[cacheKey];</span><br><span class="line">    if (staleTime) &#123;</span><br><span class="line">      if ([[NSDate new] compare:(NSDate *)staleTime] == NSOrderedDescending) &#123;</span><br><span class="line">        // cached image has expired, clear it out to make room for others</span><br><span class="line">        [_cacheStaleTimes removeObjectForKey:cacheKey];</span><br><span class="line">        [_decodedImageCache removeObjectForKey:cacheKey];</span><br><span class="line">        return nil;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return [_decodedImageCache objectForKey:cacheKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>React-Native</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS知识点(3) - NSCopying/NSMutableCopying</title>
    <url>/2019/08/18/2019-20190818-OCCopy-iOS/</url>
    <content><![CDATA[<p>有时候我们需要对某些对象作快照，需要复制对象当前的状态。OC中提供了copy&#x2F;mutableCopy的方法。系统提供的集合类，比人NSArray、NSSet、NSDictionary都提供了对于的方法。 对于我们自定义的对象，则可以通过实现NSCopying&#x2F;NSMutableCopying协议来实现对应的功能。</p>
<span id="more"></span>

<h2 id="NSCopying"><a href="#NSCopying" class="headerlink" title="NSCopying"></a>NSCopying</h2><p>用于对象实现自身复制的协议。复制得到一个独立的对象，所有的属性值与该对象一样。</p>
<p>NSCopying协议声明了一个方法 copyWithZone:。 但是所有继承NSObject的类都通过调用copy方法，间接调用copyWithZone: 实现复制。</p>
<p>你可以这样实现方法：</p>
<ol>
<li>方法中通过alloc和init返回一个新的对象， 不继承copyWithZone:</li>
<li>通过调用父类的copyWithZone:， 然后再设置额外的属性</li>
<li>如果类是不可变的， 直接返回自身也可以。</li>
</ol>
<p>如果子类也实现了NSCopying协议， 父类也有实现NSCopying， 那么子类必须重新copyWithZone：方法，调用父类的copyWithZone后，再处理自身的属性赋值。</p>
<h2 id="NSMutableCopying"><a href="#NSMutableCopying" class="headerlink" title="NSMutableCopying"></a>NSMutableCopying</h2><p>NSMutableCopying协议提供一个可变副本的拷贝。只有当类存在可变与不可变区别的时候才需要实现NSMutableCopying协议，否则，只需要实现NSCopying协议就可以了。 通过mutableCopy方法创建的对象，属性是可变的。</p>
<p>其实，具体实现还是有开发者决定。 看你在copyWithZone:&#x2F;mutableCopyWithZone:中返回的是什么对象。 当然，最好还是按照苹果的规则来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface CopyObjectBaseManager : NSObject &lt;NSCopying&gt;</span><br><span class="line">&#123;</span><br><span class="line">@protected</span><br><span class="line">    </span><br><span class="line">    BOOL _finishParse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, __kindof BaseCopyObject *&gt; *allConfig;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation CopyObjectBaseManager</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableDictionary *)allConfig &#123;</span><br><span class="line">    if (!_allConfig) &#123;</span><br><span class="line">        _allConfig = [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return _allConfig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    CopyObjectBaseManager *manager = [[self class] allocWithZone:zone];</span><br><span class="line">    manager-&gt;_finishParse = _finishParse;</span><br><span class="line">    manager.allConfig = [self.allConfig mutableCopy]; // allConfig 是可变的</span><br><span class="line">    </span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体实现代码 请参考github库   <a href="https://github.com/fishmwei/iOSLearnList">https://github.com/fishmwei/iOSLearnList</a></p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS知识点(2) - iOS横竖屏旋转</title>
    <url>/2019/08/08/2019-20190808-autorotateiOS/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近，业务方提了一个需求，希望RN页面支持横竖屏。就去研究了一下， 顺便聊聊遇到的一些问题。</p>
<p>首先，应用要支持横竖屏旋转， 首先要在工程配置中勾选支持的方向。然后，不同的ViewController通过实现对应的接口实现横竖屏， 以及代码调用接口来手动实现横竖屏切换。</p>
<!--- more --->

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="勾选支持方向"><a href="#勾选支持方向" class="headerlink" title="勾选支持方向"></a>勾选支持方向</h3><p>工程 - General - Deployment Info - Device Orientation</p>
<p><img src="/images/configOrientation.png"></p>
<h3 id="controller接口"><a href="#controller接口" class="headerlink" title="controller接口"></a>controller接口</h3><p>UIViewController需要实现3个接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">    return _isAutoRotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class="line">    return self.supportedOrientation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123;</span><br><span class="line">      return self.preferredOrientation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只有当shouldAutorotate为YES时，其它两个接口才生效。<br>UIInterfaceOrientationMask 标识支持的方向集合， UIInterfaceOrientation用于当控制器被present出来后的视图方向</p>
<h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><p>我们看代码， 可以看到2个方向， 界面方向和设备方向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用户界面方向</span><br><span class="line">typedef NS_ENUM(NSInteger, UIInterfaceOrientation) &#123;</span><br><span class="line">    UIInterfaceOrientationUnknown            = UIDeviceOrientationUnknown,</span><br><span class="line">    UIInterfaceOrientationPortrait           = UIDeviceOrientationPortrait,</span><br><span class="line">    UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown,</span><br><span class="line">    UIInterfaceOrientationLandscapeLeft      = UIDeviceOrientationLandscapeRight,</span><br><span class="line">    UIInterfaceOrientationLandscapeRight     = UIDeviceOrientationLandscapeLeft</span><br><span class="line">&#125; API_UNAVAILABLE(tvos);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 用户方向，一般与状态栏方向一致， 可以通过获取状态栏方向 来获取当前界面的方向</span><br><span class="line"></span><br><span class="line">[[UIApplication sharedApplication] statusBarOrientation]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 设备方向， 当前设备的方向</span><br><span class="line">typedef NS_ENUM(NSInteger, UIDeviceOrientation) &#123;</span><br><span class="line">    UIDeviceOrientationUnknown,</span><br><span class="line">    UIDeviceOrientationPortrait,            // Device oriented vertically, home button on the bottom</span><br><span class="line">    UIDeviceOrientationPortraitUpsideDown,  // Device oriented vertically, home button on the top</span><br><span class="line">    UIDeviceOrientationLandscapeLeft,       // Device oriented horizontally, home button on the right</span><br><span class="line">    UIDeviceOrientationLandscapeRight,      // Device oriented horizontally, home button on the left</span><br><span class="line">    UIDeviceOrientationFaceUp,              // Device oriented flat, face up</span><br><span class="line">    UIDeviceOrientationFaceDown             // Device oriented flat, face down</span><br><span class="line">&#125; API_UNAVAILABLE(tvos);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">// 设备方向， 通过当前设备的接口获取，  需要事先调用 </span><br><span class="line"></span><br><span class="line">    [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];</span><br><span class="line"></span><br><span class="line">    [[UIDevice currentDevice] orientation]</span><br><span class="line">    </span><br><span class="line">    ...  // 操作</span><br><span class="line"></span><br><span class="line">    [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很多时候， 界面方向会和设备方向不一致（支持当前设备方向的前提下）。 我们可以调用接口使其自动旋转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[UIViewController attemptRotationToDeviceOrientation];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="手动切换方向"><a href="#手动切换方向" class="headerlink" title="手动切换方向"></a>手动切换方向</h3><p>目前只能通过修改orientation的方向来达到切方向的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[[UIDevice currentDevice] setValue:@(deviceOrientation) forKey:@&quot;orientation&quot;];</span><br><span class="line">[UIViewController attemptRotationToDeviceOrientation];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="根控制器支持横竖屏"><a href="#根控制器支持横竖屏" class="headerlink" title="根控制器支持横竖屏"></a>根控制器支持横竖屏</h3><p>大部分应用window不是以UIViewController为rootViewController。 一般是TabbarController或者NavigationControler。 要使得他们支持横竖屏，需要额外添加一个分类， 重新对应的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@implementation UINavigationController (Rotation)</span><br><span class="line"></span><br><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">  if (self.viewControllers &amp;&amp; [self.viewControllers count] &gt; 0) &#123;</span><br><span class="line">    return [self.topViewController shouldAutorotate];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return [super shouldAutorotate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class="line">  if (self.viewControllers &amp;&amp; [self.viewControllers count] &gt; 0) &#123;</span><br><span class="line">    return [self.topViewController supportedInterfaceOrientations];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return [super supportedInterfaceOrientations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123;</span><br><span class="line">  if (self.viewControllers &amp;&amp; [self.viewControllers count] &gt; 0) &#123;</span><br><span class="line">    return [self.topViewController preferredInterfaceOrientationForPresentation];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return [super preferredInterfaceOrientationForPresentation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation UITabBarController (Rotation)</span><br><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">  return [self.selectedViewController shouldAutorotate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class="line">  return [self.selectedViewController supportedInterfaceOrientations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123;</span><br><span class="line">  return [self.selectedViewController preferredInterfaceOrientationForPresentation];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 大部分ViewController只支持竖屏， 不支持切换</span><br><span class="line"></span><br><span class="line">@implementation UIViewController (rotate)</span><br><span class="line"></span><br><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体实现代码 请参考github库   <a href="https://github.com/fishmwei/iOSLearnList">https://github.com/fishmwei/iOSLearnList</a></p>
<p>番外：最近家里添丁，事情比较多，挺久没有更新博客了， 以后坚持一周至少一篇。</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>YTKKeyValueStore开源库使用</title>
    <url>/2019/08/30/2019-20190830-kvStore-iOS/</url>
    <content><![CDATA[<p><code>YTKKeyValueStore</code>是一个轻量级的sqlite数据库开源库，基于FMDB封装的一个key、value的数据库, 由猿题库团队开源。适用于数据量不大的情况，进行简单的数据存储。比如配置信息，或者用户信息等。 </p>
<p>在工作中，我用它来存储版本及组件的信息， 通过查询数据，确认ipa是否升级以及确定组件是否需要更新(RN热更新)等策略。</p>
<span id="more"></span>

<p>代码非常简单， 只有一个类 <code>YTKKeyValueStore</code></p>
<p>数据表结构也很简单， 所有的表只有三个字段 id、json、createdTime</p>
<p>id用来索引一个数据项<br>json用来保存数据对象的json字符串<br>createdTime是条目插入或者更新的时间轴</p>
<p>实现逻辑比较简单， 支持如下功能</p>
<ul>
<li>创建数据库， 可以只指定数据库文件名， 也可以指定数据库文件的路径</li>
<li>创建指定名称的表操作</li>
<li>清空表操作</li>
<li>关闭数据库</li>
<li>插入字符串， 其实是把字符串转为数组，然后存储数组的json字符串</li>
<li>获取字符串， 获取到json字符串，转为数组，返回数组第一个元素</li>
<li>插入对象， 存储对象的json字符串</li>
<li>获取对象， 获取都json字符串，转为对象</li>
<li>插入数字， 把数字封装成数组，然后存储数组的json字符串</li>
<li>获取数字， 获取到json字符串，转为数组，返回数组第一个元素</li>
<li>删除指定表名、指定id的条目</li>
<li>删除指定表名、指定id数组的多个条目</li>
<li>删除指定表明、指定前缀的id条目</li>
<li>获取一个表的所有条目， 返回数组的元素是内部的结构 <code>YTKKeyValueItem</code>， 然后获取<code>itemObject</code>对象， 即存入时的对象</li>
<li>获取一个表指定id的条目， 返回的元素是内部的结构 <code>YTKKeyValueItem</code>， 然后获取<code>itemObject</code>对象， 即存入时的对象</li>
</ul>
<p>缺点： </p>
<ul>
<li>没有支持删除整个表的功能。 比如我们创建了一些临时的表， 无法删除， 那么就会有一些脏数据表在数据库中。</li>
</ul>
<p>我新增了这个功能:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static NSString *const DROP_TABLE_SQL = @&quot;drop table %@&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)dropTable:(NSString *)tableName &#123;</span><br><span class="line">    if ([YTKKeyValueStore checkTableName:tableName] == NO) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString * sql = [NSString stringWithFormat:DROP_TABLE_SQL, tableName];</span><br><span class="line">    __block BOOL result;</span><br><span class="line">    [_dbQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        result = [db executeUpdate:sql];</span><br><span class="line">    &#125;];</span><br><span class="line">    if (!result) &#123;</span><br><span class="line">        debugLog(@&quot;ERROR, failed to drop table: %@&quot;, tableName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>表名，貌似不支持以数字开头 写代码的时候， 默认在前面添加table前缀</li>
</ul>
<p>番外知识点：</p>
<ul>
<li>打开sqlite数据库， 命令<code>sqlite3 ytkstore.db</code></li>
<li>查看数据库内所有表， SQL命令<code>select name from sqlite_master where type = &#39;table&#39;</code></li>
<li>查看表数据 , SQL命令 <code>select * from tablename</code></li>
<li>如何分页查询数据  SQL命令 <code>select * from tables order by id limit 5 offset 5;</code> 可以自己实现这个功能。</li>
</ul>
<p>sqltie数据库，默认会创建一个sqlite_master的表， 存储数据库的信息。 我们从中可以找到已经存在的表名。</p>
<p>具体实现代码 请参考github库   <a href="https://github.com/fishmwei/iOSLearnList">https://github.com/fishmwei/iOSLearnList</a></p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开源代码</tag>
      </tags>
  </entry>
  <entry>
    <title>一种获取客户端程序的代码版本的方法</title>
    <url>/2019/09/27/2019-20190927-versionScheme-common/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一个构思方案， 本来方案准备用于专利申请的，反馈没有什么创新性。放上来供有需要的人参考，欢迎交流~</p>
<span id="more"></span>

<h2 id="背景技术"><a href="#背景技术" class="headerlink" title="背景技术"></a>背景技术</h2><p>目前主流的程序软件开发，都是依赖多个不同的代码库而构建的，有开源代码库、也有自研的代码库。不同版本的程序，依赖代码库的不同版本。目前流行的移动app还支持基于js的混合开发，程序可以通过下载最新的js代码运行新功能或者修复已知问题，同一个版本的app根据用户或者设备、平台等信息的不同，还可能更新到不同的js代码运行。</p>
<p>一般情况下，使用的代码库信息在构建生成二进制文件之后，没有进行保存。当出现问题时，开发人员根据最新的代码库不一定能够复现问题， 时间很久的话，又很难找到当初构建app的工程，导致问题较难定位。另外，对于支持js热更新的业务，没有有效的方式获取移动app运行的js的版本，常常无法证明js版本是否更新。针对此类问题的运维手段较缺乏。</p>
<h2 id="方案描述"><a href="#方案描述" class="headerlink" title="方案描述"></a>方案描述</h2><p>我们在构建移动app及其js代码时，把对应的依赖库版本信息与移动端app或者js代码的版本上传到专门的服务器保存。服务器提供接口查询，客户端app带上版本、包Id等信息，通过接口请求获取代码依赖库的版本信息，然后在客户端进行展示。技术实现简单，但是一旦实施，对问题定位是大有裨益的，快速定位问题出现版本，结合现象很容易分析出问题根因。</p>
<p>基本流程如下：</p>
<h3 id="1-构建保存依赖库版本信息、移动app信息、构建的js的版本信息。"><a href="#1-构建保存依赖库版本信息、移动app信息、构建的js的版本信息。" class="headerlink" title="1. 构建保存依赖库版本信息、移动app信息、构建的js的版本信息。"></a>1. 构建保存依赖库版本信息、移动app信息、构建的js的版本信息。</h3><p>移动app代码工程构建前，都需要根据配置的依赖代码库版本信息(一般由一个特定的文件来配置，如iOS的podfile文件)，来拉取对应的代码库。并生成一个相关的依赖文件， 比如iOS的podfile.lock、js的npm-shrinkwrap.json或者package-lock.json等记录最终使用的代码版本信息。然后，进行编译构建出最终的可执行文件包。<br>我们在构建成功后，把对应的版本信息文件和构建的app版本等信息上传到服务器，服务器解析后保存到数据库中。</p>
<p>最终信息层次可以参考如下：</p>
<p>一个移动app的信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">    <span class="attr">bundleId</span>: com.<span class="property">apple</span>.<span class="property">app</span>.<span class="property">diary</span>,</span><br><span class="line">    <span class="attr">appName</span>: 移动app，</span><br><span class="line">    <span class="attr">platform</span>: ios, <span class="comment">// 系统类型， android和iOS是分开编译的，其解析方式、依赖组件的名称及版本都是不一样的</span></span><br><span class="line">    <span class="attr">nativeInfoList</span>: [ <span class="comment">// 原生代码版本</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">version</span>: <span class="number">1.0</span><span class="number">.0</span>,</span><br><span class="line">            <span class="attr">denpendencies</span>: [</span><br><span class="line">                <span class="title class_">AFNetWorking</span>: <span class="number">3.0</span><span class="number">.1</span>,</span><br><span class="line">                <span class="attr">FMDB</span>: <span class="number">2.0</span><span class="number">.0</span>,</span><br><span class="line">                ...</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">version</span>: <span class="number">1.0</span><span class="number">.1</span>,</span><br><span class="line">            <span class="attr">denpendencies</span>: [</span><br><span class="line">                <span class="title class_">AFNetWorking</span>: <span class="number">3.0</span><span class="number">.2</span>,</span><br><span class="line">                <span class="attr">FMDB</span>: <span class="number">2.0</span><span class="number">.0</span>,</span><br><span class="line">                ...</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">jsInfoList</span>: [  <span class="comment">// js代码版本</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">name</span>: personalPage, <span class="comment">// 个人主页业务js</span></span><br><span class="line">            <span class="attr">versions</span>: &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="title class_">Ver</span>: <span class="number">1.0</span><span class="number">.0</span>,</span><br><span class="line">                    <span class="attr">dependencies</span>: [</span><br><span class="line">                        <span class="attr">react</span>: <span class="number">16.8</span><span class="number">.0</span>,</span><br><span class="line">                        react-<span class="attr">native</span>: <span class="number">0.60</span><span class="number">.1</span>,</span><br><span class="line">                        ...</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="title class_">Ver</span>: <span class="number">1.0</span><span class="number">.1</span>,</span><br><span class="line">                    <span class="attr">dependencies</span>: [</span><br><span class="line">                        <span class="attr">react</span>: <span class="number">16.8</span><span class="number">.0</span>,</span><br><span class="line">                        react-<span class="attr">native</span>: <span class="number">0.60</span><span class="number">.2</span>,</span><br><span class="line">                        ...</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考流程：</p>
<p><img src="/images/versionScheme.png"></p>
<h3 id="2-服务器提供一个api，根据传入的请求信息返回对应的依赖信息"><a href="#2-服务器提供一个api，根据传入的请求信息返回对应的依赖信息" class="headerlink" title="2.服务器提供一个api，根据传入的请求信息返回对应的依赖信息"></a>2.服务器提供一个api，根据传入的请求信息返回对应的依赖信息</h3><p>服务器开发一个接口，支持通过移动app上传app包Id，版本、平台、以及查询的js版本(如果有)信息，获取代码依赖版本信息。找不到则返回具体的错误(不存在的app、不存在的版本、不存在js版本等)。</p>
<h3 id="3-移动app可以实现一个UI展示页面，通过某种特殊方式展示该页面，发起接口请求，获取版本信息"><a href="#3-移动app可以实现一个UI展示页面，通过某种特殊方式展示该页面，发起接口请求，获取版本信息" class="headerlink" title="3.移动app可以实现一个UI展示页面，通过某种特殊方式展示该页面，发起接口请求，获取版本信息"></a>3.移动app可以实现一个UI展示页面，通过某种特殊方式展示该页面，发起接口请求，获取版本信息</h3><p>移动app保存有当前的版本号及运行的js版本(更新的时候，需要保存更新后的版本)信息。测人人员通过某些方式(比如：通过IM聊天窗口的链接功能访问，也可以使用某些隐藏的方式触发访问，点击版本号10次之类的)跳转到UI展示页面，展示当前app的版本已经运行的所有js的版本。 点击具体的项目，发起对应的请求，然后进行结果展示。</p>
<p>如此，我们就可以准确的获取移动app对应的依赖代码库的版本列表，快速定位问题版本。</p>
<h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>以下通过具体场景，描述上述算法的具体实现：</p>
<h3 id="场景一：bug已修复，但是业务方依旧经常反馈相同的问题。"><a href="#场景一：bug已修复，但是业务方依旧经常反馈相同的问题。" class="headerlink" title="场景一：bug已修复，但是业务方依旧经常反馈相同的问题。"></a>场景一：bug已修复，但是业务方依旧经常反馈相同的问题。</h3><p>在工作中，常常会遇到如题所述的场景。某些bug已经在某个库版本中发布解决了，但是还是会有相同的问题反馈。我们之前需要找到对应移动app的构建环境，然后确认其配置是否引用的是已修复的代码版本。有时候，甚至会找不到构建环境了， 业务方仅能够提供移动app的程序，给问题定位带来很大的困难。通过本方案，我们可以快速确认发生问题的移动app引用的版本，确认问题版本号，然后再针对具体版本代码分析。</p>
<p>流程：</p>
<ul>
<li><ol>
<li>从业务方获取移动app，登录</li>
</ol>
</li>
<li><ol start="2">
<li>启动app，打开版本信息界面</li>
</ol>
</li>
<li><ol start="3">
<li>连续点击版本号10次，跳转版本获取页面</li>
</ol>
</li>
<li><ol start="4">
<li>点击具体的条目，获取版本代码依赖信息</li>
</ol>
</li>
<li><ol start="5">
<li>确认问题是否由于未引用新的版本代码导致。如果是由于版本为更新引起的，告知业务方原因，通知其采用新的代码版本。</li>
</ol>
</li>
<li><ol start="6">
<li>如果是新的版本也有问题，采用问题版本进行复现定位。</li>
</ol>
</li>
</ul>
<h3 id="场景二：业务方反馈热更新不生效，导致其功能异常"><a href="#场景二：业务方反馈热更新不生效，导致其功能异常" class="headerlink" title="场景二：业务方反馈热更新不生效，导致其功能异常"></a>场景二：业务方反馈热更新不生效，导致其功能异常</h3><p>有时候，业务方会反馈称基本的js版本更新功能不生效，导致其功能无法通过热更新修复。其实不然，也有可能因为其代码修改未覆盖所有异常情况导致的，我们可以通过获取js依赖代码版本信息，证明代码已更新。</p>
<ul>
<li><ol>
<li>从业务方获取问题复现环境(设备啊， 帐户啊)</li>
</ol>
</li>
<li><ol start="2">
<li>启动app，打开版本信息界面</li>
</ol>
</li>
<li><ol start="3">
<li>点击具体的条目，获取版本代码依赖信息</li>
</ol>
</li>
<li><ol start="4">
<li>确认运行的js版本及代码依赖信息，告知业务方，以确认更新功能是否异常。如果更新功能正常，转业务开发人员继续定位</li>
</ol>
</li>
<li><ol start="5">
<li>如果更新功能异常，查找异常原因并解决。</li>
</ol>
</li>
</ul>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>开发经验</tag>
        <tag>构思方案</tag>
      </tags>
  </entry>
  <entry>
    <title>一次单例模式的代码重构</title>
    <url>/2019/09/30/2019-20190930-sharedInstance-JOB/</url>
    <content><![CDATA[<p><strong>不要滥用设计模式</strong></p>
<p>最近在做代码剥离重构， 有一个基础库A，作为面向业务开发者的接口库，随着业务的发展，很多内容都往里面塞。虽然，中间每次添加都或多或少考虑了解耦，抽象了很多协议接口，但架不住常年累月的堆积啊。</p>
<span id="more"></span>

<p>熟悉设计模式的人，对单例模式一定不陌生吧。一次创建、处处可用。也不用担心用错。</p>
<p>这里讲到的是一个解析配置文件的单例， 作为配置文件的管理类， 内部会包含多个不同文件的管理对象，然后对外提供统一的接口。 但是这些管理对象呢，又存在相互依赖的关系。 然后呢， 有部分文件的管理对象就也设计成了单例， 又有一部分的文件的管理对象却是普通对象。设计成单例的文件管理对象，基本上是被其它管理对象或者其它类依赖了的。库中的其它类有的依赖管理对象，有的依赖了具体文件的管理对象。总之，就是有点乱。 </p>
<p>初始类图关系大致如下：</p>
<p><img src="/images/20190930/OriginalClasses.png"></p>
<p>现在，有一个需求，进入每个页面后，页面的配置更改不能影响全局的配置。然后，我就很崩溃了，本来呢， 快照可以是管理对象的一个实例就行了， 每次进页面创建一个快照管理对象，配置更新全部在快照管理对象上处理就行了。可是，好多单例啊， 一旦修改，全局都生效了。 好吧， 花点时间把管理理一下， 然后有如下的新类图:</p>
<p><img src="/images/20190930/newClasses.png"></p>
<p>图中的<code>#</code>号表示这些属性对内部的类暴露, <code>OC</code>实现就是用扩展，然后内部类可以包含扩展的头文件。 对外业务暴露的接口不包含扩展的接口和属性。内部其它类只依赖管理对象， 然后把具体文件的管理对象的单例干掉。在管理对象中，生成每个文件的管理对象实例。 部分文件的管理对象依赖管理对象， 不再依赖具体的文件管理对象。 这里， 我还把管理对象中属性的初始化通过懒加载实现， 为了保证线程安全， 在初始化的地方加锁， 由于存在文件管理对象依赖文件管理对象的情况， 这个锁还需要可重入的，也就是递归锁。实现代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ConfigManager.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _getterLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init]; <span class="comment">// 处理懒加载，初始化 多线程互斥</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (FileAConfigManager *)aConfigManager &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_aConfigManager) &#123;</span><br><span class="line">        [_getterLock lock]; <span class="comment">// 空值加锁</span></span><br><span class="line">        <span class="keyword">if</span> (!_aConfigManager) &#123; <span class="comment">// 二次判断</span></span><br><span class="line">            _aConfigManager = [[FileAConfigManager alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">        [_getterLock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _aConfigManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (FileBConfigManager *)bConfigManager &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_bConfigManager) &#123;</span><br><span class="line">        [_getterLock lock];<span class="comment">// 空值加锁</span></span><br><span class="line">        <span class="keyword">if</span> (!_bConfigManager) &#123;<span class="comment">// 二次判断</span></span><br><span class="line">            _bConfigManager = [[FileBConfigManager alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">        [_getterLock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _bConfigManager;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// FileAConfigManager.m</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)method &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 旧代码</span></span><br><span class="line"><span class="comment">    * id&lt;FileConfigManagerInterface&gt; bManager = [FileBConfigManager shareInstance]]; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新代码通过管理对象访问文件对象</span></span><br><span class="line">    <span class="type">id</span>&lt;FileConfigManagerInterface&gt; bManager = [[ConfigManager shareInstance] bConfigManager]; </span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好了， 进入页面，创建一个<code>PageConfigManager</code>， 初始化时都是一样的。 在进入页面后，更改的也只是操作当前<code>PageConfigManager</code>，不会影响到全局。 </p>
<p>这里， 还好原先设计的逻辑比较清晰， 而且 只有内部的类使用到了具体的文件管理对象。 对外接口是统一的，改起来还可以接受吧。也许之前场景没有考虑到后续的配置独立的需求，为了方便，使用了单例模式。随着需求的演进， 需要不断的对代码进行重构，以适应新的需求。</p>
<p>如果之前写代码的时候，不贪图这点方便，直接一步到位， 可能会是更好的设计。 后面，只需要直接用，或者继承一下就好了。</p>
<p>切记，设计模式不可滥用，但是好的设计必须要用到设计模式。 重构需要捋清楚各个类的关系，对外接口清晰，类职责单一。 </p>
<blockquote>
<p>今天是2019.90.30， 明天就是国庆了， 中华人民共和国建国70周年， 祖国生日快乐!! </p>
</blockquote>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>开发经验</tag>
        <tag>软件设计</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS接口的单元测试</title>
    <url>/2019/10/23/2019-20191023-iosunit-IOS/</url>
    <content><![CDATA[<h1 id="iOS接口的单元测试"><a href="#iOS接口的单元测试" class="headerlink" title="iOS接口的单元测试"></a>iOS接口的单元测试</h1><p>近期把一个业务复杂，功能繁多的库进行了拆分，实现了功能的单一性。代码重构告一段落，功能验证并且提测了，在QA测试阶段，终于闲下来把单元测试的代码也进行拆分与补充了。</p>
<p>现在就来聊聊iOS代码的单元测试。</p>
<p>单元测试本质上就是对我们写的代码接口进行执行，传入特定的参数，返回执行结果，然后对比结果与期望的值是否一致，确定功能是否执行正确。</p>
<span id="more"></span>

<h2 id="单元测试流程"><a href="#单元测试流程" class="headerlink" title="单元测试流程"></a>单元测试流程</h2><p>不同于其他语言，Objective-C可以通过苹果官方的编辑器XCode提供的XCTest框架很方便的进行测试，可以不需要额外的第三方框架进行基础的单元测试。而JavaScript语言(jest)、C语言(CUnit)等需要专门的库才能作测试。</p>
<p>现在，我们公司iOS开发属于组件化开发，各个组件的代码都是在一个独立的库，工程通过<code>cocoapods</code>管理。这样有一个好处，就是每个库的功能单一，接口少，代码都是由特定的一个或者几个人员维护，开发人员对代码比较熟悉，单元测试都是可以对所有文件的接口进行覆盖测试，还可以通过Xcode直观的看到每个文件的测试覆盖率。在代码入库检视时，检视人把好单元测试的关，很容易推动他人对代码作单元测试，提高代码的质量。</p>
<p>下面讲一下我是如何作单元测试的</p>
<h3 id="如何开始单元测试"><a href="#如何开始单元测试" class="headerlink" title="如何开始单元测试"></a>如何开始单元测试</h3><p>每个组件库代码都是一个由<code>cocoapods</code>管理的<code>workspace</code>工程组织的，构建最终输出是一个个<code>.a</code></p>
<ul>
<li>创建一个target， 类型为 iOS Unit Testing Bundle</li>
<li>在target下创建一个文件，继承XCTTestCase, 编写单元测试代码</li>
<li>工程选中对应的test target， 设置 Target Dependencies, Link Binart with Libraries 为库的target</li>
<li>编译执行test  target （快捷键 command + U）</li>
</ul>
<p>每个测试用例的重复代码可以写在 <code>setUp</code>&#x2F;<code>tearDown</code>方法里， 分别为公共前置代码编写、资源清理的处理。</p>
<p><img src="/images/20191023/unit1.png"></p>
<h3 id="异步接口测试"><a href="#异步接口测试" class="headerlink" title="异步接口测试"></a>异步接口测试</h3><p>针对一些异步执行的接口， XCTest提供了<code>XCTestExpectation</code>来实现。</p>
<p>由于项目代码不便提供，这边请允许我偷个懒， 从<code>SDWebImage</code>库上摘录一些测试代码O(∩_∩)O哈哈~</p>
<p><img src="/images/20191023/unit2.png"></p>
<p>在回调里面，根据传入的参数判断是否符合预期， 是则调用fullfil方法，否则调用报错。</p>
<h3 id="添加文件测试"><a href="#添加文件测试" class="headerlink" title="添加文件测试"></a>添加文件测试</h3><ul>
<li>添加文件到test target</li>
<li>使用 <code>bundleForClass:</code>获取正确的bundle，再访问bundle路径下的具体文件。</li>
</ul>
<p><img src="/images/20191023/unit3.png"></p>
<h3 id="使用OCMock进行代码mock"><a href="#使用OCMock进行代码mock" class="headerlink" title="使用OCMock进行代码mock"></a>使用OCMock进行代码mock</h3><p>对于复杂的对象，可能会有许多成员。但是这些成员是不容易获得的， 我们可以通过OCMock模拟该成员，对部分函数进行打桩，达到期待的结果。</p>
<p>OCMock是一个库， 通过 podfile 引入该库， 然后根据文档进行操作。 具体文档可以访问<a href="http://ocmock.org/">链接</a></p>
<h3 id="使用OHHTTPStubs-对网络接口进行mock"><a href="#使用OHHTTPStubs-对网络接口进行mock" class="headerlink" title="使用OHHTTPStubs 对网络接口进行mock"></a>使用OHHTTPStubs 对网络接口进行mock</h3><p>有些接口需要访问网络才能返回正常的结果，可以使用OHHTTPStubs这个库对网络请求进行打桩，根据请求的request确定是否要进行打桩。</p>
<p><img src="/images/20191023/unit4.png"></p>
<h3 id="查看代码覆盖率"><a href="#查看代码覆盖率" class="headerlink" title="查看代码覆盖率"></a>查看代码覆盖率</h3><ul>
<li>工程Edit Scheme -&gt; Test -&gt; Options -&gt; Gather coverage for xxx </li>
<li>跑一遍单元测试， 查看结果</li>
</ul>
<p><img src="/images/20191023/unit5.png"></p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>一般的接口功能的单元测试，掌握以上部分就可以了。 如果还有性能的测试、或者UI的测试可以看官网文档。</p>
<p>更多查看<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html#//apple_ref/doc/uid/TP40014132-CH1-SW1">苹果文档</a></p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>为工程添加单元测试， 我们可能需要对已有代码进行重构， 使之可以是可被测试的。 通过单元测试代码的运行，可以很容易发现隐藏的问题, 不会引入新问题。 单元测试是代码质量的一个可靠的保障手段，好的团队应该对其代码进行单元测试。当然这里有巨大的工作量，但是是值得的。 以为本次代码重构的经历而言， 设计占2&#x2F;5, 写代码4&#x2F;15, 单元测试大概1&#x2F;3. 比例大概为 6:4:5。 单元测试还是花了许多时间，但中间也发现了一些问题， 这些问题在前面功能自测的时候并没有发现，代码检视过程中也没有发现，单元测试的时候发现了，不枉我花了时间啊O(∩_∩)O哈哈~。 单元测试算是一个迭代的过程吧， 也有一点一劳永逸的感觉。</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreDump的使用</title>
    <url>/2019/12/24/2019-20191224-CoreDump-JOB/</url>
    <content><![CDATA[<p>在linux下开发的工程师们对CoreDump肯定都不陌生，但凡有些许经验的工程师都或多或少使用过CoreDump文件定位过崩溃问题。之前工作中，在Android系统下开发C++程序时， 经常用到CoreDump。 中间转行去搞iOS已经五年了， 最近换了新工作，遇到程序宕掉同事让我看一下coredump文件，一时还没有反应过来， 今天好好复习一下。</p>
<span id="more"></span>

<p>coredump文件是在程序出错而异常中断时，系统保存的状态文件。工程师可以通过gdb相应的程序，跟上coredump文件，还原程序崩溃时的状态，正常都可以从中查看到崩溃时的调用栈。</p>
<h2 id="如何使系统创建coredump文件"><a href="#如何使系统创建coredump文件" class="headerlink" title="如何使系统创建coredump文件"></a>如何使系统创建coredump文件</h2><p>默认系统时不会开启coredump功能的， 需要我们使用命令打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用ulimit -c 查看是否打开coredump， 如果返回为0则没有打开</span><br><span class="line">Keep:raw_blog keep$ ulimit -c</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">// 我们可以使用ulimit -c unlimited 打开coredump功能，并且不限制文件大小。 也可以指定一个数值， 单位为KB</span><br><span class="line"></span><br><span class="line">Keep:raw_blog keep$ ulimit -c unlimited</span><br><span class="line">Keep:raw_blog keep$ </span><br><span class="line">Keep:raw_blog keep$ ulimit -c</span><br><span class="line">unlimited</span><br><span class="line">Keep:raw_blog keep$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用命令打开的话， 只有当前终端生效。 如果要使系统生效的话， 需要修改&#x2F;etc&#x2F;security&#x2F;limits.conf文件</p>
<h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><p>默认coredump文件在程序所在目录下生成，并且文件名为core。 可以通过修改&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern来控制生成的路径及文件名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/temp/core-%e-%p-%t  // 在temp目录下， 文件名为 core-程序名-pid-时间</span><br></pre></td></tr></table></figure>

<p>还可以通过在程序中，调用系统函数设置coredump的文件大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int setrlimit(int resource, const struct rlimit *rlimt);</span><br></pre></td></tr></table></figure>

<h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 生成core文件后， 使用gdb查看信息</span><br><span class="line"></span><br><span class="line">gdb  program corefile</span><br></pre></td></tr></table></figure>


<p>macos 的core文件默认生成到&#x2F;cores&#x2F;目录下</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>由于mac上面没有安装gdb， 就用lldb来演示了</p>
<p>问题代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errorFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        sum /= i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    errorFunction();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Keep:temp keep$ lldb ./m -c /cores/core.1172 </span><br><span class="line">(lldb) target create &quot;./m&quot; --core &quot;/cores/core.1172&quot;</span><br><span class="line">Core file &#x27;/cores/core.1172&#x27; (x86_64) was loaded.</span><br><span class="line">(lldb) bt</span><br><span class="line">* thread #1, stop reason = signal SIGSTOP</span><br><span class="line">  * frame #0: 0x0000000101497f84 m`errorFunction + 52</span><br><span class="line">    frame #1: 0x0000000101497fa4 m`main + 20</span><br><span class="line">    frame #2: 0x00007fff6f43d3d5 libdyld.dylib`start + 1</span><br><span class="line">    frame #3: 0x00007fff6f43d3d5 libdyld.dylib`start + 1</span><br><span class="line">(lldb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们从中可以看到栈顶函数是errorFunction， 结合代码分析一下，很容易发现问题。</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>暂时解放了</title>
    <url>/2021/01/05/2021-20210105-sjs/</url>
    <content><![CDATA[<h1 id="暂时解放了"><a href="#暂时解放了" class="headerlink" title="暂时解放了"></a>暂时解放了</h1><p>O(∩_∩)O哈哈~，舒坦啊。折磨了我快一年多的肾结石终于出来了。</p>
<span id="more"></span>

<p>还记得去年的这个时候的一个周日，天气很冷，躺在被窝里，腰酸疼的不行，上卫生间的时候发现小bian还带血，以为出了什么大的事情了。后来想到不久前的体检，右边肾脏中下盏有一颗大小为0.72cmX0.57cm的结石，上知乎查了一下，知道这个是血尿了，估计和自己近期频繁跑步有关，结石进入了输尿管，划破流血了。</p>
<p>然后大概今年三、四个月的时候，第一次发作时还在上班，右腰有点钻心的疼，汗液也止不住的流啊，扛不住的我第一次因病立马放弃工作，请假回家休息，在床上趴了一段时间才慢慢好转，那时候只有自己一个人在长沙，真是孤独凄惨~。就这样过去了。</p>
<p>到五月份左右，腰部又开始疼痛的，感觉事态有点大了，预约了几天后去医院检查。到医院做了个B超，显示距离肾门69mm处有一个10X6mm的强光团，好家伙 长大了不少啊。医生建议做手术，我先谢绝了，回家想想。上知乎继续查，手术貌似挺可怕的，不打算做，继续忍忍吧。淘宝上开始买排石的茶喝了。</p>
<img src="/images/202012/sjs0.jpeg" alt="图片替换文本" width="600" height="313" align="bottom" />

<img src="/images/202012/sjs1.jpeg" alt="图片替换文本" width="600" height="313" align="bottom" />

<p>期间买了跳绳开始跳，又过了一个月再去检查一下。这次B超竟然说没找到了，估计跑下去了一点。回家后，上京东买了一盒日本的优客龙吃，直到吃完，期间也有继续喝排石茶，一直没有排出来。哎！不过暂时也没有腰痛的情况了。</p>
<p>直到这个月初，感觉堵在了下体。还隐约流了一点血，可能快出来了吧，这个时候尿频，下体还挺疼的。然后大量喝水，依旧没有出来，同时再在京东上买了一盒优客龙。周末回去福州参加了大学同学的婚礼，在福州家里面的时候，感觉快出来了，一天在卫生间蹲好几个小时，不过下体没有那么疼了，还以为是不是出来了。周日下午就坐动车来长沙上班，在卫生间又发现尿血了，赶紧喝水，继续等待它出来。然后就是今天了，早上刚睡醒，上卫生间，噗通一声，感觉有东西碰到马桶，还有一点舒坦的感觉。xxx略过。 看下这个折磨我一年多的家伙吧，少儿不宜，O(∩_∩)O哈哈~。</p>
<img src="/images/202012/sjs2.jpeg" alt="图片替换文本" width="600" height="313" align="bottom" />

<img src="/images/202012/sjs3.jpeg" alt="图片替换文本" width="600" height="313" align="bottom" />


<p>好家伙，竟然有12X6mm这么大了。可怕可怕。这玩意也没有很硬，用纸包住，用力捏一下就碎掉了。看来喝茶吃药还是有效果的。</p>
<p>终于解放了，至少短时间内腰应该不会疼了。 坚持+科学的锻炼喝水吃药，最终还是会迎来胜利的。以后还是需要多注意饮水，多运动。</p>
<p>虽然艰难，但省了手术，省了遭罪。。。 </p>
<p>注意身体，伙伴们。 （20201223写）</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(十五) - 内存管理</title>
    <url>/2021/01/06/2021-20210106-linux15-mm/</url>
    <content><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>每个进程应该自己的内存空间。内存空间都是独立的、相互隔离的。对于每个进程来讲，看起来应该都是独占的。每个程序对内存的操作都是一致的，内存的管理是进程无关的， 不会因为进程的不同而区别对待，而都是一视同仁的。在最开始的时候，已经了解到程序对内存的操作都是通过虚拟地址实现的，就比如一个大数组，比如超过4kb的大小，已经超过一个页了，但是虚拟地址一定是连续的。只是物理地址就不大可能会是连续的了，通过分段分页的虚拟地址映射实现了物理地址的复用。</p>
<span id="more"></span>

<h2 id="独立内存空间"><a href="#独立内存空间" class="headerlink" title="独立内存空间"></a>独立内存空间</h2><p>程序的二进制格式都是一致的，仅仅内容、大小不一样而已。进程就是运行的程序，运行过程中还会产生一些数据，运行程序和数据都是放在内存里面的。内存有分页机制，通过虚拟地址和物理的地址的映射可以定位到物理地址。物理地址对进程是不可见的，操作系统的内存管理帮忙作了工作。操作系统会给进程分配一个虚拟地址。所有进程看到的这个地址都是一样的，里面的内存都是从 0 开始编号。在程序里面，指令写入的地址是虚拟地址。当程序要访问虚拟地址的时候，由内核的数据结构进行转换，转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p>
<h2 id="规划虚拟地址空间"><a href="#规划虚拟地址空间" class="headerlink" title="规划虚拟地址空间"></a>规划虚拟地址空间</h2><p>操作系统的内存管理，主要分为三个方面。</p>
<p>第一，虚拟内存空间的管理，每个进程看到的是独立的、互不干扰的虚拟地址空间；</p>
<p>第二，物理内存的管理，物理内存地址只有内存管理模块能够使用；</p>
<p>第三，内存映射，需要将虚拟内存和物理内存映射、关联起来。</p>
<p>如果是 32 位，有 2^32 &#x3D; 4G 的内存空间都是我的，不管内存是不是真的有 4G。如果是 64 位，在 x86_64 下面，其实只使用了 48 位，那也挺恐怖的。48 位地址长度也就是对应了 256TB 的地址空间。至少目前还不需求这么大，过个十几二十年时间没准会突破吧，历史经验。</p>
<p>虚拟空间一切二，一部分用来放内核的东西，称为内核空间，一部分用来放进程的东西，称为用户空间。用户空间在下，在低地址.内核空间在上，在高地址.</p>
<p>用户态空间从最低位开始排起，先是 Text Segment、Data Segment 和 BSS Segment。Text Segment 是存放二进制可执行代码的位置，Data Segment 存放静态常量，BSS Segment 存放未初始化的静态变量。接下来是堆（Heap）段。堆是往高地址增长的，是用来动态分配内存的区域，malloc 就是在这里面分配的。接下来的区域是 Memory Mapping Segment。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将 so 文件映射到了内存中。再下面就是栈（Stack）地址段。主线程的函数调用的函数栈就是用这里的。</p>
<img src="/images/202101/mm0.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />
 
<p>内核空间和用户空间构造也差不多。一般用不到，暂时不深究了。以后深入研究的时候再抽空了解一下。</p>
<p><code> cat proc/$PID/maps</code> 可以查看各个地址上是哪些东西。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(十七) - 虚拟内存管理</title>
    <url>/2021/01/16/2021-20210116-linux17-mm/</url>
    <content><![CDATA[<h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><p>整个虚拟内存空间要一分为二，一部分是用户态地址空间，一部分是内核态地址空间，那这两部分的分界线在哪里呢？这就要 task_size 来定义。</p>
<span id="more"></span>

<img src="/images/202101/mm1.jpg" alt="图片替换文本" width="600" height="413" align="bottom" />

<p>在内核任务结构 struct task_struct里面有一个成员保存内存管理信息的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct mm_struct    *mm;</span><br></pre></td></tr></table></figure>


<h2 id="用户态布局"><a href="#用户态布局" class="headerlink" title="用户态布局"></a>用户态布局</h2><p>用户态虚拟空间里面有几类数据，例如代码、全局变量、堆、栈、内存映射区等。在 struct mm_struct 里面，有下面这些变量定义了这些区域的统计信息和位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mmap_base;  <span class="comment">/* base of mmap area */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> total_vm;    <span class="comment">/* Total pages mapped */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> locked_vm;  <span class="comment">/* Pages that have PG_mlocked set */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pinned_vm;  <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> data_vm;    <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> exec_vm;    <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stack_vm;    <span class="comment">/* VM_STACK */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>total_vm 是总共映射的页的数目。我们知道，这么大的虚拟地址空间，不可能都有真实内存对应，所以这里是映射的数目。当内存吃紧的时候，有些页可以换出到硬盘上，有的页因为比较重要，不能换出。locked_vm 就是被锁定不能换出，pinned_vm 是不能换出，也不能移动。</p>
<p>data_vm 是存放数据的页的数目，exec_vm 是存放可执行文件的页的数目，stack_vm 是栈所占的页的数目。</p>
<p>start_code 和 end_code 表示可执行代码的开始和结束位置，start_data 和 end_data 表示已初始化数据的开始位置和结束位置。</p>
<p>start_brk 是堆的起始位置，brk 是堆当前的结束位置。</p>
<p>start_stack 是栈的起始位置，栈的结束位置在寄存器的栈顶指针中。</p>
<p>arg_start 和 arg_end 是参数列表的位置， env_start 和 env_end 是环境变量的位置。它们都位于栈中最高地址的地方。</p>
<p>mmap_base 表示虚拟地址空间中用于内存映射的起始地址。</p>
<img src="/images/202101/mm_usr.jpg" alt="图片替换文本" width="600" height="713" align="bottom" />

<p>除了位置信息之外，struct mm_struct 里面还专门有一个结构 vm_area_struct，来描述这些区域的属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">  <span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> vm_start;    <span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> vm_end;    <span class="comment">/* The first byte after our end address within vm_mm. */</span></span><br><span class="line">  <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>  <span class="comment">/* The address space we belong to. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">            * page_table_lock */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>  <span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line">  <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>    <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">  <span class="type">void</span> * vm_private_data;    <span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>vm_start 和 vm_end 指定了该区域在用户空间中的起始和结束地址。vm_next 和 vm_prev 将这个区域串在链表上。vm_rb 将这个区域放在红黑树上。vm_ops 里面是对这个内存区域可以做的操作的定义。</p>
<p>虚拟内存区域可以映射到物理内存，也可以映射到文件，映射到物理内存的时候称为匿名映射，anon_vma 中，anoy 就是 anonymous，匿名的意思，映射到文件就需要有 vm_file 指定被映射的文件。</p>
<p>内存的映射建立是由函数load_elf_binary来完成的。</p>
<img src="/images/202101/mm_map.jpeg" alt="图片替换文本" width="600" height="713" align="bottom" />

<p>执行 brk 处理内存申请的操作，实现的入口是 sys_brk 函数。sys_brk 函数的参数 brk 是新的堆顶位置，而当前的 mm-&gt;brk 是原来堆顶的位置。</p>
<p>将原来的堆顶和现在的堆顶，都按照页对齐地址，然后比较大小。如果两者相同，说明这次增加的堆的量很小，还在一个页里面，不需要另行分配页，直接跳到 set_brk 那里，设置 mm-&gt;brk 为新的 brk 就可以了。如果发现新旧堆顶不在一个页里面，麻烦了，这下要跨页了。</p>
<p>如果发现新堆顶小于旧堆顶，这说明不是新分配内存了，而是释放内存了，释放的还不小，至少释放了一页，于是调用 do_munmap 将这一页的内存映射去掉。</p>
<p>如果堆将要扩大，就要调用 find_vma。如果打开这个函数，看到的是对红黑树的查找，找到的是原堆顶所在的 vm_area_struct 的下一个 vm_area_struct，看当前的堆顶和下一个 vm_area_struct 之间还能不能分配一个完整的页。如果不能，没办法只好直接退出返回，内存空间都被占满了。如果还有空间，就调用 do_brk 进一步分配堆空间，从旧堆顶开始，分配计算出的新旧堆顶之间的页数。</p>
<p>在 do_brk 中，调用 find_vma_links 找到将来的 vm_area_struct 节点在红黑树的位置，找到它的父节点、前序节点。接下来调用 vma_merge，看这个新节点是否能够和现有树中的节点合并。如果地址是连着的，能够合并，则不用创建新的 vm_area_struct 了，直接跳到 out，更新统计值即可；如果不能合并，则创建新的 vm_area_struct，既加到 anon_vma_chain 链表中，也加到红黑树中。</p>
<h2 id="内核态布局"><a href="#内核态布局" class="headerlink" title="内核态布局"></a>内核态布局</h2><p>内核态的虚拟空间和某一个进程没有关系，所有进程通过系统调用进入到内核之后，看到的虚拟地址空间都是一样的。内核态空间只有一份，共享的。</p>
<img src="/images/202101/mm_kernel.jpg" alt="图片替换文本" width="600" height="713" align="bottom" />


<p>32 位的内核态虚拟地址空间一共就 1G，占绝大部分的前 896M，我们称为直接映射区。所谓的直接映射区，就是这一块空间是连续的，和物理内存是非常简单的映射关系，其实就是虚拟内存地址减去 3G，就得到物理内存的位置。</p>
<p>这 896M 还需要仔细分解。在系统启动的时候，物理内存的前 1M 已经被占用了，从 1M 开始加载内核代码段，然后就是内核的全局变量、BSS 等，也是 ELF 里面涵盖的。这样内核的代码段，全局变量，BSS 也就会被映射到 3G 后的虚拟地址空间里面。具体的物理内存布局可以查看 &#x2F;proc&#x2F;iomem。</p>
<p>创建进程的系统调用会创建一个task_struct的实例， 这个实例就是保存在内核的直接映射区域内 即896MB的内存中。</p>
<p>内核态地址：</p>
<p>在 896M 到 VMALLOC_START 之间有 8M 的空间。VMALLOC_START 到 VMALLOC_END 之间称为内核动态映射空间，也即内核想像用户态进程一样 malloc 申请内存，在内核里面可以使用 vmalloc。假设物理内存里面，896M 到 1.5G 之间已经被用户态进程占用了，并且映射关系放在了进程的页表中，内核 vmalloc 的时候，只能从分配物理内存 1.5G 开始，就需要使用这一段的虚拟地址进行映射，映射关系放在专门给内核自己用的页表里面。</p>
<p>PKMAP_BASE 到 FIXADDR_START 的空间称为持久内核映射。使用 alloc_pages() 函数的时候，在物理内存的高端内存得到 struct page 结构，可以调用 kmap 将其映射到这个区域。</p>
<p>FIXADDR_START 到 FIXADDR_TOP(0xFFFF F000) 的空间，称为固定映射区域，主要用于满足特殊需求。</p>
<p>在最后一个区域可以通过 kmap_atomic 实现临时内核映射。如果要把文件内容写入物理内存，这件事情要内核来干了，这就只好通过 kmap_atomic 做一个临时映射，写入物理内存完毕后，再 kunmap_atomic 来解映射即可。</p>
<p>64位系统的内核布局也是同样的道理，不过是大小不一样，设计的功能区不一样。</p>
<img src="/images/202101/mm_kernel64.jpg" alt="图片替换文本" width="600" height="713" align="bottom" />



<p>进程虚拟内存的布局和物理内存的布局， 分别通过查看proc&#x2F;$PID&#x2F;maps 和 &#x2F;proc&#x2F;iomem。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(十六) - 内存映射</title>
    <url>/2021/01/12/2021-20210112-linux16-mm/</url>
    <content><![CDATA[<h1 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h1><h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><p>在linux上分段机制的使用主要用于权限的判断，具体内存的访问采用的是分页机制。</p>
<span id="more"></span>

<p>分段就是通过段选择子+段内偏移量来定位物理地址，通过段选择子获取段描述符，段描述符存在GDT 全局描述符表中，包含了段的起始地址、大小、权限标志等。</p>
<img src="/images/202101/mm_seg.jpg" alt="图片替换文本" width="600" height="313" align="bottom" />

<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p>对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为换出。一旦需要的时候，再加载进来，叫做换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率。</p>
<p>这个换入和换出都是以页为单位的。页面的大小一般为 4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了。</p>
<img src="/images/202101/mm_page.jpg" alt="图片替换文本" width="600" height="313" align="bottom" />

<p>虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。原理和分段的类似， 之前是段表，这里是页表。</p>
<p>但是，每个页的大小为4K，对于32位系统，支持4GB的寻址空间，那么就有1MB个页，每个页对于一个页表项(每项4字节)，需要4MB的内存存储这个映射。显然空间浪费太大，而且并不是每个页表都会被程序使用到。那么就有了页表分级。</p>
<p>把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K。页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置。</p>
<img src="/images/202101/mm_page_sec.jpg" alt="图片替换文本" width="400" height="513" align="bottom" />

<p>尽管看起来表示全部页表的项更多了，占用的空间会更大。但是，进程如果没有用到所有的地址，很多页表是不需要创建的。如果只使用页表，也需要完整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省多了。</p>
<p>64位系统表示的范围更大，就多分几级的页表。具体的是4级目录。通过分级目录节约了内存。分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。</p>
<img src="/images/202101/mm_page_64.jpg" alt="图片替换文本" width="400" height="513" align="bottom" />

<p>内存分页管理的内容：</p>
<ul>
<li><p>第一，虚拟内存空间的管理，将虚拟内存分成大小相等的页；</p>
</li>
<li><p>第二，物理内存的管理，将物理内存分成大小相等的页；</p>
</li>
<li><p>第三，内存映射，将虚拟内存页和物理内存页映射起来，并且在内存紧张的时候可以换出到硬盘中。</p>
</li>
</ul>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(十八) -物理内存管理</title>
    <url>/2021/01/20/2021-20210120-linux18-pmm/</url>
    <content><![CDATA[<h1 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h1><h2 id="物理内存的组织方式"><a href="#物理内存的组织方式" class="headerlink" title="物理内存的组织方式"></a>物理内存的组织方式</h2><p>把内存想象成它是由连续的一页一页的块组成的。我们可以从 0 开始对物理页编号，这样每个物理页都会有个页号。物理内存按固定的页大小划分为多个页，连续的内存分配给连续页号的页。对于任何一个地址，只要直接除一下每页的大小，很容易直接算出在哪一页。每个页有一个结构 struct page 表示，这个结构也是放在一个数组里面，这样根据页号，很容易通过下标找到相应的 struct page 结构。整个物理内存的布局就非常简单、易管理，这就是最经典的平坦内存模型（Flat Memory Model）。</p>
<span id="more"></span>

<p>内存是一整块的，对内存的访问是通过总线的，多个CPU都需要通过总线访问内存，总线会成为瓶颈，这种方式为对称多处理器。后来有了一种更高级的模式，NUMA（Non-uniform memory access），非一致内存访问。在这种模式下，内存不是一整块。每个 CPU 都有自己的本地内存，CPU 访问本地内存不用过总线，因而速度要快很多，每个 CPU 和内存在一起，称为一个 NUMA 节点。但是，在本地内存不足的情况下，每个 CPU 都可以去另外的 NUMA 节点申请内存，这个时候访问延时就会比较长。内存模型就变成了非连续内存模型，管理起来就复杂一些。再后来，支持热插拔内存，不连续成为常态，于是就有了稀疏内存模型。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>NUMA（Non-uniform memory access）非连续内存访问节点？</p>
<p>linux源码中，有对应的结构体<code>struct pglist_data</code>，包含了</p>
<ul>
<li>node_id</li>
<li>node_mem_map 就是这个节点的 struct page 数组，用于描述这个节点里面的所有的页；</li>
<li>node_start_pfn 是这个节点的起始页号</li>
<li>node_spanned_pages 是这个节点中包含不连续的物理内存地址的页面数  &#x2F;&#x2F; total sizeof physical pages range including holes</li>
<li>node_present_pages &#x2F;&#x2F; total number of physical pages 真正可用的物理页数量</li>
</ul>
<p>例如，64M 物理内存隔着一个 4M 的空洞，然后是另外的 64M 物理内存。这样换算成页面数目就是，16K 个页面隔着 1K 个页面，然后是另外 16K 个页面。这种情况下，node_spanned_pages 就是 33K 个页面，node_present_pages 就是 32K 个页面。</p>
<p>每一个节点分成一个个区域 zone，放在数组 node_zones 里面。这个数组的大小为 MAX_NR_ZONES。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">  ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">  ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">  ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ZONE_MOVABLE,</span><br><span class="line">  __MAX_NR_ZONES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不同的ZONE有不同的用途，具体的：</p>
<p>ZONE_DMA 是指可用于作 DMA（Direct Memory Access，直接内存存取）的内存。DMA 是这样一种机制：要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过 CPU 控制完成，但是这会占用 CPU，影响 CPU 处理其他事情，所以有了 DMA 模式。CPU 只需向 DMA 控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，这样就可以解放 CPU。本人现在所处的项目也有对应的dma的程序，主要用来向控制面传送数据的， 不占用转发面的处理逻辑。间接的实现转发面和控制面的隔离，跟这里的DMA还是有点区别。</p>
<p>ZONE_NORMAL 是直接映射区，从物理内存到虚拟内存的内核区域，通过加上一个常量直接映射。</p>
<p>ZONE_HIGHMEM 是高端内存区，对于 32 位系统来说超过 896M 的地方，对于 64 位没必要有的一段区域。</p>
<p>ZONE_MOVABLE 是可移动区域，通过将物理内存划分为可移动分配区域和不可移动分配区域来避免内存碎片。</p>
<p>这边对于区域的划分，都是针对物理内存的。</p>
<p>nr_zones 表示当前节点的区域的数量。node_zonelists 是备用节点和它的内存区域的情况。具体如何搞的备用节点，需要抽空看一下源码对应这部分的处理。 TODO:</p>
<p>就像区域或者页一样，节点也是存在一个数组里面的。 至于这个节点数，跟具体cpu数一致。每个CPU分配一个节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">node_data</span>[<span class="title">MAX_NUMNODES</span>] __<span class="title">read_mostly</span>;</span> <span class="comment">// numa.c</span></span><br></pre></td></tr></table></figure>


<h2 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span>;</span></span><br></pre></td></tr></table></figure>

<p>在一个 zone 里面，zone_start_pfn 表示属于这个 zone 的第一个页。</p>
<p>spanned_pages &#x3D; zone_end_pfn - zone_start_pfn，也即 spanned_pages 指的是不管中间有没有物理内存空洞，反正就是最后的页号减去起始的页号。</p>
<p>present_pages &#x3D; spanned_pages - absent_pages(pages in holes)，也即 present_pages 是这个 zone 在物理内存中真实存在的所有 page 数目。</p>
<p>managed_pages &#x3D; present_pages - reserved_pages，也即 managed_pages 是这个 zone 被伙伴系统管理的所有的 page 数目。</p>
<p>per_cpu_pageset 用于区分冷热页。如果一个页被加载到 CPU 高速缓存里面，这就是一个热页（Hot Page），CPU 读起来速度会快很多，如果没有就是冷页（Cold Page）。由于每个 CPU 都有自己的高速缓存，因而 per_cpu_pageset 也是每个 CPU 一个。</p>
<h2 id="页"><a href="#页" class="headerlink" title="页"></a>页</h2><p>物理内存首先是被拆分成页这种单位的。 然后组成区域， 区域再组成节点。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br></pre></td></tr></table></figure>

<p>这个结构体是由多个union组成的， 这在嵌入式系统中很常见，一个是为了复用内存，一个是实现类似抽象类&#x2F;父类的功能。根据内存页被使用的模式，使用对应的成员。</p>
<h3 id="整页使用"><a href="#整页使用" class="headerlink" title="整页使用"></a>整页使用</h3><p>这一整页的内存，或者直接和虚拟地址空间建立映射关系，我们把这种称为匿名页（Anonymous Page）。或者用于关联一个文件，然后再和虚拟地址空间建立映射关系，这样的文件，我们称为内存映射文件（Memory-mapped File）。</p>
<p>如果某一页是这种使用模式，则会使用 union 中的以下变量：</p>
<ul>
<li>struct address_space *mapping 就是用于内存映射，如果是匿名页，最低位为 1；如果是映射文件，最低位为 0；</li>
<li>pgoff_t index 是在映射区的偏移量；</li>
<li>atomic_t _mapcount，每个进程都有自己的页表，这里指有多少个页表项指向了这个页；</li>
<li>struct list_head lru 表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中；</li>
<li>compound 相关的变量用于复合页（Compound Page），就是将物理上连续的两个或多个页看成一个独立的大页。</li>
</ul>
<h3 id="小块内存使用"><a href="#小块内存使用" class="headerlink" title="小块内存使用"></a>小块内存使用</h3><p>有时候，我们不需要一下子分配这么多的内存，例如分配一个 task_struct 结构，只需要分配小块的内存，去存储这个进程描述结构的对象。为了满足对这种小内存块的需要，Linux 系统采用了一种被称为 slab allocator 的技术，用于分配称为 slab 的一小块内存。它的基本原理是从内存管理模块申请一整块页，然后划分成多个小块的存储池，用复杂的队列来维护这些小块的状态（状态包括：被分配了 &#x2F; 被放回池子 &#x2F; 应该被回收）。</p>
<p>如果某一页是用于分割成一小块一小块的内存进行分配的使用模式，则会使用 union 中的以下变量：</p>
<ul>
<li>s_mem 是已经分配了正在使用的 slab 的第一个对象；</li>
<li>freelist 是池子中的空闲对象；</li>
<li>rcu_head 是需要释放的列表。</li>
</ul>
<h1 id="页分配"><a href="#页分配" class="headerlink" title="页分配"></a>页分配</h1><p>对于要分配比较大的内存，例如到分配页级别的，可以使用伙伴系统（Buddy System）。</p>
<p>针对页级别的分配，把所有的空闲页分组为 11 个页块链表，每个块链表分别包含很多个大小的页块，有 1、2、4、8、16、32、64、128、256、512 和 1024 个连续页的页块。最大可以申请 1024 个连续页，对应 4MB 大小的连续内存。每个页块的第一个页的物理地址是该页块大小的整数倍。</p>
<img src="/images/202101/mm_buddy.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />
 
<p>在<code>struct zone</code>里面有这样的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>  <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br></pre></td></tr></table></figure>

<p>存储每个区域不同指数级空闲的内存。</p>
<p>当向内核请求分配 (2^(i-1)，2^i]数目的页块时，按照 2^i 页块请求处理。如果对应的页块链表中没有空闲页块，那我们就在更大的页块链表中去找。当分配的页块中有多余的页时，伙伴系统会根据多余的页块大小插入到对应的空闲页块链表中。</p>
<p>具体的分配算法可以看alloc_pages_current(mm&#x2F;mempolicy.c)函数， 其实没有什么高深的， 如我此等常人页看得明白。复杂的东西都是由简单的器件组合而成的。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>2020年小结</title>
    <url>/2021/02/01/2021-20210201-design/</url>
    <content><![CDATA[<h1 id="2020年小结"><a href="#2020年小结" class="headerlink" title="2020年小结"></a>2020年小结</h1><p>嗯，的确这个年度小结来的有点儿迟了。2021年都过了一个月了，惭愧。在过去的一个多月里面，一直在忙着作新项目的性能优化工作，在不断的试验(Start-&gt;编译-重启-配置-测试-&gt;Start 循环)中渡过，会发现每天时间都过得很快。 还是有点怀念华为的补丁技术，以及RN的动态更新功能。虽然本人也花了点时间了解了一下补丁技术，奈何对系统平台还有这个交叉编译器没有足够的知识储备，性能优化的任务也比较急，只能一遍遍的重启验证，呵呵。</p>
<span id="more"></span>

<p>2020年应该算个大灾之年了，笼罩着疫情的阴霾。怎么也想不到，竟然戴着口罩渡过了这么一年。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>工作上，经历了两三个项目的开发与维护，可以熟练的、自如的应对工作了，没有遇到特别大的困难。除了熟悉了一些业务，对系统的模块分工也有了更多一点的了解。还有一块打的工作，就是做的性能优化了。 有做了算法逻辑的优化，代码架构的优化，还有就是代码语法层面的优化。效果还是有的，近期那个项目提升了百分之一百五十，很不错了。从30多GB蹭一下到了80多GB。</p>
<h2 id="学习-x2F-读书"><a href="#学习-x2F-读书" class="headerlink" title="学习&#x2F;读书"></a>学习&#x2F;读书</h2><p>年初疫情的时候，在微信读书上面完整的细读了一遍《明朝那些事儿》、《羊皮卷》。</p>
<p>技术上面，复习了一下《C语言程序设计语言》。 重读了一遍《程序员的自我修养-链接、装载与库》，并在之后粗粗的再过了一遍，并写了些博文小结。 在极客时间上面，又刷了一遍王铮的《数据结构与算法》专栏，活跃了一下脑回路；范学雷的《代码精进之路》，产生了许多共鸣。刘建国的《技术管理实战36讲》，学习一下技术人的处世方法。宋宁的《说透敏捷》，重温了下在华为的敏捷开发流程。还刷了两遍《趣谈Linux操作系统》， 目前还在博文小结阶段。说实话，极客时间上面的专栏质量都挺不错的， 只要静下心来学，还是有收获的，毕竟付费的嘛，作者还是会下点功夫，搞点干货的。目前学习的目标还是想把基础捡起来，稍微巩固一下。2021年的话，学习的目标应该转向架构，系统这块，深入钻研一下Linux代码，然后读一些管理方面的书,当然还有工作所需的新知识。准备考个软件架构师证书。</p>
<h2 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h2><p>经济上，一家四口都指着我的那微薄的工资和前几年攒下的十几万老本，年底的时候首付了台车，^_^ 老本快折腾完了。今年大好的股市行情，基本上完美踏空了，上半年挣了个七八千 就匆匆撤退了，理财这个东西，还是得坚持滴，而且得用真正的闲钱。今年没有结余，仅剩负债了。月月入不敷出，得改变一下子了。</p>
<h2 id="生活-x2F-运动"><a href="#生活-x2F-运动" class="headerlink" title="生活&#x2F;运动"></a>生活&#x2F;运动</h2><p>家有两宝，在家的生活重心就是带娃、带娃、带娃。一般晚上下班之后，回到家就没有个人的时间了。首先，回家先得看看有没有菜，么有的话就去楼下的生鲜店买点菜啊，肉啊。 老婆只管着煮饭，烧菜的事基本上就是我来了，一般七点到家，七点半煮好饭，吃完饭的话就八点了。小孩子喜欢玩，就陪着玩玩，晚上的时间过得很快，轮流洗洗澡，就十点多、快十一点的样子了，然后睡觉了。第二天，长沙的天还没亮就起床洗漱一下，七点半出门，八点过几分到办公大厦，楼下吃个早点，然后上班，一天就又开始了。时间过的相当充实了，有时候要学习的话 就留在公司自我充电一下，八点半再回去。 周末的话，由于上班大小周，也没多少个休息日。周末上午，小孩子睡懒觉，我自己看会儿书或者听听音频，^_^ 基本上出不了门，老婆做做家务啥的。吃过午饭出去走走逛逛，一天就过去了。 至于运动， 呵呵， 在福州的时候还可以利用一下早上的时间，奈何长沙这天亮的太迟了，七点半才全亮，早晨的运动时间就没了。一整年就跑了两三次步吧，一身肥肉又上身了，哎！！！欣慰的是，可恶的肾结石终于在药物的作用下，加长时间的喝水习惯，biubiu出来了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>年底的时候，收获了一份还不错的岗位，还是做嵌入式开发，嗯，2021年回福州去了。 长沙我来过了，试过了，没什么遗憾了。小孩不是很适应这边的气候，基本上每个月都会感冒发烧，两个娃不是一起中招就是前后接力，伤身费钱。工作上面的确没有很大的提升，尽管当前所在的行业属于一个旱涝保收的赛道，但是我还是希望能够有更好的发展，接受更大的挑战，提升自我。尽管这边的工作量不是很大(一般不会强制加班，最迟也就到八点半的样子)。OK，就这样了。人生就像下面这照片一样，朦胧的，抬头看看还可以感觉到有高度，有目标要追求，加油!!</p>
<img src="/images/202101/WechatIMG97.jpeg" alt="图片替换文本" width="300" height="613" align="bottom" />


<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>墨菲定律的应验</title>
    <url>/2021/01/25/2021-20210125-mofei/</url>
    <content><![CDATA[<h1 id="墨菲定律的应验"><a href="#墨菲定律的应验" class="headerlink" title="墨菲定律的应验"></a>墨菲定律的应验</h1><p>其实第一次接触这个概念是在科幻电影《星际穿越》里，没看过的同学可以去看一下。“墨菲定律”的根本内容是“凡是可能出错的事有很大几率会出错”，指的是任何一个事件，只要具有大于零的机率，就不能够假设它不会发生。</p>
<span id="more"></span>

<p>最近呢， 项目里面也有这么个类似的问题出现了。 功能就是就是多线程对数据条目进行管理，根据添加时间对数据项进行删除操作。首先会根据数据项的元信息生成key，按key把数据项的索引信息存入到一张hash表中，数据项的内容存在一个线性的地址池中，索引就是数据项所在地址的下标。一般而言，如果对数据项进行添加删除，需要同时对hash表和地址池进行加锁保护，之前的版本也的确是这样子。结果呢，由于项目的性能不满足需求，同组的同事就希望可以取巧，通过设置标志位的方式，减少对地址池数据项的加锁保护。进行了一系列的操作:</p>
<ul>
<li>在老化之前读取标志位，如果标志位有效，则对hash表加锁，判断是否达到老化时间，删除hash表项，并修改标志为为0，解锁hash表。删除结束。</li>
<li>添加的时候加锁查询hash表是否存在表项，如果不存在则添加到hash表中，先解锁hash表。然后再修改标志位为1. 添加结束。</li>
</ul>
<p>本来以为代码跑的是这样子的。<br><img src="/images/202101/mofei0.jpeg" alt="图片替换文本" width="600" height="413" align="bottom" /></p>
<p>结果跑成这样了。</p>
<img src="/images/202101/mofei1.jpeg" alt="图片替换文本" width="600" height="413" align="bottom" />

<p>按数字过一下，应该就可以发现最终标志位和hash表并不是一致的。标志位为1的时候，hash表中不一定有对应的表项。</p>
<p>多线程，并不是说只有2个线程，是多个线程，这种时序是不可控的。该加锁的东西就加锁,像这种临界资源，一定要确保互斥，不能搞一半放一半的。</p>
<p>这个问题，同事修改之后还是有做了认真的自验的， 我在自己搭建的环境上也帮忙跑了一两天都没有复现出问题，但是测试那边跑个一段时间就出现了。^_^  写代码的时候先设计好还是很重要的，不能想当然。 后面把锁的范围恢复到之前那样，问题也就不再复现了。。。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(十九) -物理内存管理</title>
    <url>/2021/02/03/2021-20210203-linux19-pmm/</url>
    <content><![CDATA[<h1 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h1><p>前面讲了内存页的分配机制，还有小块内存的分配机制。</p>
<span id="more"></span>

<h2 id="小块内存分配"><a href="#小块内存分配" class="headerlink" title="小块内存分配"></a>小块内存分配</h2><p>遇到小的对象，会使用 slub 分配器进行分配。</p>
<p>创建进程的时候，会调用 dup_task_struct，它想要试图复制一个 task_struct 对象，需要先调用 alloc_task_struct_node，分配一个 task_struct 对象。调用了 kmem_cache_alloc_node 函数，在 task_struct 的缓存区域 task_struct_cachep 分配了一块内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> // 缓存结构</span></span><br></pre></td></tr></table></figure>

<p>缓存结构里面，包含了缓存的名称， 缓存对象的大小等信息。</p>
<p>对于缓存来讲，其实就是分配了连续几页的大内存块，然后根据缓存对象的大小，切成小内存块。slba缓存的信息可以通过查看&#x2F;proc&#x2F;slabinfo查看系统创建的所有slab缓存。</p>
<img src="/images/202102/slabinfo.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />
 

<p>有2个成员用来管理缓存，分别是kmem_cache_cpu 和 kmem_cache_node，它们都是每个 NUMA 节点上有一个，我们只需要看一个节点里面的情况。</p>
<img src="/images/202102/slabnode.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />
 
<p>在分配缓存块的时候，要分两种路径，fast path 和 slow path，也就是快速通道和普通通道。其中 kmem_cache_cpu 就是快速通道，kmem_cache_node 是普通通道。每次分配的时候，要先从 kmem_cache_cpu 进行分配。如果 kmem_cache_cpu 里面没有空闲的块，那就到 kmem_cache_node 中进行分配；如果还是没有空闲的块，才去伙伴系统分配新的页。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">  <span class="type">void</span> **freelist;  <span class="comment">/* Pointer to next available object */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tid;  <span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>  <span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span>  <span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，page 指向大内存块的第一个页，缓存块就是从里面分配的。freelist 指向大内存块里面第一个空闲的项。按照上面说的，这一项会有指针指向下一个空闲的项，最终所有空闲的项会形成一个链表。partial 指向的也是大内存块的第一个页，之所以名字叫 partial（部分），就是因为它里面部分被分配出去了，部分是空的。这是一个备用列表，当 page 满了，就会从这里找。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> list_lock;</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里面也有一个 partial，是一个链表。这个链表里存放的是部分空闲的内存块。这是 kmem_cache_cpu 里面的 partial 的备用列表，如果那里没有，就到这里来找。</p>
<p>分配整个过程很冗长， 总的来说就是一级级的申请内存，如果申请不到 就到上一级申请，成功之后然后继续申请。</p>
<h2 id="页面换出"><a href="#页面换出" class="headerlink" title="页面换出"></a>页面换出</h2><p>由于物理内存大小有限，一段时间不被使用的页面会被暂时换出到磁盘，然后将空出的物理内存，交给活跃的进程去使用。</p>
<h3 id="触发页面换出的时机"><a href="#触发页面换出的时机" class="headerlink" title="触发页面换出的时机"></a>触发页面换出的时机</h3><p>最常见的情况就是，分配内存的时候，发现没有地方了，就试图回收一下。</p>
<p>还有一种情况，就是作为内存管理系统应该主动去做的，而不能等真的出了事儿再做，这就是内核线程 kswapd。这个内核线程，在系统初始化的时候就被创建。这样它会进入一个无限循环，直到系统停止。在这个循环中，如果内存使用没有那么紧张，那它就可以放心睡大觉；如果内存紧张了，就需要去检查一下内存，看看是否需要换出一些内存页。</p>
<p>调用链是 balance_pgdat-&gt;kswapd_shrink_node-&gt;shrink_node，是以内存节点为单位的，最后也是调用 shrink_node。所有的页面都被挂在 LRU 列表中。LRU 是 Least Recent Use，也就是最近最少使用。也就是说，这个列表里面会按照活跃程度进行排序，这样就容易把不怎么用的内存页拿出来做处理。shrink_list 会先缩减活跃页面列表，再压缩不活跃的页面列表。对于不活跃列表的缩减，shrink_inactive_list 就需要对页面进行回收；对于匿名页来讲，需要分配 swap，将内存页写入文件系统；对于内存映射关联了文件的，我们需要将在内存中对于文件的修改写回到文件中。</p>
<p>通过配置cat &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness 来确定swap的使用时机，该值默认值是60.<br>swappiness&#x3D;0的时候表示最大限度使用物理内存，然后才是 swap空间，<br>swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二十) -内存映射</title>
    <url>/2021/02/03/2021-20210203-linux20-mmap/</url>
    <content><![CDATA[<h1 id="用户态内存映射"><a href="#用户态内存映射" class="headerlink" title="用户态内存映射"></a>用户态内存映射</h1><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span> <span class="comment">/* list of VMAs */</span></span><br><span class="line">......&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在进程的mm_struct有一个mmap的成员, 是内存映射的一个重要结构。内存映射不仅仅是物理内存和虚拟内存之间的映射，还包括将文件中的内容映射到虚拟内存空间。</p>
<span id="more"></span>

<p>如果申请一大块内存，就要用 mmap。对于堆的申请来讲，mmap 是映射内存空间到物理内存。另外，如果一个进程想映射一个文件到自己的虚拟内存空间，也要通过 mmap 系统调用。这个时候 mmap 是映射内存空间到物理内存再到文件。</p>
<p>mmap系统调用的调用链是 vm_mmap_pgoff-&gt;do_mmap_pgoff-&gt;do_mmap。这里面主要干了两件事情：</p>
<ul>
<li>调用 get_unmapped_area 找到一个没有映射的区域；</li>
<li>调用 mmap_region 映射这个区域。</li>
</ul>
<p>通过mmap，我们主要就是建立了空间的访问逻辑所需要的一些结构，还没有涉及到具体的物理内存映射。</p>
<h2 id="用户态缺页"><a href="#用户态缺页" class="headerlink" title="用户态缺页"></a>用户态缺页</h2><p>一旦开始访问虚拟内存的某个地址，如果我们发现，并没有对应的物理页，那就触发缺页中断，调用 do_page_fault。<br>在 __do_page_fault 里面，先要判断缺页中断是否发生在内核， 地址是否大于TASK_SIZE_MAX。如果发生在内核则调用 vmalloc_fault，在内核里面，vmalloc 区域需要内核页表映射到物理页。在用户空间里面，找到你访问的那个地址所在的区域 vm_area_struct，然后调用 handle_mm_fault 来映射这个区域。</p>
<p>handle_mm_fault函数里面会设置进程对应的页表的几级目录信息。当进程在CPU上运行时，会在上下文切换时调用load_new_mm_cr3，保存pgd地址到cr3寄存器，如果 CPU 的指令要访问进程的虚拟内存，它就会自动从 cr3 里面得到 pgd 在物理内存的地址，然后根据里面的页表解析虚拟内存的地址为物理内存，从而访问真正的物理内存上的数据。</p>
<p>用户进程在运行的过程中，访问虚拟内存中的数据，会被 cr3 里面指向的页表转换为物理地址后，才在物理内存中访问数据，这个过程都是在用户态运行的，地址转换的过程无需进入内核态。</p>
<p>只有访问虚拟内存的时候，发现没有映射到物理内存，页表也没有创建过，才触发缺页异常。进入内核调用 do_page_fault，一直调用到 __handle_mm_fault。原来没有创建过页表，那只好补上这一课。于是，__handle_mm_fault 调用 pud_alloc 和 pmd_alloc，来创建相应的页目录项，最后调用 handle_pte_fault 来创建页表项。</p>
<p>大体上就是先找一遍页表，找不到就创建，直到把物理地址的映射写到页表里面，再根据基地址加偏移的方式获取对应的物理地址，然后访问。 这边如果是映射的文件， 那就是对应找到文件在内存中的缓存页，读取里面的内容。 如果页被换出了，那就把它换入 再定位。 具体的流程很长，但是逻辑还是清晰的， 不同类型的页作不同的动作，最终都会获取到一个内存的物理地址。</p>
<p>从这块逻辑看，其实用的就是缓存的技术，懒加载，定时换入换出等逻辑。先找没有找再去创建。同样的，为了提高映射速度，我们引入了 TLB（Translation Lookaside Buffer），我们经常称为快表，专门用来做地址映射的硬件设备。它不在内存中，可存储的数据比较少，但是比内存要快。所以，我们可以想象，TLB 就是页表的 Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。有了 TLB 之后，地址映射的过程就像图中画的。我们先查块表，块表中有映射关系，然后直接转换为物理地址。如果在 TLB 查不到映射关系时，才会到内存中查询页表。</p>
<p>我编写了一个mmap系统调用的文件共享内存，代码在<a href="https://github.com/fishmwei/blog_code/blob/master/linux-kernel/mmap_file.c">github</a>上，有兴趣的同学可以看看。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二十一) -内存映射</title>
    <url>/2021/02/04/2021-20210204-linux21-mmap/</url>
    <content><![CDATA[<h1 id="内核态内存映射"><a href="#内核态内存映射" class="headerlink" title="内核态内存映射"></a>内核态内存映射</h1><h2 id="内核页表"><a href="#内核页表" class="headerlink" title="内核页表"></a>内核页表</h2><p>在系统初始化的时候，我们就要创建内核页表了。</p>
<span id="more"></span>

<p>内核页表的根 swapper_pg_dir， 在 arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;pgtable_64.h 中就能找到它的定义。swapper_pg_dir 指向内核最顶级的目录 pgd，同时出现的还有几个页表目录。其中 XXX_ident_pgt 对应的是直接映射区，XXX_kernel_pgt 对应的是内核代码区，XXX_fixmap_pgt 对应的是固定映射区。</p>
<p>在汇编语言的文件里面的 arch\x86\kernel\head_64.S初始化这些页表的值，具体的汇编语言看不懂，呵呵。知道他们定义在__INITDATA 里面就可以了。页表的根其实是全局变量，这就使得我们初始化的时候，甚至内存管理还没有初始化的时候，很容易就可以定位到。最后定义成如下 一个树形的结构：</p>
<img src="/images/202102/kernel_mmap.png" alt="图片替换文本" width="600" height="513" align="bottom" />
 
<p>内核页表定义完了，一开始这里面的页表能够覆盖的内存范围比较小。例如，内核代码区 512M，直接映射区 1G。这个时候，其实只要能够映射基本的内核代码和数据结构就可以了。可以看出，里面还空着很多项，可以用于将来映射巨大的内核虚拟地址空间，等用到的时候再进行映射。</p>
<p>用户态进程页表，会有 mm_struct 指向进程顶级目录 pgd，对于内核来讲，也定义了一个 mm_struct，指向 swapper_pg_dir，名为init_mm。</p>
<p>在初始化的时候会调用setup_arch初始化init_mm的成员，创建虚拟地址和物理地址的映射页表。</p>
<h2 id="vmalloc-和-kmap-atomic-原理"><a href="#vmalloc-和-kmap-atomic-原理" class="headerlink" title="vmalloc 和 kmap_atomic 原理"></a>vmalloc 和 kmap_atomic 原理</h2><p>在虚拟地址空间里面，有个 vmalloc 区域，从 VMALLOC_START 开始到 VMALLOC_END，可以用于映射一段物理内存。</p>
<p>从vmalloc的函数注释可以看出， 这个函数会从页分配器中分配足够大小的页，然后映射到vmalloc区域</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * vmalloc - allocate virtually contiguous memory </span></span><br><span class="line"><span class="comment">  * @size: allocation size </span></span><br><span class="line"><span class="comment">  * Allocate enough pages to cover @size from the page level </span></span><br><span class="line"><span class="comment">  * allocator and map them into contiguous kernel virtual space. </span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * For tight control over page level allocator and protection flags * use __vmalloc() instead. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核的临时映射函数 kmap_atomic</p>
<p>如果是 32 位有高端地址的，就需要调用 set_pte 通过内核页表进行临时映射；如果是 64 位没有高端地址的，就调用 page_address，里面会调用 lowmem_page_address。其实低端内存的映射，会直接使用 __va 进行临时映射。</p>
<h2 id="内核态缺页异常"><a href="#内核态缺页异常" class="headerlink" title="内核态缺页异常"></a>内核态缺页异常</h2><p>kmap_atomic 发现，没有页表的时候，就直接创建页表进行映射了。而 vmalloc 没有，它只分配了内核的虚拟地址。所以，访问它的时候，会产生缺页异常。内核态的缺页异常还是会调用 do_page_fault，然后调用vmalloc_fault， 关联内核页表项。</p>
<img src="/images/202102/mm_map.png" alt="图片替换文本" width="600" height="713" align="bottom" />



<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二十二) - 文件系统</title>
    <url>/2021/02/04/2021-20210204-linux22-fm/</url>
    <content><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>对于运行的进程来说，内存就像一个纸箱子，仅仅是一个暂存数据的地方，而且空间有限。如果我们想要进程结束之后，数据依然能够保存下来，就不能只保存在内存里，而是应该保存在外部存储中，比如磁盘，数据是以文件的形式保存在硬盘上的。文件系统就是对文件进行管理的模块。</p>
<span id="more"></span>

<h2 id="文件系统功能"><a href="#文件系统功能" class="headerlink" title="文件系统功能"></a>文件系统功能</h2><ul>
<li>文件固定格式</li>
<li>文件的索引</li>
<li>常用文件缓存</li>
<li>文件应该用文件夹的形式组织起来，方便管理和查询</li>
</ul>
<p>在文件系统中，每个文件都有一个名字，这样我们访问一个文件，希望通过它的名字就可以找到。文件名就是一个普通的文本。当然文件名会经常冲突，不同用户取相同的名字的情况还是会经常出现的。文件的树形结构如下：</p>
<img src="/images/202102/file_tree.png" alt="图片替换文本" width="600" height="713" align="bottom" />

<ul>
<li>要在自己的内存里面维护一套数据结构，来保存哪些文件被哪些进程打开和使用。</li>
</ul>
<h2 id="文件系统相关命令行"><a href="#文件系统相关命令行" class="headerlink" title="文件系统相关命令行"></a>文件系统相关命令行</h2><p>使用fdisk命令对磁盘进行格式化、分区等操作。</p>
<p>使用mount命令将分区挂在到指定的目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount /dev/vdc1 /根目录/用户A目录/目录1</span><br></pre></td></tr></table></figure>

<p>umount命令卸载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">umount /根目录/用户A目录/目录1</span><br></pre></td></tr></table></figure>

<p>ls -l命令查看文件类型, 通过第一个字节判断文件的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Keep:raw_blog keep$ ls -l</span><br><span class="line">total 376</span><br><span class="line">-rw-r--r--    1 keep  staff    4722 Jun  4  2020 1.patch</span><br><span class="line">-rw-r--r--@   1 keep  staff     425 Jun  3  2020 README.md</span><br><span class="line">-rw-r--r--    1 keep  staff    2389 Dec 23 15:52 _config.yml</span><br><span class="line">-rw-r--r--    1 keep  staff     174 Feb  4 16:35 db.json</span><br><span class="line">drwxr-xr-x  325 keep  staff   10400 Jun  8  2020 node_modules</span><br></pre></td></tr></table></figure>

<p><code>-</code> 表示普通文件；d 表示文件夹；c 表示字符设备文件；b 表示块设备文件；s 表示套接字 socket 文件；l 表示符号链接，也即软链接，就是通过名字指向另外一个文件</p>
<h2 id="文件系统相关系统调用"><a href="#文件系统相关系统调用" class="headerlink" title="文件系统相关系统调用"></a>文件系统相关系统调用</h2><p>open 打开文件， 操作系统会创建一些数据结构来表示这个被打开的文件。为了能够找到这些数据结构，在进程中，我们会为这个打开的文件分配一个文件描述符 fd（File Descriptor）。文件描述符，就是用来区分一个进程打开的多个文件的。它的作用域就是当前进程，出了当前进程这个文件描述符就没有意义了。open 返回的 fd 必须记录好，我们对这个文件的所有操作都要靠这个 fd，包括最后关闭文件。</p>
<p>在 Open 函数中，有一些参数：</p>
<ul>
<li>O_CREAT 表示当文件不存在，创建一个新文件；</li>
<li>O_RDWR 表示以读写方式打开；</li>
<li>O_TRUNC 表示打开文件后，将文件的长度截断为 0。</li>
</ul>
<p>write写入数据，第一个参数就是文件描述符，第二个参数表示要写入的数据存放位置，第三个参数表示希望写入的字节数，返回值表示成功写入到文件的字节数。</p>
<p>lseek 用于重新定位读写的位置，第一个参数是文件描述符，第二个参数是重新定位的位置，第三个参数是 SEEK_SET，表示起始位置为文件头，第二个参数和第三个参数合起来表示将读写位置设置为从文件头开始 0 的位置，也即从头开始读写。</p>
<p>read 用于读取数据，第一个参数是文件描述符，第二个参数是读取来的数据存到指向的空间，第三个参数是希望读取的字节数，返回值表示成功读取的字节数。</p>
<p>最终，close 将关闭一个文件。</p>
<p>文件信息的获取，可以通过下面几个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int stat(const char *pathname, struct stat *statbuf);</span><br><span class="line">int fstat(int fd, struct stat *statbuf);</span><br><span class="line">int lstat(const char *pathname, struct stat *statbuf);</span><br></pre></td></tr></table></figure>

<p>函数 stat 和 lstat 返回的是通过文件名查到的状态信息。这两个方法区别在于，stat 没有处理符号链接（软链接）的能力。如果一个文件是符号链接，stat 会直接返回它所指向的文件的属性，而 lstat 返回的就是这个符号链接的内容，fstat 则是通过文件描述符获取文件对应的属性。</p>
<p>文件系统概要：</p>
<img src="/images/202102/file_summary.png" alt="图片替换文本" width="600" height="713" align="bottom" />



<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二十五) - 文件读写</title>
    <url>/2021/02/06/2021-20210205-linux25-fileoperation/</url>
    <content><![CDATA[<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><p>文件创建、打开之后， 就是对其进行读写操作了。</p>
<span id="more"></span>

<h2 id="系统调用层和虚拟文件系统层"><a href="#系统调用层和虚拟文件系统层" class="headerlink" title="系统调用层和虚拟文件系统层"></a>系统调用层和虚拟文件系统层</h2><p>文件系统的读写，其实就是调用系统函数 read 和 write。</p>
<p>read 和 write 的系统调用，在内核里面的定义， 具体的在read_write.c里面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(read, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">char</span> __user *, buf, <span class="type">size_t</span>, count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget_pos(fd);</span><br><span class="line">......</span><br><span class="line">  <span class="type">loff_t</span> pos = file_pos_read(f.file);</span><br><span class="line">  ret = vfs_read(f.file, buf, count, &amp;pos);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(write, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">const</span> <span class="type">char</span> __user *, buf,</span><br><span class="line">    <span class="type">size_t</span>, count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget_pos(fd);</span><br><span class="line">......</span><br><span class="line">  <span class="type">loff_t</span> pos = file_pos_read(f.file);</span><br><span class="line">    ret = vfs_write(f.file, buf, count, &amp;pos);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 read 来讲，里面调用 vfs_read-&gt;__vfs_read。对于 write 来讲，里面调用 vfs_write-&gt;__vfs_write。<br>这里通过fd获取到struct fd。 struct fd里面保存了 struct file 和 flags。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct file里面有struct path和struct inode， struct path里面有 struct vfsmount 和struct dentry。</p>
<p>具体的读写， 最终调用到 file-&gt;f_op-&gt;read 和 file-&gt;f_op-&gt;write。</p>
<h2 id="ext4-文件系统层"><a href="#ext4-文件系统层" class="headerlink" title="ext4 文件系统层"></a>ext4 文件系统层</h2><p>对于 ext4 文件系统来讲，内核定义了一个 ext4_file_operations。里面就是对ext4文件系统的文件操作的回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ext4_file_operations</span> =</span> &#123;</span><br><span class="line">......</span><br><span class="line">  .read_iter  = ext4_file_read_iter,</span><br><span class="line">  .write_iter  = ext4_file_write_iter,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两种模式的读写操作， 一种是读缓存，缓存没有再读硬盘， 一种是直接读硬盘。</p>
<p>缓存其实就是内存中的一块空间。因为内存比硬盘快得多，Linux 为了改进性能，有时候会选择不直接操作硬盘，而是读写都在内存中，然后批量读取或者写入硬盘。一旦能够命中内存，读写效率就会大幅度提高。</p>
<p>根据是否使用内存做缓存，我们可以把文件的 I&#x2F;O 操作分为两种类型。</p>
<p>第一种类型是缓存 I&#x2F;O。大多数文件系统的默认 I&#x2F;O 操作都是缓存 I&#x2F;O。对于读操作来讲，操作系统会先检查，内核的缓冲区有没有需要的数据。如果已经缓存了，那就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。对于写操作来讲，操作系统会先将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说，写操作就已经完成。至于什么时候再写到磁盘中由操作系统决定，除非显式地调用了 sync 同步命令。</p>
<p>第二种类型是直接 IO，就是应用程序直接访问磁盘数据，而不经过内核缓冲区，从而减少了在内核缓存和用户程序之间数据复制。</p>
<p>具体的就是看你参数里面有没有设置IOCB_DIRECT了。设置的话就直接从硬盘进行读写，否则会先处理缓存。由于文件系统是块设备，所以最终调用的是 blockdev 相关的函数。</p>
<h2 id="带缓存的写入操作"><a href="#带缓存的写入操作" class="headerlink" title="带缓存的写入操作"></a>带缓存的写入操作</h2><p>在__generic_file_write_iter函数里面，根据flags是否设置IOCB_DIRECT就分别处理里， 最后都调用了带缓存写入的函数generic_perform_write。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">generic_perform_write</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> iov_iter *i, <span class="type">loff_t</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span> =</span> mapping-&gt;a_ops;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset;  <span class="comment">/* Offset into pagecache page */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bytes;  <span class="comment">/* Bytes to write to page */</span></span><br><span class="line">    status = a_ops-&gt;write_begin(file, mapping, pos, bytes, flags,</span><br><span class="line">            &amp;page, &amp;fsdata);</span><br><span class="line">    copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);</span><br><span class="line">    flush_dcache_page(page);</span><br><span class="line">    status = a_ops-&gt;write_end(file, mapping, pos, bytes, copied,</span><br><span class="line">            page, fsdata);</span><br><span class="line">    pos += copied;</span><br><span class="line">    written += copied;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    balance_dirty_pages_ratelimited(mapping);</span><br><span class="line">  &#125; <span class="keyword">while</span> (iov_iter_count(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是一个do…while循环，具体就是做以下的工作：</p>
<ul>
<li>对于每一页，先调用 address_space 的 write_begin 做一些准备；</li>
<li>调用 iov_iter_copy_from_user_atomic，将写入的内容从用户态拷贝到内核态的页中；</li>
<li>调用 address_space 的 write_end 完成写操作；</li>
<li>调用 balance_dirty_pages_ratelimited，看脏页是否太多，需要写回硬盘。所谓脏页，就是写入到缓存，但是还没有写入到硬盘的页面。</li>
</ul>
<p>第一步ext4_write_begin</p>
<p>ext4 是一种日志文件系统，日志文件系统比非日志文件系统多了一个 Journal 区域。文件在 ext4 中分两部分存储，一部分是文件的元数据，另一部分是数据。元数据和数据的操作日志 Journal 也是分开管理的。他有3个模式，需要在挂载文件系统的时候设置，也可以后续通过<code>tune2fs</code>命令设置，具体的就没去操作了。</p>
<ul>
<li><strong>日志（Journal）模式</strong>  这种模式在将数据写入文件系统前，必须等待元数据和数据的日志已经落盘才能发挥作用。这样性能比较差，但是最安全。</li>
<li><strong>order 模式</strong> 这个模式不记录数据的日志，只记录元数据的日志，但是在写元数据的日志前，必须先确保数据已经落盘。这个折中，是默认模式。</li>
<li><strong>writeback</strong> 不记录数据的日志，仅记录元数据的日志，并且不保证数据比元数据先落盘。这个性能最好，但是最不安全。</li>
</ul>
<p>在 ext4_write_begin，我们能看到对于 ext4_journal_start 的调用，就是在做日志相关的工作。在 ext4_write_begin 中，还做了另外一件重要的事情，就是调用 grab_cache_page_write_begin，来得到应该写入的缓存页。</p>
<p>在内核中，缓存以页为单位放在内存里面，那我们如何知道，一个文件的哪些数据已经被放到缓存中了呢？每一个打开的文件都有一个 struct file 结构，每个 struct file 结构都有一个 struct address_space 用于关联文件和内存，就是在这个结构里面，有一棵树，用于保存所有与这个文件相关的的缓存页。我们查找的时候，往往需要根据文件中的偏移量找出相应的页面，而基数树 radix tree 这种数据结构能够快速根据一个长整型查找到其相应的对象，因而这里缓存页就放在 radix 基数树里面。如果找不到，那就创建一个缓存页。</p>
<p>第二步，调用 iov_iter_copy_from_user_atomic。先将分配好的页面调用 kmap_atomic 映射到内核里面的一个虚拟地址，然后将用户态的数据拷贝到内核态的页面的虚拟地址中，调用 kunmap_atomic 把内核里面的映射删除。为什么要拷贝呢，因为这是一个系统调用， 需要在内核安全的地方进行操作，当然需要在内核空间了。</p>
<p>第三步，调用 ext4_write_end 完成写入。这里面会调用 ext4_journal_stop 完成日志的写入，会调用 block_write_end-&gt;__block_commit_write-&gt;mark_buffer_dirty，将修改过的缓存标记为脏页。可以看出，其实所谓的完成写入，并没有真正写入硬盘，仅仅是写入缓存后，标记为脏页。</p>
<p>第四步，调用 balance_dirty_pages_ratelimited，是回写脏页的一个很好的时机。</p>
<p>在 balance_dirty_pages_ratelimited 里面，发现脏页的数目超过了规定的数目，就调用 balance_dirty_pages-&gt;wb_start_background_writeback，启动一个背后线程开始回写。这里需要葬爷数目超过规定的数目才进行写。如果永远不超过，就需要另外一个机制了，定时回写。这里不详细讲了。 </p>
<p>当然，除了被动回写， 用户也可以主动调用sync， 立马触发回写，同步脏页。</p>
<h2 id="带缓存的读操作"><a href="#带缓存的读操作" class="headerlink" title="带缓存的读操作"></a>带缓存的读操作</h2><p>对应的是函数 generic_file_buffered_read。</p>
<p>在 generic_file_buffered_read 函数中，我们需要先找到 page cache 里面是否有缓存页。如果没有找到，不但读取这一页，还要进行预读，这需要在 page_cache_sync_readahead 函数中实现。预读完了以后，再试一把查找缓存页，应该能找到了。如果第一次找缓存页就找到了，我们还是要判断，是不是应该继续预读；如果需要，就调用 page_cache_async_readahead 发起一个异步预读。最后，copy_page_to_iter 会将内容从内核缓存页拷贝到用户内存空间。</p>
<img src="/images/202102/read_write.png" alt="图片替换文本" width="600" height="513" align="bottom" />

<h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p>这边，struct address_space缓存页管理使用了基数树这种数据结构，radix树是一种针对稀疏的长整型数据查找，可以快速节省空间的完成映射。可以基于长整型快速路由到叶子节点，叶子节点保存具体的数据。具体实现见radix-tree.c文件。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二十六) - 输入输出系统</title>
    <url>/2021/02/07/2021-20210207-linux26-inout/</url>
    <content><![CDATA[<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><p>我们知道计算机由CPU、主板、硬盘、内存、鼠标、键盘、显示器、网卡等部件组成。 这里鼠标、键盘等是输入设备， 硬盘、显示器等是输出设备。网卡既是输入设备也算输出设备。这么多不同的设备，统一由输入输出系统来管理。</p>
<span id="more"></span>

<h2 id="用设备控制器屏蔽设备差异"><a href="#用设备控制器屏蔽设备差异" class="headerlink" title="用设备控制器屏蔽设备差异"></a>用设备控制器屏蔽设备差异</h2><p>计算机的是操作系统， 操作系统的核心是内核。进程管理、内存管理、文件系统管理、输入输出系统的管理都是内核的功能。输入输出管理，需要跟不同的设备打交道，但是设备多种多样，内核只能提供一个统一的抽象接口来管理设备，CPU 并不直接和设备打交道，它们中间有一个叫作设备控制器（Device Control Unit）的组件，例如硬盘有磁盘控制器、USB 有 USB 控制器、显示器有视频控制器等。</p>
<p>控制器其实有点儿像一台小电脑。它有它的芯片，类似小 CPU，执行自己的逻辑。它也有它的寄存器。这样 CPU 就可以通过写这些寄存器，对控制器下发指令，通过读这些寄存器，查看控制器对于设备的操作状态。CPU 对于寄存器的读写，可比直接控制硬件，要标准和轻松很多。</p>
<p>输入输出设备我们大致可以分为两类：块设备（Block Device）和字符设备（Character Device）</p>
<ul>
<li>块设备将信息存储在固定大小的块中，每个块都有自己的地址。硬盘就是常见的块设备。    </li>
<li>字符设备发送或接收的是字节流。而不用考虑任何块结构，没有办法寻址。鼠标就是常见的字符设备。</li>
</ul>
<p>由于块设备传输的数据量比较大，控制器里往往会有缓冲区。CPU 写入缓冲区的数据攒够一部分，才会发给设备。CPU 读取的数据，也需要在缓冲区攒够一部分，才拷贝到内存。</p>
<p>每个控制寄存器被分配一个 I&#x2F;O 端口，我们可以通过特殊的汇编指令（例如 in&#x2F;out 类似的指令）操作这些寄存器。数据缓冲区，可内存映射 I&#x2F;O，可以分配一段内存空间给它，就像读写内存一样读写数据缓冲区。</p>
<p>设备完成操作后，CPU有两种方式可以获取通知。 第一种， 就是轮询寄存器的状态位。 第二种，设备通过中断通知CPU处理。</p>
<p>为了响应中断，我们一般会有一个硬件的中断控制器，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU，一个中断产生了，CPU 需要停下当前手里的事情来处理中断。</p>
<p>中断有两种，一种软中断，例如代码调用 INT 指令触发，一种是硬件中断，就是硬件通过中断控制器触发的。</p>
<img src="/images/202102/io_int.jpg" alt="图片替换文本" width="600" height="513" align="bottom" />

<p>有的设备需要读取或者写入大量数据。这种类型的设备需要支持 DMA 功能，也就是说，允许设备在 CPU 不参与的情况下，能够自行完成对内存的读写。</p>
<p>CPU 只需要对 DMA 控制器下指令，说它想读取多少数据，放在内存的某个地方就可以了，接下来 DMA 控制器会发指令给磁盘控制器，读取磁盘上的数据到指定的内存位置，传输完毕之后，DMA 控制器发中断通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了。</p>
<img src="/images/202102/io_dma.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<h2 id="用驱动程序屏蔽设备控制器差异"><a href="#用驱动程序屏蔽设备控制器差异" class="headerlink" title="用驱动程序屏蔽设备控制器差异"></a>用驱动程序屏蔽设备控制器差异</h2><p>每种设备的控制器的寄存器、缓冲区等使用模式，指令都不同，操作系统需要通过驱动程序对接不同的设备控制器。设备驱动程序中是一些面向特殊设备控制器的代码。不同的设备不同。但是对于操作系统其它部分的代码而言，设备驱动程序应该有统一的接口。就像下面图中的一样，不同的设备驱动程序，可以以同样的方式接入操作系统，而操作系统的其它部分的代码，也可以无视不同设备的区别，以同样的接口调用设备驱动程序。</p>
<p>驱动程序就像一个适配层， 向上对操作系统提供统一的接口，向下对接具体的设备控制器。所有设备驱动程序都要，按照同样的规则，实现同样的方法。</p>
<p>设备驱动程序是用来对接设备控制器的，中断处理也在设备驱动里面完成。</p>
<p>中断的触发最终会到达 CPU，会中断操作系统当前运行的程序，所以操作系统也要有一个统一的流程来处理中断，使得不同设备的中断使用统一的流程。</p>
<p>一个设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。中断的时候，触发的函数是 do_IRQ。这个函数是中断处理的统一入口。在这个函数里面，我们可以找到设备驱动程序注册的中断处理函数 Handler，然后执行它进行中断处理。</p>
<img src="/images/202102/do_irq.jpg" alt="图片替换文本" width="600" height="513" align="bottom" />

<p>对于块设备来讲，在驱动程序之上，文件系统之下，还需要一层通用设备层。这一层通用块层，将与块设备相关的通用逻辑放在这一层，维护与设备无关的块的大小，然后通用块层下面对接各种各样的驱动程序。</p>
<h2 id="用文件系统接口屏蔽驱动程序的差异"><a href="#用文件系统接口屏蔽驱动程序的差异" class="headerlink" title="用文件系统接口屏蔽驱动程序的差异"></a>用文件系统接口屏蔽驱动程序的差异</h2><p>从硬件设备到设备控制器，到驱动程序，到通用块层，到文件系统，层层屏蔽不同的设备的差别，最终到这里涉及对用户使用接口，也要统一。操作设备，都是基于文件系统的接口，也要有一个统一的标准。</p>
<p>首先要统一的是设备名称。所有设备都在 &#x2F;dev&#x2F; 文件夹下面创建一个特殊的设备文件。这个设备特殊文件也有 inode，但是它不关联到硬盘或任何其他存储介质上的数据，而是建立了与某个设备驱动程序的连接。对于设备文件，ls 出来的内容和我们原来讲过的稍有不同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /dev</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">crw------- 1 root root      5,   1 Dec 14 19:53 console</span><br><span class="line">crw-r----- 1 root kmem      1,   1 Dec 14 19:53 mem</span><br><span class="line">crw-rw-rw- 1 root root      1,   3 Dec 14 19:53 null</span><br><span class="line">crw-r----- 1 root kmem      1,   4 Dec 14 19:53 port</span><br><span class="line">crw-rw-rw- 1 root root      1,   8 Dec 14 19:53 random</span><br><span class="line">crw--w---- 1 root tty       4,   0 Dec 14 19:53 tty0</span><br><span class="line">crw--w---- 1 root tty       4,   1 Dec 14 19:53 tty1</span><br><span class="line">crw-rw-rw- 1 root root      1,   9 Dec 14 19:53 urandom</span><br><span class="line">brw-rw---- 1 root disk    253,   0 Dec 31 19:18 vda</span><br><span class="line">brw-rw---- 1 root disk    253,   1 Dec 31 19:19 vda1</span><br><span class="line">brw-rw---- 1 root disk    253,  16 Dec 14 19:53 vdb</span><br><span class="line">brw-rw---- 1 root disk    253,  32 Jan  2 11:24 vdc</span><br><span class="line">crw-rw-rw- 1 root root      1,   5 Dec 14 19:53 zero</span><br></pre></td></tr></table></figure>

<p>主设备号相同，表示它们使用同样的字符设备驱动。</p>
<p>Linux 的驱动程序已经被写成和操作系统有标准接口的代码，可以看成一个标准的内核模块。在 Linux 里面，安装驱动程序，其实就是加载一个内核模块。可以通过lsmod查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lsmod</span></span><br><span class="line">Module                  Size  Used by</span><br><span class="line">iptable_filter         12810  1</span><br><span class="line">bridge                146976  1 br_netfilter</span><br><span class="line">vfat                   17461  0</span><br><span class="line">fat                    65950  1 vfat</span><br><span class="line">ext4                  571716  1</span><br><span class="line">cirrus                 24383  1</span><br><span class="line">crct10dif_pclmul       14307  0</span><br><span class="line">crct10dif_common       12595  1 crct10dif_pclmul</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有安装过相应的驱动，可以通过 insmod 安装内核模块。内核模块的后缀一般是 ko。</p>
<p>linux使用sysfs文件系统管理设备，在&#x2F;sys目录下面，可以查找到设备的信息。</p>
<p>在 &#x2F;sys 路径下有下列的文件夹：</p>
<ul>
<li>&#x2F;sys&#x2F;devices 是内核对系统中所有设备的分层次的表示；</li>
<li>&#x2F;sys&#x2F;dev 目录下一个 char 文件夹，一个 block 文件夹，分别维护一个按字符设备和块设备的主次号码 (major:minor) 链接到真实的设备 (&#x2F;sys&#x2F;devices 下) 的符号链接文件；</li>
<li>&#x2F;sys&#x2F;block 是系统中当前所有的块设备；</li>
<li>&#x2F;sys&#x2F;module 有系统中所有模块的信息。</li>
</ul>
<p>有了 sysfs 以后，我们还需要一个守护进程 udev。当一个设备新插入系统的时候，内核会检测到这个设备，并会创建一个内核对象 kobject 。 这个对象通过 sysfs 文件系统展现到用户层，同时内核还向用户空间发送一个热插拔消息。udevd 会监听这些消息，在 &#x2F;dev 中创建对应的文件。</p>
<img src="/images/202102/newdevice.jpg" alt="图片替换文本" width="600" height="513" align="bottom" />

<p>有些任务只使用读写很难完成，例如检查特定于设备的功能和属性，超出了通用文件系统的限制。所以，对于设备来讲，还有一种接口称为 ioctl，表示输入输出控制接口，是用于配置和修改特定设备属性的通用接口。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二十七) - 字符设备驱动</title>
    <url>/2021/02/08/2021-20210208-linux27-driver/</url>
    <content><![CDATA[<h1 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h1><p>鼠标和打印机都是字符设备，对应的驱动代码分别在drivers&#x2F;input&#x2F;mouse&#x2F;logibm.c、drivers&#x2F;char&#x2F;lp.c文件中。</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module_init(logibm_init);</span><br><span class="line">module_exit(logibm_exit);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(lp_init_module);</span><br><span class="line">module_exit(lp_cleanup_module);</span><br></pre></td></tr></table></figure>

<h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><p>驱动作为一个内核模块， 通过使用insmod加载到内核， 可以使用命令lsmod查看已经加载的内核。</p>
<img src="/images/202102/lsmod.jpeg" alt="图片替换文本" width="600" height="713" align="bottom" />

<p>构建一个内核模块需要几个部分：</p>
<h3 id="第一、头文件部分"><a href="#第一、头文件部分" class="headerlink" title="第一、头文件部分"></a>第一、头文件部分</h3><p>一般内核需要包含2个头文件，当然也可以包含更多其他头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="第二、定义一些函数，用于处理内核模块的主要逻辑。"><a href="#第二、定义一些函数，用于处理内核模块的主要逻辑。" class="headerlink" title="第二、定义一些函数，用于处理内核模块的主要逻辑。"></a>第二、定义一些函数，用于处理内核模块的主要逻辑。</h3><p>例如打开、关闭、读取、写入设备的函数或者响应中断的函数。</p>
<h3 id="第三部分，定义一个-file-operations-结构"><a href="#第三部分，定义一个-file-operations-结构" class="headerlink" title="第三部分，定义一个 file_operations 结构"></a>第三部分，定义一个 file_operations 结构</h3><p>设备要想被文件系统的接口操作，也需要类似的接口。</p>
<h3 id="第四部分，定义整个模块的初始化函数和退出函数"><a href="#第四部分，定义整个模块的初始化函数和退出函数" class="headerlink" title="第四部分，定义整个模块的初始化函数和退出函数"></a>第四部分，定义整个模块的初始化函数和退出函数</h3><p>用于加载和卸载这个 ko 的时候调用。</p>
<h3 id="第五部分，调用-module-init-和-module-exit"><a href="#第五部分，调用-module-init-和-module-exit" class="headerlink" title="第五部分，调用 module_init 和 module_exit"></a>第五部分，调用 module_init 和 module_exit</h3><p>分别指向上面两个初始化函数和退出函数。</p>
<h3 id="第六部分，声明一下-lisense，调用-MODULE-LICENSE。"><a href="#第六部分，声明一下-lisense，调用-MODULE-LICENSE。" class="headerlink" title="第六部分，声明一下 lisense，调用 MODULE_LICENSE。"></a>第六部分，声明一下 lisense，调用 MODULE_LICENSE。</h3><p>有了以上六个部分，模块就可以工作了。</p>
<h2 id="打开字符设备"><a href="#打开字符设备" class="headerlink" title="打开字符设备"></a>打开字符设备</h2><img src="/images/202102/opencd.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<p>使用字符设备，首先要写一个内核模块，然后通过insmod加载该模块， 加载模块会调用module_init调用的初始化函数。例如，在 lp.c 的初始化函数 lp_init 对应的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">lp_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> (register_chrdev (LP_MAJOR, <span class="string">&quot;lp&quot;</span>, &amp;lp_fops)) &#123;</span><br><span class="line">    printk (KERN_ERR <span class="string">&quot;lp: unable to get major %d\n&quot;</span>, LP_MAJOR);</span><br><span class="line">    <span class="keyword">return</span> -EIO;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __register_chrdev(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">unsigned</span> <span class="type">int</span> baseminor,</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">          <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span></span><br><span class="line">  <span class="type">int</span> err = -ENOMEM;</span><br><span class="line">......</span><br><span class="line">  cd = __register_chrdev_region(major, baseminor, count, name);</span><br><span class="line">  cdev = cdev_alloc();</span><br><span class="line">  cdev-&gt;owner = fops-&gt;owner;</span><br><span class="line">  cdev-&gt;ops = fops;</span><br><span class="line">  kobject_set_name(&amp;cdev-&gt;kobj, <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">  err = cdev_add(cdev, MKDEV(cd-&gt;major, baseminor), count);</span><br><span class="line">  cd-&gt;cdev = cdev;</span><br><span class="line">  <span class="keyword">return</span> major ? <span class="number">0</span> : cd-&gt;major;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符设备驱动的内核模块加载的时候，首先会注册这个字符设备。调用 __register_chrdev_region，注册字符设备的主次设备号(在major.h定义好了)和名称，然后分配一个 struct cdev 结构，将 cdev 的 ops 成员变量指向这个模块声明的 file_operations。然后，cdev_add 会将这个字符设备添加到内核中一个叫作 struct kobj_map *cdev_map 的结构，来统一管理所有字符设备。</p>
<p>其中，MKDEV(cd-&gt;major, baseminor) 表示将主设备号和次设备号生成一个 dev_t 的整数，然后将这个整数 dev_t 和 cdev 关联起来。</p>
<p>这里对于鼠标这种输入设备，又被封装了一层， 通过input.c来管理。</p>
<p>内核模块加载完毕后，接下来要通过 mknod 在 &#x2F;dev 下面创建一个设备文件，只有有了这个设备文件，我们才能通过文件系统的接口，对这个设备文件进行操作。mknod会让设备和这个文件关联起来， 创建一个inode节点，保存文件的操作最终调用的是设备的操作。打开的话， 从文件系统的open, 一直到调用驱动的open，打开设备。</p>
<h2 id="写入字符设备"><a href="#写入字符设备" class="headerlink" title="写入字符设备"></a>写入字符设备</h2><p>对于文件的读写操作也和文件的读写操作一样，只是最终调用到的是驱动的读写函数。</p>
<img src="/images/202102/lp_wr.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<h2 id="使用-IOCTL-控制设备"><a href="#使用-IOCTL-控制设备" class="headerlink" title="使用 IOCTL 控制设备"></a>使用 IOCTL 控制设备</h2><p>对于 I&#x2F;O 设备来讲，我们前面也说过，除了读写设备，还会调用 ioctl，做一些特殊的 I&#x2F;O 操作。</p>
<img src="/images/202102/ioctl.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(ioctl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> error;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line">......</span><br><span class="line">  error = do_vfs_ioctl(f.file, fd, cmd, arg);</span><br><span class="line">  fdput(f);</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ioctl也是一个系统调用。</p>
<p>其中，fd 是这个设备的文件描述符，cmd 是传给这个设备的命令，arg 是命令的参数。其中，对于命令和命令的参数，使用 ioctl 系统调用的用户和驱动程序的开发人员约定好行为即可。</p>
<p>其实 cmd 看起来是一个 int，其实他的组成比较复杂，它由几部分组成：最低八位为 NR，是命令号；然后八位是 TYPE，是类型；然后十四位是参数的大小；最高两位是 DIR，是方向，表示写入、读出，还是读写。这里了解一下就ok了， 用的时候可以查一下文档。</p>
<p>ioctl 中会调用 do_vfs_ioctl，这里面对于已经定义好的 cmd，进行相应的处理。如果不是默认定义好的 cmd，则执行默认操作。对于普通文件，调用 file_ioctl；对于其他文件调用 vfs_ioctl。</p>
<p>调用的是 struct file 里 file_operations 的 unlocked_ioctl 函数。我们前面初始化设备驱动的时候，已经将 file_operations 指向设备驱动的 file_operations 了。这里调用的是设备驱动的 unlocked_ioctl。对于打印机程序来讲，调用的是 lp_ioctl。</p>
<p>好了， 这里也终于了解了ioctl这个系统调用了，以前和驱动联调的时候，也都是通过这个函数来调用的。 理顺了。</p>
<img src="/images/202102/lp_driver.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />



<h2 id="内核模块编译"><a href="#内核模块编译" class="headerlink" title="内核模块编译"></a>内核模块编译</h2><p>linux内核使用的是kbuild编译系统，在编译可加载模块时，其makefile的风格和常用的编译C程序的makefile有所不同，尽管如此，makefile的作用总归是给编译器提供编译信息。</p>
<p>网上看到了一个相关的<a href="https://www.cnblogs.com/downey-blog/p/10486907.html">文章</a>， 后续有用再查查 </p>
<p>今天最后一天上班了， 过两天就回去过年了，春节快乐!~~~</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二十八) - 字符设备中断</title>
    <url>/2021/02/19/2021-20210219-linux28-int/</url>
    <content><![CDATA[<h1 id="字符设备中断"><a href="#字符设备中断" class="headerlink" title="字符设备中断"></a>字符设备中断</h1><p>前面在学习文件读写的时候，如果是读取设备上的内容， 那么在读取完毕的时候，设备会发送一个中断告知CPU内容读取完毕。同样的，字符设备也是有中断来通知CPU处理事件， 比如鼠标设备就是通过中断来告知系统自己的位置和按键信息，传递给驱动程序。</p>
<span id="more"></span>

<h2 id="注册中断处理函数"><a href="#注册中断处理函数" class="headerlink" title="注册中断处理函数"></a>注册中断处理函数</h2><p>处理中断，需要一个中断的处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">logibm_open</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (request_irq(logibm_irq, logibm_interrupt, <span class="number">0</span>, <span class="string">&quot;logibm&quot;</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;logibm.c: Can&#x27;t allocate irq %d\n&quot;</span>, logibm_irq);</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br><span class="line">  &#125;</span><br><span class="line">  outb(LOGIBM_ENABLE_IRQ, LOGIBM_CONTROL_PORT);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">logibm_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鼠标的中断处理函数就是<code>logibm_interrupt</code>。通过<code>request_irq</code>函数注册中断处理函数。</p>
<p>中断处理函数的返回值表示中断处理的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">irqreturn_t</span> (*<span class="type">irq_handler_t</span>)(<span class="type">int</span> irq, <span class="type">void</span> * dev_id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum irqreturn</span></span><br><span class="line"><span class="comment"> * @IRQ_NONE    interrupt was not from this device or was not handled</span></span><br><span class="line"><span class="comment"> * @IRQ_HANDLED    interrupt was handled by this device</span></span><br><span class="line"><span class="comment"> * @IRQ_WAKE_THREAD  handler requests to wake the handler thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> &#123;</span></span><br><span class="line">  IRQ_NONE    = (<span class="number">0</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">  IRQ_HANDLED    = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">  IRQ_WAKE_THREAD    = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用void指针参数， 可以达到同一个函数处理不同设备的中断事件，根据中断号可以区分是什么设备，然后强转为特定设备的结构，这种实现是很普遍的用在通过流程的入口函数的。</p>
<p>这里的返回值有三种：IRQ_NONE 表示不是我的中断，不归我管；IRQ_HANDLED 表示处理完了的中断；IRQ_WAKE_THREAD 表示有一个进程正在等待这个中断，中断处理完了，应该唤醒它。</p>
<p>鼠标的中断处理相对比较简单，没有耗时长的操作，整体也不是很复杂。在中断处理的过程中，这个中断信号是被关闭的， 如果连续来几个相同的中断，后续的中断可能不被即时响应，显得系统很慢。对于其他复杂的中断，可能需要分成关键处理部分和延迟处理部分，在中断处理函数中，仅仅处理关键部分，完成了就将中断信号打开，使得新的中断可以进来，需要比较长时间处理的部分，也即延迟部分，往往通过工作队列等方式慢慢处理。</p>
<p><code>request_irq</code>函数注册中断处理函数。对于每一个中断，都有一个对中断的描述结构 struct irq_desc。它有一个重要的成员变量是 struct irqaction，用于表示处理这个中断的动作。处理动作可以有多个，通过 irqaction的next串起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>  *<span class="title">action</span>;</span>  <span class="comment">/* IRQ action list */</span></span><br><span class="line">......</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span>    *<span class="title">owner</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>    *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irqaction - per interrupt action descriptor</span></span><br><span class="line"><span class="comment"> * @handler:  interrupt handler function</span></span><br><span class="line"><span class="comment"> * @name:  name of the device</span></span><br><span class="line"><span class="comment"> * @dev_id:  cookie to identify the device</span></span><br><span class="line"><span class="comment"> * @percpu_dev_id:  cookie to identify the device</span></span><br><span class="line"><span class="comment"> * @next:  pointer to the next irqaction for shared interrupts</span></span><br><span class="line"><span class="comment"> * @irq:  interrupt number</span></span><br><span class="line"><span class="comment"> * @flags:  flags (see IRQF_* above)</span></span><br><span class="line"><span class="comment"> * @thread_fn:  interrupt handler function for threaded interrupts</span></span><br><span class="line"><span class="comment"> * @thread:  thread pointer for threaded interrupts</span></span><br><span class="line"><span class="comment"> * @secondary:  pointer to secondary irqaction (force threading)</span></span><br><span class="line"><span class="comment"> * @thread_flags:  flags related to @thread</span></span><br><span class="line"><span class="comment"> * @thread_mask:  bitmask for keeping track of @thread activity</span></span><br><span class="line"><span class="comment"> * @dir:  pointer to the proc/irq/NN/name entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">  <span class="type">irq_handler_t</span>    handler;</span><br><span class="line">  <span class="type">void</span>      *dev_id;</span><br><span class="line">  <span class="type">void</span> __percpu    *percpu_dev_id;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>  *<span class="title">next</span>;</span></span><br><span class="line">  <span class="type">irq_handler_t</span>    thread_fn;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">thread</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>  *<span class="title">secondary</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>    irq;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>    flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>    thread_flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>    thread_mask;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>    *name;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>  *<span class="title">dir</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个desc结构可以通过中断号调用irq_to_desc函数来查找。当然这里的中断号也只是一个内核逻辑的中断编号，不同的设备实际发出的中断号可能不一样，这个有一个中断控制器控制。</p>
<p>request_threaded_irq 函数分配了一个 struct irqaction，并且初始化它，接着调用 __setup_irq。在这个函数里面，如果 struct irq_desc 里面已经有 struct irqaction 了，我们就将新的 struct irqaction 挂在链表的末端。如果设定了以单独的线程运行中断处理函数，setup_irq_thread 就会创建这个内核线程，wake_up_process 会唤醒它。</p>
<p>注册处理函数其实也不复杂，只是查找一下中断描述符，然后建立action链表。</p>
<h2 id="触发中断处理"><a href="#触发中断处理" class="headerlink" title="触发中断处理"></a>触发中断处理</h2><p>中断触发有几个阶段</p>
<ul>
<li>外部设备给中断控制器发送物理中断信号</li>
<li>中断控制器将物理中断信号转换成为中断向量 interrupt vector，发给各个 CPU。</li>
<li>每个 CPU 都会有一个中断向量表，根据 interrupt vector 调用一个 IRQ 处理函数。</li>
<li>在 IRQ 处理函数中，将 interrupt vector 转化为抽象中断层的中断信号 irq，调用中断信号 irq 对应的中断描述结构里面的 irq_handler_t。</li>
</ul>
<p>CPU 能够处理的中断总共 256 个，用宏 NR_VECTOR 或者 FIRST_SYSTEM_VECTOR 表示。</p>
<p>CPU 硬件要求每一个 CPU 都有一个中断向量表，通过 load_idt 加载，里面记录着每一个中断对应的处理方法，这个中断向量表定义在文件 arch&#x2F;x86&#x2F;kernel&#x2F;traps.c 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gate_desc idt_table[NR_VECTORS] __page_aligned_bss;</span><br></pre></td></tr></table></figure>

<p>0-31是系统异常的中断，在内核初始化的时候 trap_init函数设置了中断函数。在trap_init还设置了127系统调用的中断处理函数。同时给used_vectors全局变量对应的位置位。其他设备的中断初始化调用的是init_IRQ函数。</p>
<p>任何硬件中断向量处理最终都会调用到do_IRQ函数。do_IRQ就通过每个CPU对应的中断向量表获取最终全局的中断desc，然后调用对应的处理函数进行处理。</p>
<img src="/images/202102/dev_irq.png" alt="图片替换文本" width="600" height="713" align="bottom" />




<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二十九) - 块设备</title>
    <url>/2021/02/19/2021-20210219-linux29-bdev/</url>
    <content><![CDATA[<h1 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h1><p>输入输出系统的设备包括字符设备和块设备。块设备也和字符设备类似，需要注册、打开、读写操作。</p>
<span id="more"></span>

<p>硬盘是最常见的块设备。块设备一般需要被格式化为文件系统，然后通过文件系统接口调用操作。 </p>
<p>块设备也需要mknod到&#x2F;dev&#x2F;xxx下面，&#x2F;dev 路径下面是 devtmpfs 文件系统。和字符设备一样，需要为&#x2F;dev&#x2F;xxx分配一个inode，inode 里面的 i_rdev 被设置成了块设备的设备号 dev_t。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_special_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> rdev)</span></span><br><span class="line">&#123;</span><br><span class="line">  inode-&gt;i_mode = mode;</span><br><span class="line">  <span class="keyword">if</span> (S_ISCHR(mode)) &#123;</span><br><span class="line">    inode-&gt;i_fop = &amp;def_chr_fops;</span><br><span class="line">    inode-&gt;i_rdev = rdev;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISBLK(mode)) &#123;</span><br><span class="line">    inode-&gt;i_fop = &amp;def_blk_fops;</span><br><span class="line">    inode-&gt;i_rdev = rdev;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISFIFO(mode))</span><br><span class="line">    inode-&gt;i_fop = &amp;pipefifo_fops;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (S_ISSOCK(mode))</span><br><span class="line">    ;  <span class="comment">/* leave it no_open_fops */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个inode是不能操作文件系统的， 我们需要把他mount到一个文件夹下面。如果这个块设备原来被格式化为一种文件系统的格式，例如 ext4，那我们调用的就是 ext4 相应的 mount 操作。ext4文件系统就是调用的ext4_mount函数，然后调用mount_bdev。mount_bdev主要就是做了2个工作：</p>
<ul>
<li>调用blkdev_get_by_path 根据 &#x2F;dev&#x2F;xxx 这个名字，找到相应的设备并打开它；块设备是在这里打开的，不是调用的file_ops的函数.</li>
<li>sget 根据打开的设备文件，填充 ext4 文件系统的 super_block</li>
</ul>
<p>如果块设备分区了，分别格式化成不同的文件系统， 就有下面这张复杂的关系图了。</p>
<img src="/images/202102/dev_disk.png" alt="图片替换文本" width="600" height="713" align="bottom" />

<p>gendisk 只有一个实例，指向 &#x2F;dev&#x2F;sda。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> major;      <span class="comment">/* major number of driver */</span></span><br><span class="line">  <span class="type">int</span> first_minor;</span><br><span class="line">  <span class="type">int</span> minors;                     <span class="comment">/* maximum number of minors, =1 for disks that can&#x27;t be partitioned. */</span></span><br><span class="line">  <span class="type">char</span> disk_name[DISK_NAME_LEN];  <span class="comment">/* name of major driver */</span></span><br><span class="line">  <span class="type">char</span> *(*devnode)(<span class="keyword">struct</span> gendisk *gd, <span class="type">umode_t</span> *mode);</span><br><span class="line">......</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">disk_part_tbl</span> __<span class="title">rcu</span> *<span class="title">part_tbl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> <span class="title">part0</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">  <span class="type">void</span> *private_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">slave_dir</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct disk_part_tbl 结构里是一个 struct hd_struct 的数组，用于表示各个分区。struct block_device_operations fops 指向对于这个块设备的各种操作。struct request_queue queue 是表示在这个块设备上的请求队列。struct hd_struct 是用来表示某个分区的，在上面的例子中，有两个 hd_struct 的实例，分别指向 &#x2F;dev&#x2F;sda1、 &#x2F;dev&#x2F;sda2。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> &#123;</span></span><br><span class="line">  <span class="type">sector_t</span> start_sect;</span><br><span class="line">  <span class="type">sector_t</span> nr_sects;</span><br><span class="line">......</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">dev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">holder_dir</span>;</span></span><br><span class="line">  <span class="type">int</span> policy, partno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">partition_meta_info</span> *<span class="title">info</span>;</span></span><br><span class="line">......</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">disk_stats</span> <span class="title">dkstats</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref</span> <span class="title">ref</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 hd_struct 中，比较重要的成员变量保存了如下的信息：从磁盘的哪个扇区开始，到哪个扇区结束。而 block_device 既可以表示整个块设备，也可以表示某个分区，所以对于上面的例子，block_device 有三个实例，分别指向 &#x2F;dev&#x2F;sda1、&#x2F;dev&#x2F;sda2、&#x2F;dev&#x2F;sda。</p>
<p>block_device 的成员变量 bd_disk，指向的 gendisk 就是整个块设备。这三个实例都指向同一个 gendisk。bd_part 指向的某个分区的 hd_struct，bd_contains 指向的是整个块设备的 block_device。</p>
<img src="/images/202102/disk_mount.png" alt="图片替换文本" width="600" height="713" align="bottom" />


<p>这个流程挺复杂的，但是归根到底都逃不出增删改查的操作，相互关联通过指针来关联，先注册回调函数，然后操作时调用回调。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(三十) - 进程间通信方式</title>
    <url>/2021/02/20/2021-20210220-linux30-process/</url>
    <content><![CDATA[<h1 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h1><p>对于大项目，单进程已经不能满足需求了，现在很多应用往往存在多个进程，各个进程在大功能上面都是职责单一的。那么就需要有一种途径进行进程间的交互协作，这就是进程间的通行方式。</p>
<span id="more"></span>

<h2 id="管道模型"><a href="#管道模型" class="headerlink" title="管道模型"></a>管道模型</h2><p>管道模型，适用于瀑布型的流程，前一个流程的输入作为后一个流程的输出，仅仅单向的传递数据。比如命令行的管道使用方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ps -ef | grep 关键字 | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs kill <span class="number">-9</span></span><br></pre></td></tr></table></figure>

<p>管道是一种单向传输数据的机制，它其实是一段缓存，里面的数据只能从一端写入，从另一端读出。如果想互相通信，我们需要创建两个管道才行。</p>
<h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><p>“|” 表示的管道称为匿名管道，意思就是这个类型的管道没有名字，用完了就销毁了。就像上面那个命令里面的一样，竖线代表的管道随着命令的执行自动创建、自动销毁。用户甚至都不知道自己在用管道这种技术，就已经解决了问题。</p>
<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>这个类型的管道需要通过 mkfifo 命令显式地创建。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfifo hello</span><br></pre></td></tr></table></figure>

<p>管道以文件的形式存在，这也符合 Linux 里面一切皆文件的原则。这个时候，我们<code>ls</code> 一下，可以看到，这个文件的类型是 <code>p</code>，就是 <code>pipe</code> 的意思。管道的写入和读取，就可以像下面这样操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; hello  // 写入</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> &lt; hello   // 读取</span></span><br><span class="line">hello world</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>管道不适合进程间频繁地交换数据。 具体代码实现上，一般是用于父子进程间的通信。通过pipe函数创建管道，然后创建子进程，父子进程分别关闭读写端，然后一个只读，另一个只写。</p>
<h2 id="消息队列模型"><a href="#消息队列模型" class="headerlink" title="消息队列模型"></a>消息队列模型</h2><p>消息队列，通过发送消息块进行交互。类似邮件一样，发送完消息就可以不管了， 对端主动读取消息，如果没有消息则返回空。你来我往的进行交互通信。</p>
<p>系统级的消息队列使用的比较少，一般使用用户级别的消息队列，比如通过socket网络通信发送消息，然后使用链表等数据结构保存消息。</p>
<h2 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h2><p>消息队列适合传递小的消息块，如果太大就可以使用共享内存模型。</p>
<p>每个进程都有自己独立的虚拟内存空间，不同的进程的虚拟内存空间映射到不同的物理内存中去。共享内存的原理就是让不同进程的虚拟空间映射到相同的物理地址上，这样不同进程写入的内容就可以被其他进程立马读取到。这种方式是进程间通信最快的了，因为共享内存是直接将一块内存区域映射到虚拟地址空间中，因此在数据通信传输的过程中，相比较其他的通信方式少了将数据从用户态到内核态的数据拷贝过程。<br>什么意思，就是说这种通信方式，已经把数据拿到了地址空间，再取数据不需要再涉及到内核，不涉及执行进入内核的系统调用 来传递数据。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>共享内存模型存在多个进程对其进行读写，构成了临界资源，进程间对临界资源的保护采用的是信号量。通过信号量的获取与释放，获得临界资源的访问保护，可以保证相同时间段内只能有特定数目的进程对其进行操作。</p>
<p>消息队列，共享内存模型和信号量，需要保证不同的进程操作的是相同的队列、内存块和信号量，需要有一个地方获取统一的标识，这个由System V IPC通信体系来保证，通过对同一个文件进行操作获取信息，保证获取相同的标识。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>进程间通信还有一种方式，就是信号。不同进程间可以通过发送信号给指定id的进程，然后目标进程调用信号处理函数进行处理。一般用于处理异常来用。</p>
<p>Linux 提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。信号可以在任何时候发送给某一进程，进程需要为这个信号配置信号处理函数。当某个信号发生的时候，就默认执行这个函数就可以了。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>博客迁移</title>
    <url>/2021/02/28/2021-20210228-notice/</url>
    <content><![CDATA[<p>github不稳定，近期老是被墙，换到<a href="https://fishmwei.github.io/">码云</a>上去。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(三十一) - 信号</title>
    <url>/2021/03/21/2021-20210321-linux31-signal/</url>
    <content><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>信号其实是一个很像中断的机制，事先注册号信号的处理函数，或者使用默认的处理函数， 当接收到奥信号的时候，调用对应的处理函数进行处理。中断呢，系统默认有一个中断向量表，存储中断处理程序，当接收到中断的时候，从中断向量表中获取中断处理程序进行处理。只是中断是在内核态处理，信号是在用户态处理。</p>
<span id="more"></span>

<h2 id="信号的类型"><a href="#信号的类型" class="headerlink" title="信号的类型"></a>信号的类型</h2><p>操作系统中，为了响应各种各样的事件，也是定义了非常多的信号。我们可以通过 kill -l 命令，查看所有的信号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">linux-kernel keep$ kill -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL</span><br><span class="line"> 5) SIGTRAP	 6) SIGABRT	 7) SIGEMT	 8) SIGFPE</span><br><span class="line"> 9) SIGKILL	10) SIGBUS	11) SIGSEGV	12) SIGSYS</span><br><span class="line">13) SIGPIPE	14) SIGALRM	15) SIGTERM	16) SIGURG</span><br><span class="line">17) SIGSTOP	18) SIGTSTP	19) SIGCONT	20) SIGCHLD</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGIO	24) SIGXCPU</span><br><span class="line">25) SIGXFSZ	26) SIGVTALRM	27) SIGPROF	28) SIGWINCH</span><br><span class="line">29) SIGINFO	30) SIGUSR1	31) SIGUSR2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的命令是在mac下面敲的，具体到linux显示会不一样，但是内容是代表一样的意义，都是信号的类型。具体类型的说明， 可以通过 ‘man signal’查看。</p>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><p>一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p>1.执行默认操作。Linux 对每种信号都规定了默认操作</p>
<p>2.捕捉信号。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p>3.忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。</p>
<p>如果我们不想让某个信号执行默认操作，一种方法就是对特定的信号注册相应的信号处理函数，设置信号处理方式的是 signal 函数。我们在 Linux 下面执行 man signal 的话，会发现 Linux 不建议我们直接用这个方法，而是改用 sigaction。这两个函数的区别就是sigaction掌控的粒度更小，更灵活。而signal没有那么灵活而已。具体使用的时候，可以去看看函数的说明，决定使用哪个。</p>
<h2 id="信号发送"><a href="#信号发送" class="headerlink" title="信号发送"></a>信号发送</h2><p>有时候，我们在终端输入某些组合键的时候，会给进程发送信号，例如，Ctrl+C 产生 SIGINT 信号，Ctrl+Z 产生 SIGTSTP 信号。有的时候，硬件异常也会产生信号。比如，执行了除以 0 的指令，CPU 就会产生异常，然后把 SIGFPE 信号发送给进程。再如，进程访问了非法内存，内存管理模块就会产生异常，然后把信号 SIGSEGV 发送给进程。</p>
<p>对于硬件触发的，无论是中断，还是信号，肯定是先到内核的，然后内核对于中断和信号处理方式不同。一个是完全在内核里面处理完毕，一个是将信号放在对应的进程 task_struct 里信号相关的数据结构里面，然后等待进程在用户态去处理。当然有些严重的信号，内核会把进程干掉。但是，这也能看出来，中断和信号的严重程度不一样，信号影响的往往是某一个进程，处理慢了，甚至错了，也不过这个进程被干掉，而中断影响的是整个系统。一旦中断处理中有了 bug，可能整个 Linux 都挂了。</p>
<p>有时候，内核在某些情况下，也会给进程发送信号。例如，向读端已关闭的管道写数据时产生 SIGPIPE 信号，当子进程退出时，我们要给父进程发送 SIG_CHLD 信号等。</p>
<p>最直接的发送信号的方法就是，通过命令 kill 来发送信号了。</p>
<p>另外，我们还可以通过 kill 或者 sigqueue 系统调用，发送信号给某个进程，也可以通过 tkill 或者 tgkill 发送信号给某个线程。虽然方式多种多样，但是最终都是调用了 do_send_sig_info 函数，将信号放在相应的 task_struct 的信号数据结构中。</p>
<ul>
<li><p>kill-&gt;kill_something_info-&gt;kill_pid_info-&gt;group_send_sig_info-&gt;do_send_sig_info</p>
</li>
<li><p>tkill-&gt;do_tkill-&gt;do_send_specific-&gt;do_send_sig_info</p>
</li>
<li><p>tgkill-&gt;do_tkill-&gt;do_send_specific-&gt;do_send_sig_info</p>
</li>
<li><p>rt_sigqueueinfo-&gt;do_rt_sigqueueinfo-&gt;kill_proc_info-&gt;kill_pid_info-&gt;group_send_sig_info-&gt;do_send_sig_info</p>
</li>
</ul>
<p>当接收到信号的时候，内核会把信号放到task_struct结构里面， &lt;32的信号放在信号集里面， 其他信号放在一个链表里面。 对于&lt;32的信号可能会丢失，即不可信信号，其他的就是可信的信号。有信号之后，会置一个标志位，当任务从中断或者系统调用返回后，检查标志然后进行处理。</p>
<h2 id="信号处理-1"><a href="#信号处理-1" class="headerlink" title="信号处理"></a>信号处理</h2><p>从系统调用或者中断返回的时候，都会调用 exit_to_usermode_loop函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exit_to_usermode_loop</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, u32 cached_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (cached_flags &amp; _TIF_NEED_RESCHED)</span><br><span class="line">      schedule();</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* deal with pending signal delivery */</span></span><br><span class="line">    <span class="keyword">if</span> (cached_flags &amp; _TIF_SIGPENDING)</span><br><span class="line">      do_signal(regs);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (!(cached_flags &amp; EXIT_TO_USERMODE_LOOP_FLAGS))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果检查有信号标志_TIF_SIGPENDING， 就调用do_signal函数进行信号处理。 这个时候，我们要看，是否从系统调用中返回。如果是从系统调用返回的话，还要区分我们是从系统调用中正常返回，还是在一个非运行状态的系统调用中，因为会被信号中断而返回。如果是因为信号中断而返回的话， 会在栈桢里面添加中断信号相关的上下文，然后出栈直接调到信号处理函数，而不会调用系统调用前的代码行。</p>
<p>万变不离其宗，其实如果有一些基础的系统知识，不如这里知道栈的用处，那么读代码的时候就比较容易理解了。 </p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(三十二) - 管道</title>
    <url>/2021/03/28/2021-20210328-linux32-pipe/</url>
    <content><![CDATA[<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>这次学习了管道的具体创建与使用。</p>
<span id="more"></span>

<p>管道的创建通过调用函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>返回了两个文件描述符，这表示管道的两端，一个是管道的读取端描述符 fd[0]，另一个是管道的写入端描述符 fd[1]。先读后写。</p>
<img src="/images/202104/pipe_map.png" alt="图片替换文本" width="600" height="513" align="bottom" />

<p><code>pipe</code>系统调用，最终是调到一个<code>pipe2</code>的函数.这里面要创建一个数组 files，用来存放管道的两端的打开文件，另一个数组 fd 存放管道的两端的文件描述符。</p>
<h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>所谓的匿名管道，其实就是内核里面的一串缓存。读写管道的文件的操作就是对这段缓存的操作。创建的两个文件描述符都是在一个进程里面的，通过fork创建子进程的方式，使得子进程也可以访问相同的文件，最终实现父子进程间的通信。</p>
<img src="/images/202104/pipe_fork.png" alt="图片替换文本" width="600" height="513" align="bottom" />

<p>父进程和子进程都可以写入，也都可以读出，通常的方法是父进程关闭读取的 fd，只保留写入的 fd，而子进程关闭写入的 fd，只保留读取的 fd，如果需要双向通行，则应该创建两个管道。具体的操作需要程序员自己掌控。</p>
<p>好了，那么shell命令怎么实现的管道呢。其实，就是先fork一个进程A，进程A保留写入的fd。此时shell保留读端的fd。 然后再fork一个进程B，这样进程B就可以有读端的fd，shell进程关掉自己的读端功能。A和B就分别控制管道的两端了。至于输入输出传输，需要把读端的fd和进程B的标准输入fd关联起来，这是调用的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure>

<p>将老的文件描述符赋值给新的文件描述符，让 newfd 的值和 oldfd 一样。 具体的就是进程A调用dup2(fd[1],STDOUT_FILENO)，写端对应A的标准输出。进程B调用dup2(fd[0],STDIN_FILENO)，读端对应B的标准输入。这样，就实现了读写的无缝衔接。 A以后往标准输出写入的任何东西，都会写入管道文件。B以后从标准输入读取的任何东西，都来自于管道文件。</p>
<h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>命名管道需要事先通过命令 mkfifo，进行创建。如果是通过代码创建命名管道，也有一个函数，但是这不是一个系统调用，而是 Glibc 提供的函数，也叫mkfifo。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span></span><br></pre></td></tr></table></figure>

<p>Glibc 的 mkfifo 函数会调用 mknodat 系统调用，还记得咱们学字符设备的时候，创建一个字符设备的时候，也是调用的 mknod。这里命名管道也是一个设备，因而我们也用 mknod。</p>
<p>接下来，要打开这个管道文件，我们还是会调用文件系统的 open 函数。所谓的命名管道，其实是也是内核里面的一串缓存。</p>
<p>命名管道的创建与使用伪代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// create</span></span><br><span class="line"><span class="type">int</span>  ret  = mkfifo( <span class="string">&quot;/tmp/cmd_pipe&quot;</span> , S_IFIFO  |  <span class="number">0666</span> );</span><br><span class="line">    </span><br><span class="line"><span class="comment">// read</span></span><br><span class="line">pfp  = fopen(<span class="string">&quot;/tmp/cmd_pipe&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">ret = fgets( buffer, MAX_LINE, pfp );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// write</span></span><br><span class="line">pfp =fopen( <span class="string">&quot;/tmp/cmd_pipe&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">ret = <span class="built_in">fprintf</span>( pfp, <span class="string">&quot;Here’s a test string!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈MODBUS协议</title>
    <url>/2021/04/11/2021-20210411-modbus/</url>
    <content><![CDATA[<p>近两周完成了MODBUS协议RTU格式的开发，包含了从站和主站的功能，算是完成一个简易版的MODBUS协议栈了，做个小结。</p>
<span id="more"></span>

<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>MODBUS是一个工业应用层的消息协议，描述了不同总线或者网络上设备的一种主从交互的方式。协议包含了链路层与应用层的实现， 具体链路的我也不懂，没有深究。主要还是讲协议本身实现层面上的一些逻辑。</p>
<p><img src="/images/202104/mblayer.png" alt="avatar"></p>
<p>主从模式，就是请求都是主机发起，从机被动应答或者不答(广播时)一个机制。不问不答。由于MODBUS原先是针对总线结构而定义的，因此对带宽要求比较苛刻，挂在同一个总线上的设备不能很多，最多247台从机， 从机地址为1-247， 0作为广播地址, 248-255为保留地址。从机之间不会进行交互。每个地址在总线上只能有一台从机。</p>
<p>单播模式： 主机定位到一个独立的从机，向其发送请求。从机在接收处理完请求后，返回一个对应的响应给主机。</p>
<p>广播模式：主机发送一个广播包给总线上的所有从机，从机不需要响应。所有的从机需要接收广播的报文。</p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>协议层面，MODBUS定义了一个数据格式，简称PDU。格式为1个字节的功能码加数据。PDU前加一个字节的地址，后面加2个字节的CRC校验码，最终组成MODBUS的帧。</p>
<p><img src="/images/202104/mbframe.png" alt="avatar"></p>
<p>CRC是针对从地址开始到整个PDU来计算的。CRC有2个字节，低位在前，这样子接收端收到完整报文的时候，只要重新计算完整报文(包含CRC)的crc值为0就表示报文传输正确。</p>
<p>功能码指示了主机希望从机执行什么动作，随后的数据表示请求和响应的数据。</p>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>MODBUS状态机按数据链路分成了2层：</p>
<ul>
<li>主从机状态机</li>
<li>数据接收状态机</li>
</ul>
<p>数据帧的传输模式包含了RTU和ASCII两种模式。后面再说。</p>
<h3 id="主机状态机"><a href="#主机状态机" class="headerlink" title="主机状态机"></a>主机状态机</h3><p><img src="/images/202104/MasterState.png" alt="avatar"></p>
<ul>
<li>IDLE状态，上电后处于这个状态，这个状态的适合没有任何进行中的请求。只有这个状态的时候，主机才能发送一个新的请求。同一个时刻，主机只会有一个进行中的请求，发送请求后，切换到另外的状态。</li>
<li>“Waiting for reply”状态，当发送完一个单播的请求后，转为这个状态。主机开启一个超时等待响应。</li>
<li>接收到回应后，主机先进行校验。如果出现校验错误的话，状态不变更，继续等待超时。</li>
<li>如果直到超时都没有接收到正确的响应，主机会报超时错误，然后回到IDLE状态，重新发起请求。重试的次数可以配置。</li>
<li>“Waiting Turnaround delay”状态，当发送完一个广播的请求后，转为这个状态，由于广播请求没有从机会进行响应，所以需要开启一个足够长的超时等待从机处理完请求。只有当超时后，再回到IDLE状态，开始另一个请求的发送。</li>
<li>一般单播超时设置为1s到几s的时长，波特率为9600bps时。Turnaround delay超时设置为100ms-200ms</li>
</ul>
<p>协议层面的状态机比较简单，这边不需要考虑传输的细节。实际实现时，也要把两个状态机的逻辑分开来看。我在实现时，直接省略了Processing reply 和 error的状态，实际这两个状态可以只是一个中间的状态，合并到waiting for reply的处理逻辑里了。具体实现可以有一些取舍，我主要是为了快速处理响应，不等那么多个状态了。框架的缘故，调度的周期会比较长，而不是在一个死循环里面。</p>
<h3 id="从机状态机"><a href="#从机状态机" class="headerlink" title="从机状态机"></a>从机状态机</h3><p><img src="/images/202104/SlaveState.png" alt="avatar"></p>
<ul>
<li>IDLE状态表示没有接收到请求，也是上电后的初始状态。</li>
<li>当接收到一个请求后，首先进行报文的校验。按约定请求必须使主机发起的，没有什么机制可以确定正确性。</li>
<li>如果收到的是单播请求，从机需要在操作完成后，回应一个报文，告知主机执行的结果。</li>
<li>如果收到的帧错误，只的是crc校验出错，从机不会作任何动作。需要主机的超时重发机制来搞定。</li>
<li>MODBUS可以有一些诊断的计数器，用于诊断错误原因，定位问题。可以通过特定的功能码来读取。</li>
</ul>
<p>这里有一个主从机的交互时序图，可以清晰的看到各个流程。</p>
<p><img src="/images/202104/mb_timing.jpg" alt="avatar"></p>
<h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p>MODBUS传输模式有两种， RTU和ASCII码。不同的模式，每一个字节的内容含义是不一样的。同一条总线上交互的MODBUS设备需要采用相同的传输模式，否则就很难玩了。协议约定默认所有的MODBUS设备都是要实现RTU模式的， ASCII码模式作为一个备选方案。</p>
<ul>
<li>RTU模式，每个字节代表数据的一个8位十六进制内容， 0xab</li>
<li>ASCII码模式， 每两个字节代表数据的一个8位十六进制内容， 每个字节分别代表一个字符。 类比上面的0xab， 需要两个字节， 分别存储’a’ 和‘b’两个字符。</li>
</ul>
<h3 id="RTU模式"><a href="#RTU模式" class="headerlink" title="RTU模式"></a>RTU模式</h3><p>RTU模式通过传输11bits的数据来确定最终传递的8位数字。</p>
<p><img src="/images/202104/mb_rtu.jpg" alt="avatar"></p>
<p>MODBUS的每一帧的开始和结束时通过字符传递间隔来确定的。帧与帧之间间隔至少3.5个字符时间。 同一帧之间的字符间隔不能超过1.5个字符时间，否则就认为这是一个错包。</p>
<p><img src="/images/202104/rtu_frame.jpg" alt="avatar"></p>
<p> RTU帧接收也有一个状态机，用于确定接收到一个完整的帧的。</p>
<p><img src="/images/202104/rtu_transmit.jpg" alt="avatar"></p>
<h3 id="ASCII码模式"><a href="#ASCII码模式" class="headerlink" title="ASCII码模式"></a>ASCII码模式</h3><p> ASCII模式下，帧的组成和RTU模式不一样。帧与帧之间的分隔是通过特定的字符来标识的。</p>
<p><img src="/images/202104/ascii_frame.jpg" alt="avatar"></p>
<p>具体的细节可以看官方的文档，就不细说了， 没有深究。</p>
<h2 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h2><p>MODBUS的链路主要是串行总线，也可以通过普通的以太网帧来封装，就是TCP-MODBUS，是另外的东东了。</p>
<p>我做的这个项目，是由串行总线来处理的。 有RS485和RS232两种。 </p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>总的来说， MODBUS是一个应用比较广泛的总线协议， 很多厂家会在其基础上进行自定义。具体的应用实现也会有不一样。 MODBUS还提供了应用层协议的约定。 可以通过官网获取具体的文档。各个文档讲的比较通俗易懂，反正我是看懂了。</p>
<p>官网地址  ：  <a href="https://modbus.org/">https://modbus.org/</a></p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二十四) - 虚拟文件系统</title>
    <url>/2021/02/05/2021-20210205-linux24-vfs/</url>
    <content><![CDATA[<h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><p>进程要想往文件系统里面读写数据，需要很多层的组件一起合作。</p>
<span id="more"></span>

<ul>
<li>在应用层，进程在进行文件读写操作时，可通过系统调用如 sys_open、sys_read、sys_write 等。</li>
<li>在内核，每个进程都需要为打开的文件，维护一定的数据结构。</li>
<li>在内核，整个系统打开的文件，也需要维护一定的数据结构。</li>
<li>Linux 可以支持多达数十种不同的文件系统。Linux 内核向用户空间提供了虚拟文件系统这个统一的接口，来对文件系统进行操作。它提供了常见的文件系统对象模型，例如 inode、directory entry、mount 等，以及操作这些对象的方法，例如 inode operations、directory operations、file operations 等。</li>
<li>读写 ext4 文件系统，要通过块设备 I&#x2F;O 层，也即 BIO 层。这是文件系统层和块设备驱动的接口。</li>
<li>为了加快块设备的读写效率，我们还有一个缓存层。</li>
<li>最下层是块设备驱动程序。</li>
</ul>
<img src="/images/202102/vfs_layer.jpg" alt="图片替换文本" width="600" height="813" align="bottom" />


<p>这里涉及到几个概念， mount， file， inode， 对应的operations, dentry。</p>
<h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><p>想要操作文件系统，第一件事情就是挂载文件系统。每种文件系统都有一个结构file_system_type保存文件系统的信息及操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">register_filesystem(&amp;ext4_fs_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">ext4_fs_type</span> =</span> &#123;</span><br><span class="line">  .owner    = THIS_MODULE,</span><br><span class="line">  .name    = <span class="string">&quot;ext4&quot;</span>,</span><br><span class="line">  .mount    = ext4_mount,</span><br><span class="line">  .kill_sb  = kill_block_super,</span><br><span class="line">  .fs_flags  = FS_REQUIRES_DEV,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注册过文件系统之后， 需要把文件系统mount到一个目录下， 才可以访问文件系统。通过系统调用mount来完成， do_mount-&gt;do_new_mount-&gt;vfs_kern_mount。</p>
<p>vfs_kern_mount 先是创建 struct mount 结构，每个挂载的文件系统都对应于这样一个结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mount</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_hash</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_parent</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> <span class="title">mnt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">mnt_rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> <span class="title">mnt_llist</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span>  <span class="comment">/* list of children, anchored here */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span>  <span class="comment">/* and going through their mnt_child */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_instance</span>;</span>  <span class="comment">/* mount instance on sb-&gt;s_mounts */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *mnt_devname;  <span class="comment">/* Name of device e.g. /dev/dsk/hda1 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span>  <span class="comment">/* root of the mounted tree */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span>  <span class="comment">/* pointer to superblock */</span></span><br><span class="line">  <span class="type">int</span> mnt_flags;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>mnt_parent 是装载点所在的父文件系统，mnt_mountpoint 是装载点在父文件系统中的 dentry；struct dentry 表示目录，并和目录的 inode 关联；mnt_root 是当前文件系统根目录的 dentry，mnt_sb 是指向超级块的指针。最终调用文件系统类型的mount回调函数。</p>
<p>每个文件都由一个struct file来描述， struct file里面有mnt和dentry的指针， mnt表示文件系统的挂载点信息，dentry就是保存文件的inode 等信息的结构。通过指针构成一个复杂的网状结构。 </p>
<p>下面是一张图， 假设根文件系统下面有一个目录 home，有另外一个文件系统 A 挂载在这个目录 home 下面。在文件系统 A 的根目录下面有另外一个文件夹 hello。由于文件系统 A 已经挂载到了目录 home 下面，所以我们就有了目录 &#x2F;home&#x2F;hello，然后有另外一个文件系统 B 挂载在 &#x2F;home&#x2F;hello 下面。在文件系统 B 的根目录下面有另外一个文件夹 world，在 world 下面有个文件夹 data。由于文件系统 B 已经挂载到了 &#x2F;home&#x2F;hello 下面，所以我们就有了目录 &#x2F;home&#x2F;hello&#x2F;world&#x2F;data。</p>
<img src="/images/202102/vfs_hello.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />


<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>要打开一个文件，首先要通过 get_unused_fd_flags 得到一个没有用的文件描述符。 每个进程的task_struct里面都会有一个指针files:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>    *<span class="title">files</span>;</span></span><br></pre></td></tr></table></figure>

<p>files_struct 里面最重要的是一个文件描述符列表，每打开一个文件，就会在这个列表中分配一项，下标就是文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认情况下，文件描述符 0 表示 stdin 标准输入，文件描述符 1 表示 stdout 标准输出，文件描述符 2 表示 stderr 标准错误输出。另外，再打开的文件，都会从这个列表中找一个空闲位置分配给它。</p>
<p>打开文件的操作，就是创建一个struct file结构，然后和fd关联起来，最后设置struct file的成员。这中间， 查找dentry又是一个缓存和老化的方案，提高查找效率。</p>
<img src="/images/202102/dentry_cache.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />




<p>有关文件的数据结构层次多，而且很复杂，就得到了下面这张图</p>
<img src="/images/202102/file_relation.png" alt="图片替换文本" width="600" height="513" align="bottom" />




<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈CAN</title>
    <url>/2021/04/28/2021-20210428-canopen/</url>
    <content><![CDATA[<p>最近完成了项目<code>CAN</code>协议模块的编写，<code>CAN</code>作为一种总线类型，多台设备连接到总线上，在短距离传输上有其优势，套用相关公司的广告就是 “CAN协议 – 方便灵活 功能强大”：</p>
<span id="more"></span>

<ul>
<li><p>CAN协议为分布式控制系统的设计提供了良好基础。CAN仲裁方法确保每一个CAN节点只需处理与其相关的报文。</p>
</li>
<li><p>CAN协议是在硅片的环境中实现的。这使得CAN设备在拥有错误处理和故障界定功能的同时可保持高速传输。这种用来分发报文至正确接收器的方法有助于充分利用带宽。</p>
</li>
<li><p>传输介质简单， 常见的传输介质是双绞线。CAN系统也可以单线工作。而在一些应用中，不同种类的链路、光链路或无线链路更适合。虽然存在着传输硬件标准（双绞线），但根据系统要求采用不同的传输方案也很常见。</p>
</li>
<li><p>出色的错误处理功能，CAN的错误处理功能是该协议最为突出的优点之一。错误检测机制的范围很广，而且故障界定算法非常先进。错误处理和报文重发会由CAN硬件自动进行。</p>
</li>
<li><p>强大的故障界定功能，CAN协议内置的特别功能会阻止故障节点堵塞整个系统。此类节点最终会被禁止在CAN总线上发送报文。</p>
</li>
<li><p>成熟的标准，CAN协议已经诞生将近30年（从1986年开始）。 现在市面上有很多可用的CAN产品和工具。</p>
</li>
</ul>
<h2 id="CAN总线"><a href="#CAN总线" class="headerlink" title="CAN总线"></a>CAN总线</h2><p>CAN总线是广播类型的总线，所有的节点都可以侦听到所有传输的报文。在物理层上，无法将报文单独发送给指定的节点。不过， CAN硬件提供本地的过滤功能，使得节点可以对报文做出选择性的响应。这样的话，通过设定可以接收任意报文。</p>
<p>CAN标准定义四种不同的报文类型。报文使用逐位仲裁智能方案来控制对总线的访问，每条报文都带有优先级标记。具体实现就不深入了， 知道有这么个优先级及可以了。</p>
<h2 id="CAN报文"><a href="#CAN报文" class="headerlink" title="CAN报文"></a>CAN报文</h2><p>CAN使用短报文 – 最大实用负载是94位。报文中没有任何明确的地址；相反，可以认为报文是通过内容寻址，也就是说，报文的内容隐式地确定其地址。CAN协议只定义链路层，具体的有高层协议CANOpen来定义。</p>
<p>CAN总线上有四种不同的报文类型:</p>
<ul>
<li>数据帧</li>
<li>远程帧</li>
<li>错误帧</li>
<li>过载帧</li>
</ul>
<h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p>数据帧是最常见的类型。 包含以下部分：</p>
<ul>
<li>仲裁字段  由标识符(11位&#x2F;29位)和标记位组成</li>
<li>数据字段 包含0-8个数据字节</li>
<li>CRC字段 包含一个基于报文大部分数据计算得到的15位校验和。校验和用于错误检测。</li>
<li>应答时隙。任何能够正确接收报文的CAN控制器都会在每条报文的末尾发送一个应答位。传送节点检查应答位是否存在，如果没有检测到应答位，会重新发送报文。</li>
</ul>
<h3 id="远程帧"><a href="#远程帧" class="headerlink" title="远程帧"></a>远程帧</h3><p>远程帧与数据帧十分相似，但是有两个重要的区别：</p>
<p>它被显式标记为远程帧（仲裁字段中的RTR位为隐性），并且它没有数据字段。<br>远程帧的预期目的是征求传输相应的数据帧。</p>
<p>如果节点A传输一个仲裁字段设置为234的远程帧，那么节点B（如果已经正确初始化）可能通过一个仲裁字段也设置为234的数据帧进行响应。</p>
<h3 id="错误帧"><a href="#错误帧" class="headerlink" title="错误帧"></a>错误帧</h3><p>一般不用</p>
<h3 id="过载帧"><a href="#过载帧" class="headerlink" title="过载帧"></a>过载帧</h3><p>一般不用</p>
<h3 id="标准帧和扩展帧"><a href="#标准帧和扩展帧" class="headerlink" title="标准帧和扩展帧"></a>标准帧和扩展帧</h3><p>开始的时候， 仲裁字段是定义了11位的标识符， 后续根据应用需求扩展成了29位的标识符。大部分CAN收发器都是支持两种格式的。</p>
<h3 id="总线仲裁和报文优先级"><a href="#总线仲裁和报文优先级" class="headerlink" title="总线仲裁和报文优先级"></a>总线仲裁和报文优先级</h3><p>任何CAN控制器都可能在检测到空闲总线时开始传送数据。这可能会导致两个或多个控制器（几乎）同时开始传送报文。传送节点在发送报文时监视总线。如果节点在自身发送隐性位时检测到显性位，它将立即退出仲裁过程并转变成接收方。仲裁针对整个仲裁字段进行，当该字段已经被发送时，总线上恰好只剩一个传送节点。这个节点就像什么都没发生那样继续传送。其它潜在的传送节点将在总线下次空闲时尝试重传它们的报文。仲裁过程不会消耗时间。</p>
<p>总线采用线与逻辑，并且显性位是逻辑0，所以包含数值最低仲裁字段的报文将赢得仲裁。</p>
<p>简单说，是否可以发送报文，需要先检查总线上有没有人在发，只有空闲了，你才能发报文。标识符的值越小优先级越高。</p>
<h2 id="CAN物理层"><a href="#CAN物理层" class="headerlink" title="CAN物理层"></a>CAN物理层</h2><p>CAN总线的最大速度是1 Mbps。</p>
<p>如果速度为1Mbps，可以使用的最大线缆长度大约为40米（130英尺）。 </p>
<h2 id="高层协议"><a href="#高层协议" class="headerlink" title="高层协议"></a>高层协议</h2><p>CAN本身只定义了物理层和链路层的协议。具体应用还需要更高层的协议，一般而言，都是采用的CANOpen。 </p>
<p>CANOpen也是项目实现的重点。主要就是通过把标识符拆分为功能码与节点地址。然后约定好各种功能的协议格式。</p>
<p>具体收发器可以实现对不同标识符位的过滤。就类似网络IP协议中的掩码，可以设置只关心某些位，其他位的值不需要关心。比IP更灵活，不仅仅支持后缀掩码，可以支持任意位的掩码。</p>
<h2 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h2><p>模块的实现主要就是分层思想的应用，从上而下分为应用逻辑层、协议层、驱动层。初始化通过函数注入上层接口，解除底层对上层的耦合。通过参数配置可以灵活选择底层的CAN IO口，以及波特率等的设置。同时，针对TI的eCAN邮箱，应用层通过合理规划分配输入和输出邮箱的标识符，实现多种报文的收发。把可变的都设置成上层可配置的方式。具体这个ecan的使用，除了学习例程、主要就是花时间看看寄存器文档,然后自己实现个demo，实现基本功能。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈中台</title>
    <url>/2021/05/01/2021-20210501-middleplatform/</url>
    <content><![CDATA[<p>最近有了几天的空闲时间，又开始了学习的征程。之前在极客时间上面订阅了《从0开始学架构》的专栏，在专栏结束之后，作者还陆续增加了一些文章上去，其中有一篇就是讲中台的。</p>
<span id="more"></span>

<p>原先我理解的中台就是一些基础的公共技术的聚合平台，作为各个业务的中介，通过技术的手段解耦业务模块之间的硬耦合，同时为业务提供通用的、基础的功能(例如：网络通信、数据存储、日志系统等)。业务就像是网络中的两个节点，中台就是节点间通讯使用到的网络。离开了网络，节点的功能就不易实现。业务需要在中台的肩膀上，才能更方便的构建具体的业务。就好比socket数据发送， 你可以使用TCP、UDP等传输层的协议，也可以直接发送基础数据，而不基于传输层。这样子，中台实际上只是一个资源团队，跟具体的业务是无关的，只专注于技术实现。就是人们常说的技术中台。</p>
<p>通过文章的学习了解，我发现，之前的理解仅仅局限于广义的中台概念。而业界一般所谓的中台，实际上比技术中台更上层，包含一些共性的业务在里面。最早提出中台战略的应该是阿里巴巴，推行“大中台、小前台”的战略。中台为业务提供业务能力，前台根据实际的应用场景实现用户业务。</p>
<p>本人之前在一家互联网公司的共享平台部门工作过，主要做的是移动端react-native的技术支撑。通过该平台业务可以便捷的与其他模块进行交互。基于平台的架构，以及其它独立的业务部门的能力，可以快捷的搭建起一个个不同应用场景的APP软件。平台部门提炼各业务线的共性的技术需求，最大限度地减少“重复造轮子”。通过业务驱动开发，在实现业务需求的过程中，可以实现很多创新。在这样的部门工作，可以接触到更多底层的技术、前沿的技术，这个对开发人员的发展是很有裨益的，而不总是为了繁忙的业务逻辑加班，很少有时间深入理解底层的技术原理，仅仅停留在业务应用层面。当然，由于不同的业务有不同的需要，为了最大化兼容所有的业务，一般需要随着业务的快速发展而不断的迭代。迭代的过程就是一个痛苦的过程，新旧特性会存在许多的不兼容性，所以发布往往要影响许多业务的使用。即使有些业务已经稳定了，但是伴随着新版本发布，业务也需要进行兼容修改发布，否则后期就无法继续使用。这也制约了平台的发展，许多新技术都不能快速的推进，受到业务的掣肘。这样实际是处在一个很尴尬的地位，既要影响业务，又要被业务影响。如果不是有强有力的领导来支撑，那就很难推进工作。</p>
<p>中台是属于业务层面的，提炼了共性的业务，可以在中台孵化新业务，时机成熟后再独立出去。平台呢，主要还是提供技术的支持，为业务提供基础的架构，本身不需要关注业务。</p>
<p>中台的好处就是在已有的基础上，可以缩短业务开发的周期，可以快速构建一个个新的业务，中台可以提供业务相关的完整的解决方案。缺点就是复杂，有难度，对工程师的要求更高。做中台需要懂技术还要懂业务。一般中台的出现，都是公司有面向用户的业务的。很多做底层支撑的公司，会存在平台的概念，和业务中台不是一个概念的。</p>
<p>在专业深度上，平台和中台就没什么区别了。作为支撑业务的部门，都提高了上层业务的开发效率，自身也可以在专业上更加深入，保障整个系统运行的稳定和高效。</p>
<p>在人力资源上，都节约了用人成本，减少了重复工作。</p>
<p>用户体验，中台和平台都可以花时间优化系统的性能，提升软件的流畅度、稳定性。</p>
<p>但是有一点，平台只提供了通用基础能力，不同业务间存在协同问题。中台，则可以在发展的过程中，逐步将他们整合协同起来，这就是中台的优势，中台可以提供完整的业务解决方案。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二十三) - 硬盘文件系统</title>
    <url>/2021/02/04/2021-20210204-linux23-diskf/</url>
    <content><![CDATA[<h1 id="硬盘文件系统"><a href="#硬盘文件系统" class="headerlink" title="硬盘文件系统"></a>硬盘文件系统</h1><p>常见的硬盘是这幅图左边的样子，中间圆的部分是磁盘的盘片，右边的图是抽象出来的图。每一层里分多个磁道，每个磁道分多个扇区，每个扇区是 512 个字节。</p>
<span id="more"></span>

<img src="/images/202102/disk.jpg" alt="图片替换文本" width="600" height="513" align="bottom" />

<p>Linux 下最主流的文件系统格式——ext 系列</p>
<h2 id="inode-与块的存储"><a href="#inode-与块的存储" class="headerlink" title="inode 与块的存储"></a>inode 与块的存储</h2><p>硬盘分成相同大小的单元，我们称为块（Block）。一块的大小是扇区大小的整数倍，默认是 4K。在格式化的时候，这个值是可以设定的。</p>
<p>一大块硬盘被分成了一个个小的块，用来存放文件的数据部分。这样一来，如果我们像存放一个文件，就不用给他分配一块连续的空间了。我们可以分散成一个个小块进行存放。这样就灵活得多，也比较容易添加、删除和插入数据。</p>
<p>但是文件的数据存放得太散，找起来就比较困难，我们就需要有个地方存储这些信息，这就是inode。我们每个文件都会对应一个 inode；一个文件夹就是一个文件，也对应一个 inode。</p>
<p>对于ext的文件系统， 就有ext4_inode这个结构体:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_inode</span> &#123;</span></span><br><span class="line">  __le16  i_mode;    <span class="comment">/* File mode */</span></span><br><span class="line">  __le16  i_uid;    <span class="comment">/* Low 16 bits of Owner Uid */</span></span><br><span class="line">  __le32  i_size_lo;  <span class="comment">/* Size in bytes */</span></span><br><span class="line">  __le32  i_atime;  <span class="comment">/* Access time */</span></span><br><span class="line">  __le32  i_ctime;  <span class="comment">/* Inode Change time */</span></span><br><span class="line">  __le32  i_mtime;  <span class="comment">/* Modification time */</span></span><br><span class="line">  __le32  i_dtime;  <span class="comment">/* Deletion Time */</span></span><br><span class="line">  __le16  i_gid;    <span class="comment">/* Low 16 bits of Group Id */</span></span><br><span class="line">  __le16  i_links_count;  <span class="comment">/* Links count */</span></span><br><span class="line">  __le32  i_blocks_lo;  <span class="comment">/* Blocks count */</span></span><br><span class="line">  __le32  i_flags;  <span class="comment">/* File flags */</span></span><br><span class="line">......</span><br><span class="line">  __le32  i_block[EXT4_N_BLOCKS];<span class="comment">/* Pointers to blocks */</span></span><br><span class="line">  __le32  i_generation;  <span class="comment">/* File version (for NFS) */</span></span><br><span class="line">  __le32  i_file_acl_lo;  <span class="comment">/* File ACL */</span></span><br><span class="line">  __le32  i_size_high;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>“某个文件分成几块、每一块在哪里”，这些在 inode 里面，应该保存在 i_block 里面。</p>
<p>EXT4_N_BLOCKS 有如下的定义，计算下来一共有 15 项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  EXT4_NDIR_BLOCKS    12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  EXT4_IND_BLOCK      EXT4_NDIR_BLOCKS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  EXT4_DIND_BLOCK      (EXT4_IND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  EXT4_TIND_BLOCK      (EXT4_DIND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  EXT4_N_BLOCKS      (EXT4_TIND_BLOCK + 1)</span></span><br></pre></td></tr></table></figure>

<p>在 ext2 和 ext3 中，其中前 12 项直接保存了块的位置，也就是说，我们可以通过 i_block[0-11]，直接得到保存文件内容的块。如果文件较大，12个块放不下，让 i_block[12]指向一个块，这个块里面不放数据块，而是放数据块的位置，这个块我们称为间接块。也就是说，我们在 i_block[12]里面放间接块的位置，通过 i_block[12]找到间接块后，间接块里面放数据块的位置，通过间接块可以找到数据块。</p>
<p>如果文件再大一些，i_block[13]会指向一个块，我们可以用二次间接块。二次间接块里面存放了间接块的位置，间接块里面存放了数据块的位置，数据块里面存放的是真正的数据。如果文件再大一些，i_block[14]会指向三次间接块。原理和上面都是一样的，就像一层套一层的俄罗斯套娃，一层一层打开，才能拿到最中心的数据块。</p>
<img src="/images/202102/inode_level.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />


<p>这里面有一个非常显著的问题，对于大文件来讲，我们要多次读取硬盘才能找到相应的块，这样访问速度就会比较慢。为了解决这个问题，ext4 做了一定的改变。它引入了一个新的概念，叫做 Extents。我们来解释一下 Extents。比方说，一个文件大小为 128M，如果使用 4k 大小的块进行存储，需要 32k 个块。如果按照 ext2 或者 ext3 那样散着放，数量太大了。但是 Extents 可以用于存放连续的块，也就是说，我们可以把 128M 放在一个 Extents 里面。这样的话，对大文件的读写性能提高了，文件碎片也减少了。</p>
<img src="/images/202102/Exents.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<p>可以看出Exents可以分成两种节点， 索引节点和叶子节点。 索引节点指向新的一个索引，叶子节点指向具体的块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the extent on-disk structure.</span></span><br><span class="line"><span class="comment"> * It&#x27;s used at the bottom of the tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_extent</span> &#123;</span></span><br><span class="line">  __le32  ee_block;  <span class="comment">/* first logical block extent covers */</span></span><br><span class="line">  __le16  ee_len;    <span class="comment">/* number of blocks covered by extent */</span></span><br><span class="line">  __le16  ee_start_hi;  <span class="comment">/* high 16 bits of physical block */</span></span><br><span class="line">  __le32  ee_start_lo;  <span class="comment">/* low 32 bits of physical block */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is index on-disk structure.</span></span><br><span class="line"><span class="comment"> * It&#x27;s used at all the levels except the bottom.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_extent_idx</span> &#123;</span></span><br><span class="line">  __le32  ei_block;  <span class="comment">/* index covers logical blocks from &#x27;block&#x27; */</span></span><br><span class="line">  __le32  ei_leaf_lo;  <span class="comment">/* pointer to the physical block of the next *</span></span><br><span class="line"><span class="comment">         * level. leaf or next index could be there */</span></span><br><span class="line">  __le16  ei_leaf_hi;  <span class="comment">/* high 16 bits of physical block */</span></span><br><span class="line">  __u16  ei_unused;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>eh_depth 为 0，也即 inode 里面的就是叶子节点，树高度为 0。eh_depth&gt;0 的节点就是索引节点，其中根节点深度最大，在 inode 中。</p>
<p>除了根节点，其他的节点都保存在一个块 4k 里面，4k 扣除 ext4_extent_header 的 12 个 byte，剩下的能够放 340 项，每个 extent 最大能表示 128MB 的数据，340 个 extent 会使你表示的文件达到 42.5GB。这已经非常大了，如果再大，我们可以增加树的深度。</p>
<h2 id="inode-位图和块位图"><a href="#inode-位图和块位图" class="headerlink" title="inode 位图和块位图"></a>inode 位图和块位图</h2><p>在文件系统里面，我们专门弄了一个块来保存 inode 的位图。在这 4k 里面，每一位对应一个 inode。如果是 1，表示这个 inode 已经被用了；如果是 0，则表示没被用。同样，我们也弄了一个块保存 block 的位图。</p>
<p>我们调用open函数的时候，如果传入了参数 包含 O_CREAT， 那么在文件不存在的时候会创建文件， open实际上调用的是sys_open系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(open, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">int</span>, flags, <span class="type">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">    flags |= O_LARGEFILE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用链：do_sys_open-&gt; do_filp_open-&gt;path_openat-&gt;do_last-&gt;lookup_open。这个调用链的逻辑是，要打开一个文件，先要根据路径找到文件夹。如果发现文件夹下面没有这个文件，同时又设置了 O_CREAT，就说明我们要在这个文件夹下面创建一个文件，那我们就需要一个新的 inode。主要逻辑就是在inode位图中找到一个空的位，然后使用该inode，设置为已占用，然后填写各种信息。具体的是调用dir_inode对应的回调函数。</p>
<h2 id="文件系统的格式"><a href="#文件系统的格式" class="headerlink" title="文件系统的格式"></a>文件系统的格式</h2><img src="/images/202102/disk_fs.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<p>文件系统的结构大概就是这样子， 我们可以看到，分级的概念在linux整体的架构中随处可见， 果然是万金油。实际上，在大多数的项目开发中，这种分级思想也是应用很广泛。</p>
<h2 id="目录的存储格式"><a href="#目录的存储格式" class="headerlink" title="目录的存储格式"></a>目录的存储格式</h2><p>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。这些信息我们称为 ext4_dir_entry。从代码来看，有两个版本，在成员来讲几乎没有差别，只不过第二个版本 ext4_dir_entry_2 是将一个 16 位的 name_len，变成了一个 8 位的 name_len 和 8 位的 file_type。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_dir_entry</span> &#123;</span></span><br><span class="line">  __le32  inode;      <span class="comment">/* Inode number */</span></span><br><span class="line">  __le16  rec_len;    <span class="comment">/* Directory entry length */</span></span><br><span class="line">  __le16  name_len;    <span class="comment">/* Name length */</span></span><br><span class="line">  <span class="type">char</span>  name[EXT4_NAME_LEN];  <span class="comment">/* File name */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_dir_entry_2</span> &#123;</span></span><br><span class="line">  __le32  inode;      <span class="comment">/* Inode number */</span></span><br><span class="line">  __le16  rec_len;    <span class="comment">/* Directory entry length */</span></span><br><span class="line">  __u8  name_len;    <span class="comment">/* Name length */</span></span><br><span class="line">  __u8  file_type;</span><br><span class="line">  <span class="type">char</span>  name[EXT4_NAME_LEN];  <span class="comment">/* File name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每一项都会保存这个目录的下一级的文件的文件名和对应的 inode，通过这个 inode，就能找到真正的文件。第一项是“.”，表示当前目录，第二项是“…”，表示上一级目录，接下来就是一项一项的文件名和 inode。</p>
<p>同样的，如果目录下文件太多， linxu又采用了索引的方式解决查找慢的问题。</p>
<p>如果在 inode 中设置 EXT4_INDEX_FL 标志，则目录文件的块的组织形式将发生变化，变成了下面定义的这个样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_root</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fake_dirent</span> <span class="title">dot</span>;</span></span><br><span class="line">  <span class="type">char</span> dot_name[<span class="number">4</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fake_dirent</span> <span class="title">dotdot</span>;</span></span><br><span class="line">  <span class="type">char</span> dotdot_name[<span class="number">4</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dx_root_info</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __le32 reserved_zero;</span><br><span class="line">    u8 hash_version;</span><br><span class="line">    u8 info_length; <span class="comment">/* 8 */</span></span><br><span class="line">    u8 indirect_levels;</span><br><span class="line">    u8 unused_flags;</span><br><span class="line">  &#125;</span><br><span class="line">  info;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dx_entry</span>  <span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>索引项 dx_entry。这个也很简单，其实就是文件名的哈希值和数据块的一个映射关系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __le32 hash;</span><br><span class="line">  __le32 block;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过hash找到块， 然后打开这个块，如果里面不再是索引，而是索引树的叶子节点的话，那里面还是 ext4_dir_entry_2 的列表，我们只要一项一项找文件名就行。通过索引树，我们可以将一个目录下面的 N 多的文件分散到很多的块里面，可以很快地进行查找。这个就是利用了hash表的查找原理，比数组遍历高效多了。</p>
<img src="/images/202102/inode_index.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<h2 id="软链接和硬链接的存储格式"><a href="#软链接和硬链接的存储格式" class="headerlink" title="软链接和硬链接的存储格式"></a>软链接和硬链接的存储格式</h2><p>所谓的链接（Link），我们可以认为是文件的别名，而链接又可分为两种，硬链接与软链接。通过下面的命令可以创建。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ln -s 创建的是软链接，不带 -s 创建的是硬链接。 &#x2F;&#x2F; soft</p>
<p>硬链接与原始文件共用一个 inode 的，但是 inode 是不跨文件系统的，每个文件系统都有自己的 inode 列表，因而硬链接是没有办法跨文件系统的。</p>
<p>而软链接不同，软链接相当于重新创建了一个文件。这个文件也有独立的 inode，只不过打开这个文件看里面内容的时候，内容指向另外的一个文件。这就很灵活了。我们可以跨文件系统，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p>
<img src="/images/202102/inode_link.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看文件inode:stat filename</span><br><span class="line">查看目录inode:stat dirname</span><br><span class="line">查看磁盘inode:df -i</span><br></pre></td></tr></table></figure>





<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>gitbook使用</title>
    <url>/2021/05/15/2021-20210515-gitbook/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在英文文档中游离，不断的吸取协议规范的点点滴滴。发现还是有一点儿费劲的，在阅读的同时自然少不了做一些笔记。以往的经验，都是在word或者txt文档里面，记录一下自己感觉比较重要的点，同时在记录的过程中增加理解。阅读文档和阅读代码，我都是这样子做的。相信大多数程序员也都差不多吧。</p>
<span id="more"></span>

<p>了解一个新的领域，首先是看网络上关于这个领域的介绍，让自己对这个领域有初步的理解。然后就是快速阅读官方关于这个领域制定的文档，对其内容有一个全局的理解。再者就是去看代码了，先看一下代码相关的README, 然后结合着文档对代码进行学习。每一步都可以做一下笔记，同时记录一下自己的疑问和心得、想法，以便在后续的学习中按图索骥，加深对细节的理解和掌握。</p>
<p>最近开始netconf一系列规范的学习，首先是多个RFC文档的阅读。相关的RFC比较多，使用以往的经验学习，感觉有点儿杂乱无章的感觉。在网络上找到一些博客，发现他们通过gitbook的使用，把不同的RFC阅读笔记整理出来，这是一个不错的实践。这不，我也开始了解一下gitbook的使用，打算也这么干。</p>
<h2 id="gitbook"><a href="#gitbook" class="headerlink" title="gitbook"></a>gitbook</h2><p>gitbook介绍的话不多说， 在网络上可以搜到很多gitbook的教程。这里就记录一下自己搭建gitbook到博客上的想法及步骤。</p>
<p>参照他人的做法，在博客上添加一个gitbook的标签，指向一个总的gitbook的索引页面。  这个索引页面是markdown写的，权重改小一点，让他不会置顶，可以通过标签访问到。</p>
<p>针对每个RFC或者其他协议的文档笔记，都在一个新的统一git仓库中创建，每个占用一个顶级目录。生成的html文档拷贝到博客的一个gitbook的目录下，这个目录不需要渲染。</p>
<h3 id="安装、创建"><a href="#安装、创建" class="headerlink" title="安装、创建"></a>安装、创建</h3><p>安装gitbook</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install gitbook -g</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir RFC7950</span><br><span class="line">cd RFC7950</span><br><span class="line">gitbook init</span><br><span class="line"></span><br><span class="line">// write notes</span><br><span class="line"></span><br><span class="line">gitbook serve</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拷贝’_book’目录到source下的gbook目录下，修改目录名称为具体的主题名（注意：这里主题名不能以下划线开头，否则会被忽略掉，不被拷贝到public目录），如 rfc7950。</p>
<p>skip_render 添加 gbook&#x2F;**&#x2F;*</p>
<p>去除自带插件<br>Gitbook 默认带有 5 个插件：</p>
<ul>
<li>highlight</li>
<li>search</li>
<li>sharing</li>
<li>font-settings</li>
<li>livereload</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// book.json</span><br><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;-search&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>嗯，这样简单的gitbook集成pages就可以。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>普通进程、守护进程和后台进程</title>
    <url>/2021/06/20/2021-20210620-daemon/</url>
    <content><![CDATA[<p>最近看代码，一些服务进程在main函数中会调用daemon函数创建守护进程，然后继续执行。 又联想到之前项目在调试的时候，一般在shell中会执行多次的程序名后加一个&amp;符号，让进程进入后台执行，还可以看到终端的输出。有时候我们自己写的小程序，在shell中使用程序名执行，查看输出结果。</p>
<span id="more"></span>

<p>上面三种进程，分别对应到守护进程、后台进程和前台进程(一般也可以叫普通进程?)。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作。对于那些没有交互的进程，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。</p>
<p>守护进程是生存期长的一种进程。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。也就是指daemon和service。比如web服务器， syslog服务。</p>
<p>普通和后台进程在shell退出时，进程也会终止，这个时候可以使用nohup 程序名 &amp;来实现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">nohup ping www.baidu.com &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用了nohup命令后，会在当前目录下生成一个nohup.out的日志文件，记录的就是命令的输出。</p>
<p>守护进程，就是shell退出，也会运行。</p>
<h2 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h2><p>守护进程：ps -x</p>
<p>普通进程：ps 或 带参数的其他ps命令</p>
<p>后台进程：jobs 或 前面的上述的那些命令</p>
<h2 id="daemon函数使用"><a href="#daemon函数使用" class="headerlink" title="daemon函数使用"></a>daemon函数使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    The  daemon()  function is for programs wishing to detach themselves from the controlling</span></span><br><span class="line"><span class="comment">       terminal and run in the background as system daemons.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If nochdir is zero, daemon() changes the process&#x27;s current working directory to the  root</span></span><br><span class="line"><span class="comment">       directory (&quot;/&quot;); otherwise, the current working directory is left unchanged.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If noclose is zero, daemon() redirects standard input, standard output and standard error</span></span><br><span class="line"><span class="comment">       to /dev/null; otherwise, no changes are made to these file descriptors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     On success daemon() returns zero.  If an</span></span><br><span class="line"><span class="comment">       error occurs, daemon() returns -1 and sets errno to any of the errors specified  for  the</span></span><br><span class="line"><span class="comment">       fork(2) and setsid(2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// int daemon(int nochdir, int noclose); </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1111 now pid is  %d\r\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (daemon(<span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;create daemon success\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;22222 now pid is %d\r\n&quot;</span>, getpid());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;count %d daemon(%d)\r\n&quot;</span>, count++, getpid());</span><br><span class="line">        sleep(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;daemon(%d) exit\r\n&quot;</span>, count++, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们创建了一个守护进程， 让他运行60s后退出，并输出运行的信息。</p>
<p>程序运行过程中，我们可以退出shell，然后重新进一个shell， 可以通过ps -x看到进程还在运行。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>gitbook笔记</title>
    <url>/2021/05/15/2021-20210515-gitbook-index/</url>
    <content><![CDATA[<p>这是所有笔记的入口</p>
<ul>
<li><a href="/gbook/rfc7950/index.html">RFC7950</a></li>
</ul>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>buildroot的简单使用（二）</title>
    <url>/2021/06/27/2021-20210627-buildroot2/</url>
    <content><![CDATA[<p>前面一文主要讲了<code>buildroot</code>的使用及一些结构。 这里讲一下如何使用<code>buildroot</code>来编译一个<code>package</code>。</p>
<span id="more"></span>


<h2 id="Config-in和-mk"><a href="#Config-in和-mk" class="headerlink" title="Config.in和.mk"></a>Config.in和<package>.mk</h2><p>首先，编译package需要使用到2个主要的文件， <code>Config.in</code>和<code>&lt;package&gt;.mk</code>。</p>
<h3 id="Config-in文件"><a href="#Config-in文件" class="headerlink" title="Config.in文件"></a>Config.in文件</h3><p><code>Config.in</code>文件包含了<code>buildroot</code>里面可配置的所有项目。</p>
<p>范例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config BR2_PACKAGE_LIBFOO</span><br><span class="line">        bool &quot;libfoo&quot;</span><br><span class="line">        depends on BR2_PACKAGE_LIBBAZ</span><br><span class="line">        select BR2_PACKAGE_LIBBAR</span><br><span class="line">        help</span><br><span class="line">          This is a comment that explains what libfoo is. The help text</span><br><span class="line">          should be wrapped.</span><br><span class="line"></span><br><span class="line">          http://foosoftware.org/libfoo/</span><br></pre></td></tr></table></figure>

<p><code>Config.in</code>文件是<code>buildroot</code>配置工具的输入，使用的是<code>Kconfig</code>格式。具体见·<code>http://kernel.org/doc/Documentation/kbuild/kconfig-language.txt.</code></p>
<p>可以通过<code>make menuconfig</code>命令选择编译的包。</p>
<h3 id="mk文件"><a href="#mk文件" class="headerlink" title=".mk文件"></a>.mk文件</h3><p>开始是一个文件头，包含模块名，一般都是小写的，前后被80个#包含。头部后面紧跟着空行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">################################################################################</span><br><span class="line">#</span><br><span class="line"># libfoo</span><br><span class="line">#</span><br><span class="line">################################################################################</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后是赋值语句，等号两边有空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIBFOO_VERSION = 1.0</span><br><span class="line">LIBFOO_CONF_OPTS += --without-python-support</span><br></pre></td></tr></table></figure>

<p>缩进使用tab符号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define LIBFOO_REMOVE_DOC</span><br><span class="line">        $(RM) -fr $(TARGET_DIR)/usr/share/libfoo/doc \</span><br><span class="line">                $(TARGET_DIR)/usr/share/man/man3/libfoo*</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>命令前面必须是<code>tab</code>，才会被识别为命令。</p>
<p>紧跟着是依赖和配置选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifeq ($(BR2_PACKAGE_PYTHON),y)</span><br><span class="line">LIBFOO_CONF_OPTS += --with-python-support</span><br><span class="line">LIBFOO_DEPENDENCIES += python</span><br><span class="line">else</span><br><span class="line">LIBFOO_CONF_OPTS += --without-python-support</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>最后是 <code>eval 语句</code>， 表示包是使用何种编译系统。</p>
<h2 id="如何新增一个package到buildroot"><a href="#如何新增一个package到buildroot" class="headerlink" title="如何新增一个package到buildroot"></a>如何新增一个<code>package</code>到<code>buildroot</code></h2><h3 id="新增package目录"><a href="#新增package目录" class="headerlink" title="新增package目录"></a>新增<code>package</code>目录</h3><p>首先在<code>package</code>目录下创建对应的目录， 比如：<code>package/nginx</code>.</p>
<p>然后再在该目录创建<code>Config.in</code>文件或者<code>Config.in.host</code>文件。</p>
<h4 id="Config-in文件-1"><a href="#Config-in文件-1" class="headerlink" title="Config.in文件"></a><code>Config.in</code>文件</h4><p>用于编译运行在目标平台的包使用的<code>Config.in</code>文件。这个文件包含一些<code>package</code>相关的选项，并用于在配置工具中显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config BR2_PACKAGE_LIBFOO</span><br><span class="line">        bool &quot;libfoo&quot;</span><br><span class="line">        help</span><br><span class="line">          This is a comment that explains what libfoo is. The help text</span><br><span class="line">          should be wrapped.</span><br><span class="line"></span><br><span class="line">          http://foosoftware.org/libfoo/</span><br></pre></td></tr></table></figure>

<p>这些属性有相对固定的顺序：</p>
<ul>
<li>bool、string属性</li>
<li>default值</li>
<li>target 依赖</li>
<li>toolchain依赖</li>
<li>packages依赖</li>
<li>select依赖</li>
<li>help text</li>
</ul>
<p>然后再在外层的Config.in中添加引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;package/libfoo/Config.in&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Config-in-host文件"><a href="#Config-in-host文件" class="headerlink" title="Config.in.host文件"></a>Config.in.host文件</h4><p>用于编译运行在host的package， 使用的Config.in.host。</p>
<p>略过</p>
<p><code>Config.in</code>文件需要保证依赖的包.</p>
<p>主要有2种选项， <code>depends on</code>和<code>select</code>。 </p>
<p>A depends on B  ，只有A被选择了之后，B才可见（B是否可见取决于A）<br>B    select   C ，B被选择了，就会自动选择C（C的可见性与B无关）</p>
<h4 id="mk文件-1"><a href="#mk文件-1" class="headerlink" title=".mk文件"></a>.mk文件</h4><p>.mk文件用于描述<code>package</code>是怎么下载， 配置、编译和安装的。根据<code>package</code>的类型， .mk文件使用不同的格式编写。</p>
<h4 id="hash文件"><a href="#hash文件" class="headerlink" title=".hash文件"></a>.hash文件</h4><p>包含下载文件的hash值， 用于校验下载包。</p>
<p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hashes from: http://www.foosoftware.org/download/libfoo-1.2.3.tar.bz2.&#123;sha1,sha256&#125;:</span><br><span class="line">sha1  486fb55c3efa71148fe07895fd713ea3a5ae343a  libfoo-1.2.3.tar.bz2</span><br><span class="line">sha256  efc8103cc3bcb06bda6a781532d12701eb081ad83e8f90004b39ab81b65d4369  libfoo-1.2.3.tar.bz2</span><br><span class="line"></span><br><span class="line"># md5 from: http://www.foosoftware.org/download/libfoo-1.2.3.tar.bz2.md5, sha256 locally computed:</span><br><span class="line">md5  2d608f3c318c6b7557d551a5a09314f03452f1a1  libfoo-data.bin</span><br><span class="line">sha256  01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b  libfoo-data.bin</span><br><span class="line"></span><br><span class="line"># Locally computed:</span><br><span class="line">sha256  ff52101fb90bbfc3fe9475e425688c660f46216d7e751c4bbdb1dc85cdccacb9  libfoo-fix-blabla.patch</span><br><span class="line"></span><br><span class="line"># No hash for 1234:</span><br><span class="line">none  xxx  libfoo-1234.tar.gz</span><br><span class="line"></span><br><span class="line"># Hash for license files:</span><br><span class="line">sha256  a45a845012742796534f7e91fe623262ccfb99460a2bd04015bd28d66fba95b8  COPYING</span><br><span class="line">sha256  01b1f9f2c8ee648a7a596a1abe8aa4ed7899b1c9e5551bda06da6e422b04aa55  doc/COPYING.LGPL</span><br></pre></td></tr></table></figure>


<p>如果下载后比较了不匹配，那么下载包将被删除，并且放弃编译。</p>
<p><code>buildroot</code>官网提供了一个完整的压缩包，里面包含了很多需要交叉编译的常用的包。可以下载来了看一下别人是怎么写的，这里贴一个最新的链接。</p>
<p><a href="https://buildroot.org/downloads/buildroot-2021.02.3.tar.gz">https://buildroot.org/downloads/buildroot-2021.02.3.tar.gz</a></p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
        <category>buildroot</category>
      </categories>
  </entry>
  <entry>
    <title>virtualbox 磁盘扩容</title>
    <url>/2021/07/01/2021-20210701-vm-disk/</url>
    <content><![CDATA[<p>之前安装的虚拟机，选择的磁盘只有10G， 随着时间的推移，空间不够了。需要进行磁盘的扩容。</p>
<span id="more"></span>

<p>进入virtualbox安装目录</p>
<p>C:\Program Files\Oracle\VirtualBox</p>
<p>执行VBoxManage list hdds查看当前所有的虚拟磁盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;cd C:\Program Files\Oracle\VirtualBox</span><br><span class="line"></span><br><span class="line">C:\Program Files\Oracle\VirtualBox&gt;VBoxManage list hdds</span><br><span class="line">UUID:           639e89b2-0afa-4e0b-bfa5-09297bef4b09</span><br><span class="line">Parent UUID:    base</span><br><span class="line">State:          created</span><br><span class="line">Type:           normal (base)</span><br><span class="line">Location:       D:\VM\ubuntu\ubuntu.vdi</span><br><span class="line">Storage format: VDI</span><br><span class="line">Capacity:       20480 MBytes</span><br><span class="line">Encryption:     disabled</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记录UUID然后执行命令 修改大小为300G</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">C:\Program Files\Oracle\VirtualBox&gt;VBoxManage modifyhd 639e89b2-0afa-4e0b-bfa5-09297bef4b09   --resize 307200</span><br><span class="line">0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>虚拟机开机<br>运行 du -ah， 可以看到sda1大小没有变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root ~]df -ah </span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">sysfs              0     0     0     - /sys</span><br><span class="line">proc               0     0     0     - /proc</span><br><span class="line">udev            1.9G     0  1.9G    0% /dev</span><br><span class="line">devpts             0     0     0     - /dev/pts</span><br><span class="line">tmpfs           394M  1.6M  393M    1% /run</span><br><span class="line">/dev/sda1        20G   14G  5.3G   72% /</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这里， 我们可以安装一个图形化的磁盘工具 gparted</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install gparted</span><br></pre></td></tr></table></figure>

<p>使用gparted方便的调整磁盘的大小</p>
<img src="/images/202107/gparted-1.png" alt="图片替换文本" width="600" height="513" align="bottom" />
<img src="/images/202107/gparted-2.png" alt="图片替换文本" width="600" height="513" align="bottom" />
<img src="/images/202107/gparted-3.png" alt="图片替换文本" width="600" height="513" align="bottom" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root ~]df -ah </span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">sysfs              0     0     0     - /sys</span><br><span class="line">proc               0     0     0     - /proc</span><br><span class="line">udev            1.9G     0  1.9G    0% /dev</span><br><span class="line">devpts             0     0     0     - /dev/pts</span><br><span class="line">tmpfs           394M  1.7M  393M    1% /run</span><br><span class="line">/dev/sda1        30G   14G   15G   48% /</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
        <category>经验</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈Linux的systemd服务管理</title>
    <url>/2021/07/17/2021-20210717-systemd/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目中很多进程都是注册为服务，在系统启动的时候自动运行。抽空仔细的学习了一下<code>systemd</code>服务管理，在此做一个小结。</p>
<span id="more"></span>

<h2 id="systemd-概述"><a href="#systemd-概述" class="headerlink" title="systemd 概述"></a>systemd 概述</h2><p>之前在极客时间上面学习过一个专栏《趣谈Linux操作系统》， 有了解到系统的首个进程是<code>init</code>进程， 后续的进程都是通过<code>init</code>来起来的。服务基本上都是通过脚本启动，主要的脚本在<code>/etc/init.d</code>下面。服务主要有两类： 独立模式和托管模式。独立模式就是服务独立启动，常驻内存的， 托管模式就是通过<code>inetd</code>或者<code>xinetd</code>对<code>socket</code>和<code>port</code>进行管理， 当用户有需求时再去唤醒相应的服务程序。</p>
<p>而<code>systemd</code>基本上替代了旧的<code>initd</code>，实现了对服务的管理。有如下特点：</p>
<ul>
<li>平行处理所有的服务，加速了开机的流程。 <code>init</code>是串行的执行启动脚本，时间上会比较慢。<code>systemd</code>可以并发执行不相关的服务，启动速度更快。</li>
<li>通过<code>systemctl</code>实现<code>on-demand</code>的启动方式。默认<code>systemd</code>是一个常驻内存的进程，通过执行<code>systemctl</code>的命令就可以快速的实现服务的管理。</li>
<li>支持服务依赖的检查。<code>systemd</code>通过服务的文件描述了相关服务的依赖说明。<code>systemd</code>通过解析服务文件，自动进行服务启动的管理。省却了人工管理的麻烦。</li>
<li>支持<code>daemon</code>的分类。<code>systemd</code>的<code>unit</code>可以分成多种类型， <code>service, socket, target, path, timer,snapshot</code>等。</li>
<li>相关的服务可以分组，就是有一个<code>target</code>类型的服务包含多个相关的其它类型的服务， 便于管理。</li>
<li>兼容<code>init</code>的服务脚本。</li>
</ul>
<p><code>systemd</code>也有缺点，并不能实现对就有<code>init</code>功能的一一对应。但是为了启动更便捷，牺牲一些功能还是值得的。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><code>systemd</code>的服务文件主要放在三个地方。</p>
<ul>
<li>&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;: 软件安装的时候配置文件安装的位置，默认是不需要修改的。</li>
<li>&#x2F;run&#x2F;systemd&#x2F;system&#x2F;: 系统执行过程中产生的服务脚本， 这个目录下的脚本内容可以覆盖上面那个脚本的内容。</li>
<li>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;: 这个是<code>systemd</code>实际运行的脚本。一般自动运行的服务都会在这里创建一个链接指向前面两个的位置，<code>systemd</code>启动的时候会依旧当前目录的文件依次启动服务。</li>
</ul>
<p>还有几个相关的目录：</p>
<ul>
<li>&#x2F;etc&#x2F;sysconfig&#x2F;*:  存放一些初始化的参数配置</li>
<li>&#x2F;var&#x2F;lib： 一般存放产生的数据文件</li>
<li>&#x2F;run&#x2F;: 运行过程中产生的一些文件， 比如： lock文件， pid文件。 这些文件也可能存放在&#x2F;run&#x2F;下面</li>
</ul>
<p><code>systemd</code>的服务单元分类：</p>
<ul>
<li>service。 一般的服务分类，主要是系统服务，进程服务。最常见的类型</li>
<li>socket. 内部交换的，主要进程间通信的吧， 具体还待深入了解， 不是很常用</li>
<li>target。 群组类型，可以执行一堆其他的服务。</li>
<li>mount. 执行文件系统挂载相关的服务。</li>
<li>path。 用于侦测特定目录文件的服务。</li>
<li>timer。 循环执行的服务。</li>
</ul>
<h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><p><code>systemd</code>使用<code>systemctl</code>指令对服务进行管理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start xxx  启动服务</span><br><span class="line">systemctl stop xxx 停止服务</span><br><span class="line">systemctl restart xxx 重启服务</span><br><span class="line">systemctl reload xxx  服务不关闭，重新载入配置，让配置生效。</span><br><span class="line">systemctl enable xxx  设置服务自动启动，其实就是在/etc/systemd/system下面创建一个对应的链接</span><br><span class="line">systemctl disable xxx 设置服务不自动启动 就是删除上面的链接</span><br><span class="line">systemctl status xxx 查看服务的状态信息</span><br><span class="line">systemctl list-units --type=service --all 查看所有service类型服务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务只有通过<code>systemctl</code>管理，才可以被<code>systemd</code>监控到，手动执行的话就检测不到了。</p>
<p>还有一些小技巧。例如，切换图形界面<code>graphical.target</code>和命令行界面<code>multi-user.target</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl get-default  // 获取当前运行的target</span><br><span class="line">systemctl set-default multi-user.target // 设置下次启动默认的模式</span><br><span class="line">systemctl isolate graphical.target // 切换到图形界面模式</span><br><span class="line"></span><br><span class="line">linux还提供快捷命令切换不同的模式</span><br><span class="line"></span><br><span class="line">[root@study ~]# systemctl poweroff 系统关机 </span><br><span class="line">[root@study ~]# systemctl reboot 重新开机 </span><br><span class="line">[root@study ~]# systemctl suspend 进入暂停模式 </span><br><span class="line">[root@study ~]# systemctl hibernate 进入休眠模式 </span><br><span class="line">[root@study ~]# systemctl rescue 强制进入救援模式 </span><br><span class="line">[root@study ~]# systemctl emergency 强制进入紧急救援模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> systemctl list-dependencies [unit] [--reverse]   // 查看某个unit依赖的服务， --reverse表示显示这个unit被谁依赖(使用)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="服务文件的编写"><a href="#服务文件的编写" class="headerlink" title="服务文件的编写"></a>服务文件的编写</h3><p>下面是<code>sshd.service</code>文件的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /usr/lib/systemd/system/sshd.service </span><br><span class="line"></span><br><span class="line">[Unit] # 这个项目与此 unit 的解释、执行服务相依性有关 </span><br><span class="line">Description=OpenSSH server daemon </span><br><span class="line">After=network.target sshd-keygen.service </span><br><span class="line">Wants=sshd-keygen.service </span><br><span class="line"></span><br><span class="line">[Service] # 这个项目与实际执行的指令参数有关 </span><br><span class="line">EnvironmentFile=/etc/sysconfig/sshd </span><br><span class="line">ExecStart=/usr/sbin/sshd -D $OPTIONS </span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID </span><br><span class="line">KillMode=process </span><br><span class="line">Restart=on-failure </span><br><span class="line">RestartSec=42s </span><br><span class="line"></span><br><span class="line">[Install] # 这个项目说明此 unit 要挂载哪个 target 下面 </span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大部分的<code>service</code>文件格式都是如上，就是一些相关的选项不一样，具体的可以参考网络文章学习一下。</p>
<h3 id="多重服务实例"><a href="#多重服务实例" class="headerlink" title="多重服务实例"></a>多重服务实例</h3><p><code>systemd</code>还支持设置多个相同服务的不同实例， 这个主要是通过 <code>xxx@.service</code>实现的。带有<code>@</code>符号，表示这个<code>service</code>可以实现多个实例，然后里面会是一个带有参数<code>%I</code>的配置文件，根据参数的不同 最终实现不一样的服务实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始文件：执行服务名称@.service</span><br><span class="line">可执行文件案：执行服务名称@范例名称.service</span><br></pre></td></tr></table></figure>

<p>比较常见的<code>vtty</code>、还有<code>Ubuntu</code>下面不同网络空间的服务程序。</p>
<p><code>systemd</code>是一个原理简单，细节很多的一个服务管理程序。如果有需要使用到的话，还有待深入了解。一般使用的话，了解上面的那些命令及知识基本就足够了。</p>
<p>学习<code>systemd</code>这个知识的话，比较简单易读的还是鸟哥的Linux私房菜，虽然有一些实现有一点点出入，还有就是湾湾翻译的跟我们的习惯还是有点不一样。看书籍还是有好处的， 当然最好的材料还是英文文档。另外一个就是阮一峰的博客，这位老师的博文质量都是杠杠的。</p>
<p>另外， <code>systemd</code>是一个开源的程序,在<code>github</code>上面可以找到源代码，systemctl的实现跟一个dbus的程序相关，下一次聊一聊dbus服务，主要是项目中需要用到dbus服务实现一个功能，我也简单了解了一下。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>buildroot的简单使用（一）</title>
    <url>/2021/06/27/2021-20210627-buildroot/</url>
    <content><![CDATA[<p>最近需要编译一个arm平台上面的nginx，项目使用的buildroot构建环境，实现自动化的编译。前期的构建工具之类的已经由平台组的同事弄好了，主要的工作就是进行nginx的交叉编译，中间陆续踩了许多坑，简单聊聊吧。</p>
<span id="more"></span>

<p>做事的第一步就是磨刀，了解编译系统的基础使用。项目资料也挺缺的，没有人提供一个指导性的文档。一开始就是口头让写个Config.in和xxx.mk文件。我也丈二的和尚没摸着头脑，第一次接触这个编译环境，不熟悉。直接参照其他模块编写了Config.in和xxx.mk，下载nginx的源码，就这么开始了构建了。</p>
<p>首先 <code>make xxxdefconfig</code>，然后创建host的sysroot目录，安装一下基础的组件包。 然后就是 <code>make menuconfig</code>选择了编译nginx。接下来就是<code>make nginx</code>了。一切就开始了，各种报错，基本的参数设置也没有搞懂。这样下去可不行，然后通过BR2这个关键字上网查到了使用的是buildroot， 对比一下项目的结构，大同小异。</p>
<p>然后就是上官网看文档了。 还是有许多的错误解决不了，在讨论组里面询问一下问题，呵呵 平台的人就让拷贝官方的buildroot包里面的nginx脚本，我石化了 既然有这东西怎么在任务安排的时候不提前讲了。 哦了， 就赶紧去下载官方buildroot包，拷贝nginx的脚本，修改修改开始编译。</p>
<p>中间遇到许多编译错误，通过错误找到对应的脚本，基本都是缺失了某个库，然后再到buildroot下查找对应的包目录，拷贝脚本然后编译安装，然后继续nginx的编译。 期间发现有一个问题， 每次make clean的时候，之前安装的基础包也会被清掉，需要重新安装一下。然后我就取巧了一下，编译的时候不make clean，而是删除output&#x2F;build&#x2F;nginx-xxx的目录，再执行make nginx的时候，就只会进行nginx的编译，顺利解决基础包需要重装的问题。(今天看网络文章，发现有<code>make &lt;package&gt;-dirclean </code>这个命令) 中间还有许多的问题，边编译边解决，哈哈， 这么来回搞了2天吧，目前还有错误，下周继续再战吧。</p>
<p>等搞定nginx的编译，到时候再来发一个问题汇总。</p>
<p>嗯，今天周末我再来熟悉熟悉buildroot的使用。</p>
<h2 id="buildroot"><a href="#buildroot" class="headerlink" title="buildroot"></a>buildroot</h2><p>buildroot主要用来作交叉编译的。需要交叉编译的基本上都是嵌入式系统，目标系统没有足够的资源用于编译。buildroot支持许多目标处理器的编译。</p>
<p>buildroot是需要运行于linux系统上的。buildroot首先需要基于许多主机包，在主机(执行编译的系统)上需要安装好所需要的依赖软件。</p>
<p>依赖包:</p>
<p>必须的，比如：wget, which, sed, binutils, gcc, g++, bash, patch, gzip, bzip2, perl, tar, unzip, bc 等</p>
<p>可选的， 比如： python， glib2， git, svn, javac， jar， w3m, graphviz等</p>
<h3 id="buildroot快速入门"><a href="#buildroot快速入门" class="headerlink" title="buildroot快速入门"></a>buildroot快速入门</h3><p>主要的编译命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make menuconfig // 选择要编译的项目， 生成.config文件， 会被顶级的Makefile引用。</span><br><span class="line"></span><br><span class="line">make // 开始编译， 这将编译完整所有选择的项目</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>make执行的步骤：</p>
<ul>
<li>下载源文件</li>
<li>配置工具链</li>
<li>配置编译安装选择的目标包</li>
<li>编译一个内核镜像， if selected</li>
<li>编译一个bootloader镜像， if selected</li>
<li>创建一个root filesystem in selected formats.</li>
</ul>
<p>所有的编译输出到output目录下， 这个目录下包含几个子目录</p>
<ul>
<li>images&#x2F; 所有映像存储的位置，这些是需要放到目标系统的文件</li>
<li>build&#x2F; 所有组件执行编译的位置，各个组件都会有一个对应的目录</li>
<li>host&#x2F; 包含host的编译工具和sysroot of target的编译工具链。首先安装了buildroot运行所必须的编译工具，然后就是一个root目录的结构，主要包含编译包所依赖的各种头文件、lib及包。这个目录主要用来编译的，并不是最终嵌入式系统的root结构。</li>
<li>staging&#x2F; 这是一个符号链接， 指向host&#x2F;…&#x2F;sysroot, 主要是为了向前兼容而保留的。</li>
<li>target&#x2F; 包含了目标系统几乎完整的root 文件系统，除了没有&#x2F;dev&#x2F;。也缺失了准确的权限，也不能直接用到最终的嵌入式系统。我们最终使用的是images目录下的安装文件来安装的。目标系统最终安装的文件，将缺失开发所需要的文件， 而且二进制文件是被stripped的</li>
</ul>
<h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><p>make menuconfig有一个快捷搜索工具，通过按下 &#x2F; 调出。然后输入字符串查找到指定的项， 最后输入列表的数字索引即可定位到具体的条目。</p>
<h4 id="交叉工具链"><a href="#交叉工具链" class="headerlink" title="交叉工具链"></a>交叉工具链</h4><p>pass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make sdk</span><br></pre></td></tr></table></figure>

<h4 id="x2F-dev管理"><a href="#x2F-dev管理" class="headerlink" title="&#x2F;dev管理"></a>&#x2F;dev管理</h4><p>pass</p>
<h4 id="init-system"><a href="#init-system" class="headerlink" title="init system"></a>init system</h4><p>pass</p>
<h3 id="通用指南"><a href="#通用指南" class="headerlink" title="通用指南"></a>通用指南</h3><p>有一些帮助命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make V=1 &lt;target&gt;  // 显示make执行的所有命令</span><br><span class="line">make list-defconfigs // 显示配置</span><br><span class="line">make help // 查看所有可用的target, 具体查看.config文件</span><br><span class="line">make clean // delete all build products (including build directories, host, staging and target trees, the images and the toolchain)</span><br><span class="line"></span><br><span class="line">make manual-clean // 帮助文件清理  /docs/manual目录</span><br><span class="line">make manual   // 帮助文件生成</span><br><span class="line"></span><br><span class="line">make distclean // deltete all build products as well as the configuration</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关于是否需要完整编译"><a href="#关于是否需要完整编译" class="headerlink" title="关于是否需要完整编译"></a>关于是否需要完整编译</h3><ul>
<li>目标架构变更时， 需要重新完整编译</li>
<li>工具链变更时， 需要完整编译</li>
<li>新增了一个package，不需要完整编译。如果新增了一个lib，需要手动编译lib或者完整编译。</li>
<li>删除了一个package，默认什么也不做。不会主动删除对应包已经安装到target root文件系统的sysroot的文件。</li>
<li>一个package修改了suboption，只需要重新编译package。一旦一个package编译了，那么它将不会被重新编译。</li>
<li>当依赖包重新编译或者删除了，该package不会自动重新编译。需要手动编译package。</li>
</ul>
<p>重新完整编译命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make clean all</span><br><span class="line"></span><br><span class="line">make &lt;package&gt;-dirclean  // 清除某个package的编译结果</span><br><span class="line">make &lt;package&gt;-rebuild.  // 仅仅重新编译文件</span><br><span class="line"></span><br><span class="line">make show-info // 导出包的信息， json格式</span><br><span class="line"></span><br><span class="line">make graph-depends  // 包的依赖树， 输出到 output/graphs/graph-depends.pdf</span><br><span class="line"></span><br><span class="line">make &lt;pkg&gt;-graph-depends  // 生成特定pkg的包依赖关系 </span><br><span class="line"></span><br><span class="line">// 生成graph 需要使用graphviz包</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用buildroot开发"><a href="#使用buildroot开发" class="headerlink" title="使用buildroot开发"></a>使用buildroot开发</h3><p>buildroot的正常的操作是下载压缩包、解压、配置然后编译、安装软件。源码会被解压到<code>output/build/&lt;pkg&gt;-&lt;version&gt;</code>目录，这个目录在make clean的时候会被删除。开发过程中，直接在这个目录作修改的话，很容易被清除掉。buildroot提供了一个机制，叫做<code>&lt;pkg&gt;_OVERRIDE_SRCDIR</code>， buildroot会读取一个文件，用户可以指定源码的路径。</p>
<p>可以通过<code>$(CONFIG_DIR)/local.mk</code>文件来定义位置关系。格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pkg1&gt;_OVERRIDE_SRCDIR = /path/to/pkg1/sources</span><br><span class="line">&lt;pkg2&gt;_OVERRIDE_SRCDIR = /path/to/pkg2/sources</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一旦buildroot发现定义了某个包的位置，那么它将不会下载、解压package了。而是直接使用指定的目录， 并且调用make clean时，也不会清除目录。buildroot会拷贝源文件到<code>output/build/&lt;pkg&gt;-custom</code>. 我们在修改完代码后，只需要<code>make &lt;pkg&gt;-rebuild all</code> 就会自动拷贝代码，很是方便。还可以指定不同步的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># local.mk</span><br><span class="line">WEBKITGTK_OVERRIDE_SRCDIR = /home/bob/WebKit</span><br><span class="line">WEBKITGTK_OVERRIDE_SRCDIR_RSYNC_EXCLUSIONS = \</span><br><span class="line">        --exclude JSTests --exclude ManualTests --exclude PerformanceTests \</span><br><span class="line">        --exclude WebDriverTests --exclude WebKitBuild --exclude WebKitLibraries \</span><br><span class="line">        --exclude WebKit.xcworkspace --exclude Websites --exclude Examples</span><br><span class="line">        --include .git</span><br></pre></td></tr></table></figure>



<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
        <category>buildroot</category>
      </categories>
  </entry>
  <entry>
    <title>nginx交叉编译问题</title>
    <url>/2021/07/24/2021-20210724-nginx-compile/</url>
    <content><![CDATA[<p>基于buildroot框架进行的交叉编译，首先拷贝官网buildroot包，然后拷贝里面的nginx的脚本配置。然后运行<code>make nginx</code>。</p>
<p>以下是前段时间编译nginx遇到的一些问题：</p>
<span id="more"></span>

<h2 id="1-checking-for-C-compiler-…-found-but-is-not-workong"><a href="#1-checking-for-C-compiler-…-found-but-is-not-workong" class="headerlink" title="1. checking for C compiler … found but is not workong"></a>1. checking for C compiler … found but is not workong</h2><p>这个主要是测试C编译器的， 在编译机器上肯定不能执行。 我们修改一下<code>auto/cc/name</code>下的配置，设置ngx_feature_run&#x3D;no。</p>
<h2 id="2-can-not-detect-int-size"><a href="#2-can-not-detect-int-size" class="headerlink" title="2. can not detect int size"></a>2. can not detect int size</h2><p>原因跟1一样， 直接修改<code>auto/types/sizeof</code> 设置ngx_size&#x3D;4</p>
<h2 id="3-checking-for-PCRE-library-…-not-found"><a href="#3-checking-for-PCRE-library-…-not-found" class="headerlink" title="3. checking for PCRE library … not found"></a>3. checking for PCRE library … not found</h2><p>依赖PCRE， 需要首先编译PCRE， 在make menuconfig 选择pcre。 如果没有，需要拷贝pcre相关的脚本 进行编译。</p>
<h2 id="4-the-HTTP-XSLT-module-requires-the-libxml2-x2F-libxslt"><a href="#4-the-HTTP-XSLT-module-requires-the-libxml2-x2F-libxslt" class="headerlink" title="4. the HTTP XSLT module requires the libxml2&#x2F;libxslt"></a>4. the HTTP XSLT module requires the libxml2&#x2F;libxslt</h2><p>同理，需要编译libxslt</p>
<h2 id="5-Could-not-find-libxml2-anywhere-check-ftp-xmlsoft-org"><a href="#5-Could-not-find-libxml2-anywhere-check-ftp-xmlsoft-org" class="headerlink" title="5. Could not find libxml2 anywhere, check ftp://xmlsoft.org/"></a>5. Could not find libxml2 anywhere, check <a href="ftp://xmlsoft.org/">ftp://xmlsoft.org/</a></h2><p>这个是由于我执行了make clean, host下依赖包都卸载了， 需要重新编译libxml2</p>
<h2 id="6-checking-for-GD-library-…objs-x2F-autotest-c-4-10-fatal-error-gd-h：-No-such-file-or-directory"><a href="#6-checking-for-GD-library-…objs-x2F-autotest-c-4-10-fatal-error-gd-h：-No-such-file-or-directory" class="headerlink" title="6. checking for GD library …objs&#x2F;autotest.c:4:10: fatal error: gd.h： No such file or directory"></a>6. checking for GD library …objs&#x2F;autotest.c:4:10: fatal error: gd.h： No such file or directory</h2><p>需要编译gd</p>
<h2 id="7-checking-for-GeoIP-library-…objs-x2F-autotest-c-4-10-fatal-error-GeoIP-h-No-such-file-or-directory"><a href="#7-checking-for-GeoIP-library-…objs-x2F-autotest-c-4-10-fatal-error-GeoIP-h-No-such-file-or-directory" class="headerlink" title="7. checking for GeoIP library …objs&#x2F;autotest.c:4:10: fatal error: GeoIP.h: No such file or directory"></a>7. checking for GeoIP library …objs&#x2F;autotest.c:4:10: fatal error: GeoIP.h: No such file or directory</h2><p>需要编译geoip</p>
<h2 id="8-xxx-gcc-Error-unsafe-header-x2F-library-path-use-in-cross-compilation-‘-I’-‘-x2F-usr-x2F-include-x2F-libxml2’"><a href="#8-xxx-gcc-Error-unsafe-header-x2F-library-path-use-in-cross-compilation-‘-I’-‘-x2F-usr-x2F-include-x2F-libxml2’" class="headerlink" title="8. xxx-gcc: Error: unsafe header&#x2F;library path use in cross-compilation: ‘-I’ ‘&#x2F;usr&#x2F;include&#x2F;libxml2’"></a>8. xxx-gcc: Error: unsafe header&#x2F;library path use in cross-compilation: ‘-I’ ‘&#x2F;usr&#x2F;include&#x2F;libxml2’</h2><p>在添加头文件的目录时， 在目录前面添加${STAGING_DIR}</p>
<h2 id="9-src-x2F-core-x2F-ngx-spinlock-c-47-2-error-error-ngx-spinlock-or-ngx-atomic-cmp-set-are-not-defined"><a href="#9-src-x2F-core-x2F-ngx-spinlock-c-47-2-error-error-ngx-spinlock-or-ngx-atomic-cmp-set-are-not-defined" class="headerlink" title="9. src&#x2F;core&#x2F;ngx_spinlock.c:47:2: error: #error ngx_spinlock() or ngx_atomic_cmp_set() are not defined !"></a>9. src&#x2F;core&#x2F;ngx_spinlock.c:47:2: error: #error ngx_spinlock() or ngx_atomic_cmp_set() are not defined !</h2><p>需要编译libatomic_ops。  修改<code>auto/lib/conf</code>  run&#x3D;no</p>
<h2 id="10-src-x2F-os-x2F-unix-x2F-ngx-errno-c-37-31-error-‘NGX-SYS-NERR’-undeclared-first-use-in-this-function-did-you-mean-‘NGX-LOG-ERR’"><a href="#10-src-x2F-os-x2F-unix-x2F-ngx-errno-c-37-31-error-‘NGX-SYS-NERR’-undeclared-first-use-in-this-function-did-you-mean-‘NGX-LOG-ERR’" class="headerlink" title="10. src&#x2F;os&#x2F;unix&#x2F;ngx_errno.c:37:31: error: ‘NGX_SYS_NERR’ undeclared(first use in this function); did you mean ‘NGX_LOG_ERR’?"></a>10. src&#x2F;os&#x2F;unix&#x2F;ngx_errno.c:37:31: error: ‘NGX_SYS_NERR’ undeclared(first use in this function); did you mean ‘NGX_LOG_ERR’?</h2><p>出错的原因仍然是因为交叉编译程序无法本地运行，手动在<code>auto/linux</code>下增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [$ngx_found = no]; then</span><br><span class="line">  cat &lt;&lt; END &gt;&gt; $NGX_AUTO_CONFIG_H</span><br><span class="line">#ifndef $ngx_feature_name</span><br><span class="line">#define $ngx_feature_name 132</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体的值可以看一下errno.h的宏</p>
<h2 id="11-undefined-reference-to-gdImageCreateFromJpegPtr"><a href="#11-undefined-reference-to-gdImageCreateFromJpegPtr" class="headerlink" title="11. undefined reference to gdImageCreateFromJpegPtr"></a>11. undefined reference to <code>gdImageCreateFromJpegPtr</code></h2><p>gd版本升级  2.2.5 –&gt; 2.3.0</p>
<h2 id="12-x2F-usr-x2F-bin-x2F-install-cannot-stat-package-nginx-nginx-logrotate-No-such-file-or-directory"><a href="#12-x2F-usr-x2F-bin-x2F-install-cannot-stat-package-nginx-nginx-logrotate-No-such-file-or-directory" class="headerlink" title="12. &#x2F;usr&#x2F;bin&#x2F;install: cannot stat package/nginx/nginx.logrotate: No such file or directory"></a>12. &#x2F;usr&#x2F;bin&#x2F;install: cannot stat <code>package/nginx/nginx.logrotate</code>: No such file or directory</h2><p>这个是目录错误了， 修改ngxin.mk。 相关<code>package/xxx</code>修改为<code>$(BR2_EXTERNAL_PATH)/package/xxx</code></p>
<p>OK, 差不多就是这些问题， 然后就编译出了nginx包了。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈dbus</title>
    <url>/2021/08/28/2021-20210828-dbus/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 最近项目上面要在两个进程间通信，传递一些设置的信息。而且之前项目调用系统的一些接口使用了dbus的通信机制，所以想着也使用dbus来做这个功能。</p>
<span id="more"></span>

<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p> D-Bus是一个低开销，易使用的IPC系统。 协议传递的是二进制数据， 而不是其他的文本格式(如JSON&#x2F;XML)， 协议是基于消息处理的， 而不是基于流。根据名字可以看出，这是一个总线型的通信机制，所有节点挂载总线上，节点发送消息到总线上，根据消息的头部信息定位目标节点，基于消息总线转发各个应用间的消息。</p>
<p>dbus在linux桌面会话间用的相当广泛，已经是一个成熟的系统了。</p>
<p>消息总线分为两种类型：</p>
<ul>
<li>system, 用于系统与用户会话的通知， 允许系统从用户会话中获取输入，系统中只允许存在一个系统总线</li>
<li>session, 用于实现 desktop environment， 例如： GNOME, KDE，系统中可以存在多个session总线</li>
</ul>
<p>D-Bus不是设计被用于任何应用间的交互， 缺少许多其他IPC方式的特性。 D-Bus daemon也提供了许多其他IPC没有的特性， 例如 Bus-name， 用于服务启动和安全策略。</p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>bus name: 每个应用连接到总线上，每个连接都通过一个bus name来标识。消息发送的时候，指定目标bus name， 总线就知道转发给哪个应用了。</p>
<p>对象： 每个应用可以提供多个对象，对象就是一组接口的抽象，提供给其他应用定位接口的。</p>
<p>路径： 每个对象对应的有一个路径，用于定位对象的。消息发送的时候，也会指定路径，表示要调用应用的哪个对象下的哪个接口。</p>
<p>接口： 接口就是具体调用的方法了。接口包含在对象中， 不同的对象可以提供同名的方法，但是实现可以不同，包括类型啊， 参数、返回值等都可以不一样，其实就是不同的接口。  接口有两种类型， 分别为方法和信号。 方法是提供给应用精确调用的，方法属于单播的消息，传递参数，返回执行结果。信号的发送是一个广播的消息，应用要处理什么信号，可以增加一个过滤器，告诉总线我想接收什么信号，信号不需要返回值，只需要处理就行了。</p>
<p>地址：系统上面可以运行多个总线，只有挂载到同一个总线上面的应用才可以相互通信。总线通过地址来区分，应用建立连接的时候需要指定总线的地址，这个总线的地址是存在环境变量<code>DBUS_SESSION_BUS_ADDRESS</code>和<code>DBUS_SYSTEM_BUS_ADDRESS</code>中的。系统默认会起一个system类型的总线，如果是界面登陆的终端，默认有一个session类型的总线，但如果是ssh或者Telnet连接的终端，就没有session总线了。 总线是通过一个后台daemon运行的。</p>
<p>inspect： 对象接口的xml声明，用于告知客户端dbus-name对应的应用提供了什么样的对象，路径是什么，接口是什么，还有就是接口的入参、出参的类型。只有实现了返回inspect的接口，才可以通过d-feet查看到具体的信息。</p>
<p>类型系统： dbus有一个类型系统，表示了ASCII码到具体数据类型的映射。用于对数据封包解包。</p>
<h1 id="交互模型"><a href="#交互模型" class="headerlink" title="交互模型"></a>交互模型</h1><p>这是个网络上的图片，详细的描述了dbus的通信流程。</p>
<p><img src="/images/202108/dbus_conn.png" alt="avatar"></p>
<h1 id="server代码流程"><a href="#server代码流程" class="headerlink" title="server代码流程"></a>server代码流程</h1><p><img src="/images/202108/dbus_server.png" alt="avatar"></p>
<h1 id="client代码流程"><a href="#client代码流程" class="headerlink" title="client代码流程"></a>client代码流程</h1><p><img src="/images/202108/dbus_client.png" alt="avatar"></p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>dbus自身提供了dbus-monitor, dbus-send等程序用于调试。</p>
<p>Ubuntu里面还可以安装d-feet程序，对dbus用一个可视化的了解。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>这些是我在学习的过程中，看到的比较好的一些资料， 讲的比较详细。</p>
<p><a href="https://dbus.freedesktop.org/doc/dbus-specification.html">官方文档</a></p>
<p>博客<br><a href="http://www.fmddlmyy.cn/mytext.html">http://www.fmddlmyy.cn/mytext.html</a>    全局了解<br><a href="https://www.cnblogs.com/chenbin7/archive/2013/03/05/2944895.html">https://www.cnblogs.com/chenbin7/archive/2013/03/05/2944895.html</a>  api使用</p>
<p>dbus-next文档	<br><a href="https://python-dbus-next.readthedocs.io/en/latest/high-level-service/index.html">https://python-dbus-next.readthedocs.io/en/latest/high-level-service/index.html</a> 这个是python的库，属于dbus的高度封装库，使用比较简便。</p>
<h1 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h1><p><a href="https://github.com/fishmwei/dbus-demo">https://github.com/fishmwei/dbus-demo</a></p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>管道的神操作(事件通知)-sysrepo笔记(1)</title>
    <url>/2021/09/02/2021-20210902-pipeipc/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于项目需要，安排了一个月左右的时间研究一下开源代码<code>sysrepo</code>这个共享内存型的数据库，后面得根据需要实现一些定制的需求,还有性能提升，数据是<code>yang</code>模型的数据。整体代码量大概3w行，每天刷个三四千行，每天日子过得很快很快，安排熟悉代码的时间也就七天，很是紧凑，消耗的还是有点儿慢。收获也颇多吧，从中也看到了许多<code>linux</code>接口的使用，后面陆续分享上来。</p>
<span id="more"></span>

<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>今天讲的是管道的应用吧，在sysrepo中基本上对每个模块的路径事件的订阅都会创建一个<code>subscription_ctx</code>这么个结构，每个结构都会有一个管道关联起来。事件的内容写在一个内存映射的文件中，然后再通过管道写一个字节的消息。 这边，每个管道都会有一个线程进行读操作，当读到消息后，就去对应的内存映射文件中读取内容，然后再处理事件。处理完事件之后，把结果写回到内存映射文件的后面。</p>
<p>这里，使用管道实现了事件通知的作用。而不像平常使用的那样，用来直接传递的数据内容。在这里，每个管道都有唯一的一个管道id来标识它，管道的文件也是和这个管道id相关联的。管道文件存放在<code>/etc/sysrepo/</code>目录下，带有evpipe和数字的就是了。</p>
<p>这里，对管道的读有设置了一个超时时间，超时了就继续下一次读。然后，涉及一些管道读写方面的知识。</p>
<h2 id="读管道："><a href="#读管道：" class="headerlink" title="读管道："></a>读管道：</h2><ul>
<li><ol>
<li>管道中有数据，read返回实际读到的字节数。</li>
</ol>
</li>
<li><ol start="2">
<li>管道中无数据：<br>(1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)<br>(2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</li>
</ol>
</li>
</ul>
<h2 id="写管道："><a href="#写管道：" class="headerlink" title="写管道："></a>写管道：</h2><ul>
<li><ol>
<li>管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</li>
</ol>
</li>
<li><ol start="2">
<li>管道读端没有全部关闭：<br>(1) 管道已满，write阻塞。<br>(2) 管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ol>
</li>
</ul>
<p>这边对管道的写，每次都是重写打开写端，然后写一个字节， 通知完了就关闭。读端通过select监听读的fd，当有数据了就读了， 然后到对应的位置去取数据。不像正常的那样父子进程各自维护读写端。这边管道不是作为进程间通信来用的，而是线程间的事件传递。</p>
<p>示例代码  </p>
<p><a href="https://github.com/fishmwei/blog_code/tree/master/sysrepo">https://github.com/fishmwei/blog_code/tree/master/sysrepo</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;asprintf.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getPipePath</span><span class="params">(<span class="type">int</span> number, <span class="type">char</span> **path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (asprintf(path, <span class="string">&quot;/sr_evpipe%d&quot;</span>, number) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;get path %s\r\n&quot;, *path);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_notify</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *path = <span class="literal">NULL</span>, buf[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> fd  = <span class="number">-1</span>, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getPipePath(number, &amp;path) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error get pipe path&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_WRONLY|O_NONBLOCK)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret = write(fd, buf, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!ret);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write a notify\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret = read(fd, buf, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret == <span class="number">-1</span>) &amp;&amp; (errno != EAGAIN)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read ok , do something!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pipe_listen_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="type">time_t</span> stop_time_in = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// pipe read</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> read = *(<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        tv.tv_sec = <span class="number">10</span>;</span><br><span class="line">        tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">        FD_ZERO(&amp;rfds);</span><br><span class="line">        FD_SET(read, &amp;rfds);</span><br><span class="line">        <span class="type">int</span> ret = select(read + <span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">        <span class="keyword">if</span> ((ret == <span class="number">-1</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!ret || ((ret == <span class="number">-1</span>)&amp;&amp;(errno == EINTR)))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;time out&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do read </span></span><br><span class="line">        do_read(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *path = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getPipePath(number, &amp;path) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unlink(path);</span><br><span class="line">    <span class="type">mode_t</span> um = umask(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ret = mkfifo(path, <span class="number">00622</span>);</span><br><span class="line">    umask(um);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mkfifo error&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> readFd = open(path, O_RDWR | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (readFd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">if</span> (ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, pipe_listen_thread, &amp;readFd))</span><br><span class="line">    &#123;</span><br><span class="line">        close(readFd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        write_notify(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    close(readFd);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/202108/sysrepo-1.jpg" alt="avatar"></p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sysrepo</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-sysrepo笔记(3)</title>
    <url>/2021/09/12/2021-20210912-nodetree/</url>
    <content><![CDATA[<h1 id="模块和数据节点的树结构"><a href="#模块和数据节点的树结构" class="headerlink" title="模块和数据节点的树结构"></a>模块和数据节点的树结构</h1><p><code>sysrepo</code>对<code>yang</code>文件节点数据及模块的解析是一个有层次的关系结构：</p>
<span id="more"></span>

<p><img src="/images/202109/node_tree.jpeg" alt="avatar"></p>
<ul>
<li>顶级节点没有parent&#x3D;NULL， 兄弟节点的parent是相同的。 </li>
<li>兄弟节点间是一个特殊的双向链表。第一个节点的<code>prev</code>指向最后一个节点，<code>next</code>指向下一个节点。如图所示，最后一个兄弟节点的<code>next</code>为<code>NULL</code>。如果只有一个节点，那么<code>prev</code>指向自身， next&#x3D;NULL</li>
<li>父节点的<code>child</code>指向第一个子节点。</li>
<li>每个节点有对应的节点类型，根据节点类型有对应的<code>value</code>。</li>
</ul>
<h1 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h1><p>所有安装的模块由一个名为<code>sysrepo</code>的模块管理。这个模块的定义在<code>https://github.com/sysrepo/sysrepo/blob/master/modules/sysrepo.yang</code>文件中。</p>
<p><img src="/images/202109/sysrepo.png" alt="avatar"></p>
<p>里面会记录哪些模块已经安装了，哪些模块待安装。<code>module</code>列表表示已经安装过的模块，存放模块的名称、版本、特性列表。每个安装的模块的依赖和反向依赖的模块列表，还可以存放这个模块是否将被移动或者被更新， 使能的特性列表等。新安装的模块在<code>installed-module</code>里面， 等待<code>sysrepo</code>没有连接的时候进行安装，从<code>yang</code>文件中解析出各种属性，添加为<code>module</code>列表的一个项。 已安装的<code>yang</code>文件默认会被存放到<code>/etc/sysrepo/yang</code>目录下，这个目录可以在编译的之前在CMakeList.txt文件中设置。</p>
<h1 id="数据内容存储"><a href="#数据内容存储" class="headerlink" title="数据内容存储"></a>数据内容存储</h1><p>所有相关的数据结构被存放在两个共享内存文件中， 分别是 <code>sr_main</code>和 <code>sr_ext</code>。</p>
<h2 id="sr-main"><a href="#sr-main" class="headerlink" title="sr_main"></a>sr_main</h2><p><code>sr_main</code>文件里面前面是<code>sr_main_shm_t</code>， 后面保存的是所有模块的信息<code>sr_mod_t</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> shm_ver;           <span class="comment">/**&lt; Main and ext SHM version of all expected data stored in them. Is increased with</span></span><br><span class="line"><span class="comment">                                     every change of their structure content (ABI change). */</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> lydmods_lock; <span class="comment">/**&lt; Process-shared lock for accessing sysrepo module data. */</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> ext_lock;   <span class="comment">/**&lt; Process-shared lock for accessing holes and truncating ext SHM. */</span></span><br><span class="line">    <span class="type">uint32_t</span> mod_count;         <span class="comment">/**&lt; Number of installed modules stored after this structure. */</span></span><br><span class="line"></span><br><span class="line">    ATOMIC_T new_sr_cid;        <span class="comment">/**&lt; Connection ID for a new connection. */</span></span><br><span class="line">    ATOMIC_T new_sr_sid;        <span class="comment">/**&lt; SID for a new session. */</span></span><br><span class="line">    ATOMIC_T new_sub_id;        <span class="comment">/**&lt; Subscription ID of a new subscription. */</span></span><br><span class="line">    ATOMIC_T new_evpipe_num;    <span class="comment">/**&lt; Event pipe number for a new subscription. */</span></span><br><span class="line">&#125; <span class="type">sr_main_shm_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sr_mod_lock_s</span> &#123;</span></span><br><span class="line">        <span class="type">sr_rwlock_t</span> lock;       <span class="comment">/**&lt; Process-shared lock for accessing module instance data and DS lock information. */</span></span><br><span class="line">        <span class="type">uint32_t</span> ds_lock_sid;   <span class="comment">/**&lt; SID of the module data datastore lock (NETCONF lock), the data can be modified only</span></span><br><span class="line"><span class="comment">                                     by this session. If 0, the DS lock is not held. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ds_lock_ts</span>;</span> <span class="comment">/**&lt; Timestamp of the datastore lock. */</span></span><br><span class="line">    &#125; data_lock_info[SR_DS_COUNT]; <span class="comment">/**&lt; Module data lock information for each datastore. */</span></span><br><span class="line">    <span class="type">sr_rwlock_t</span> replay_lock;    <span class="comment">/**&lt; Process-shared lock for accessing stored notifications for replay. */</span></span><br><span class="line">    <span class="type">uint32_t</span> ver;               <span class="comment">/**&lt; Module data version (non-zero). */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> name;                 <span class="comment">/**&lt; Module name (offset in main SHM). */</span></span><br><span class="line">    <span class="type">char</span> rev[<span class="number">11</span>];               <span class="comment">/**&lt; Module revision. */</span></span><br><span class="line">    ATOMIC_T replay_supp;       <span class="comment">/**&lt; Whether module supports replay. */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> features;             <span class="comment">/**&lt; Array of enabled features (off_t *) (offset in main SHM). */</span></span><br><span class="line">    <span class="type">uint16_t</span> feat_count;        <span class="comment">/**&lt; Number of enabled features. */</span></span><br><span class="line">    <span class="type">off_t</span> rpcs;                 <span class="comment">/**&lt; Array of RPCs/actions of the module (offset in main SHM). */</span></span><br><span class="line">    <span class="type">uint16_t</span> rpc_count;         <span class="comment">/**&lt; Number of RPCs/actions. */</span></span><br><span class="line">    <span class="type">off_t</span> notifs;               <span class="comment">/**&lt; Array of notifications of the module (offset in main SHM). */</span></span><br><span class="line">    <span class="type">uint16_t</span> notif_count;       <span class="comment">/**&lt; Number of notifications. */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> deps;                 <span class="comment">/**&lt; Array of module data dependencies (offset in main SHM). */</span></span><br><span class="line">    <span class="type">uint16_t</span> dep_count;         <span class="comment">/**&lt; Number of module data dependencies. */</span></span><br><span class="line">    <span class="type">off_t</span> inv_deps;             <span class="comment">/**&lt; Array of inverse module data dependencies (off_t *) (offset in main SHM). */</span></span><br><span class="line">    <span class="type">uint16_t</span> inv_dep_count;     <span class="comment">/**&lt; Number of inverse module data dependencies. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">sr_rwlock_t</span> lock;       <span class="comment">/**&lt; Process-shared lock for reading or preventing changes (READ) or modifying (WRITE)</span></span><br><span class="line"><span class="comment">                                     change subscriptions. */</span></span><br><span class="line">        <span class="type">off_t</span> subs;             <span class="comment">/**&lt; Array of change subscriptions (offset in ext SHM). */</span></span><br><span class="line">        <span class="type">uint32_t</span> sub_count;     <span class="comment">/**&lt; Number of change subscriptions. */</span></span><br><span class="line">    &#125; change_sub[SR_DS_COUNT];  <span class="comment">/**&lt; Change subscriptions for each datastore. */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">sr_rwlock_t</span> oper_lock;      <span class="comment">/**&lt; Process-shared lock for reading or preventing changes (READ) or modifying (WRITE)</span></span><br><span class="line"><span class="comment">                                     operational subscriptions. */</span></span><br><span class="line">    <span class="type">off_t</span> oper_subs;            <span class="comment">/**&lt; Array of operational subscriptions (offset in ext SHM). */</span></span><br><span class="line">    <span class="type">uint32_t</span> oper_sub_count;    <span class="comment">/**&lt; Number of operational subscriptions. */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">sr_rwlock_t</span> notif_lock;     <span class="comment">/**&lt; Process-shared lock for reading or preventing changes (READ) or modifying (WRITE)</span></span><br><span class="line"><span class="comment">                                     notification subscriptions. */</span></span><br><span class="line">    <span class="type">off_t</span> notif_subs;           <span class="comment">/**&lt; Array of notification subscriptions (offset in ext SHM). */</span></span><br><span class="line">    <span class="type">uint32_t</span> notif_sub_count;   <span class="comment">/**&lt; Number of notification subscriptions. */</span></span><br><span class="line">&#125; <span class="type">sr_mod_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>sr_mod_t</code>里面保存的都是各个数据在<code>sr_ext</code>里面对应的偏移， 具体的数据存在<code>sr_ext</code>里面。</p>
<h2 id="sr-ext"><a href="#sr-ext" class="headerlink" title="sr_ext"></a>sr_ext</h2><p><code>sr_ext</code>的头部是<code>sr_ext_shm_t</code>， 后面存的是一个个结构<code>sr_ext_hole_t</code>， 指向了各个模块的内存偏移。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Ext SHM structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> first_hole_off;    <span class="comment">/**&lt; Offset of the first memory hole, 0 if there is none. */</span></span><br><span class="line">&#125; <span class="type">sr_ext_shm_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Ext SHM memory hole.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">uint32_t</span> next_hole_off;</span><br><span class="line">&#125; <span class="type">sr_ext_hole_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>还有具体的数据也是存放在共享内存文件中， 不同模块的数据存放在不同的文件中， sr_modulename.datatype。</p>
<p>订阅的信息存放在sr_sub_xxxx等文件里。</p>
<p>后面再详细描述。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>动态库实现插件-sysrepo笔记(4)</title>
    <url>/2021/09/21/2021-20210921-plugin/</url>
    <content><![CDATA[<p>插件顾名思义就是通过宿主程序提供的机制，影响宿主程序而实现特定功能的一种程序。</p>
<p><code>sysrepo</code>数据库的一个重要的功能是在数据变更的时候，通过共享内存文件保存变更的内容，然后通过变更内容的模块找到相关路径订阅的管道id，通过往管道文件中写入随机数据通知订阅处理线程取数据，然后进行对应的操作处理。 </p>
<span id="more"></span>

<p>每个对数据变化感兴趣的处理流程都可以通过<code>sysrpo</code>提供的接口注册处理函数，每个处理流程对于<code>sysrepo</code>数据更新进程而言，都是客户端，可以通过一个独立的进程<code>sysrepo-plugind</code>来管理，每个处理流程可以做成一个个插件。根据订阅的参数，<code>sysrepo</code>会发送不同的事件，处理流程根据事件的类型，进行不同的处理。</p>
<p>根据处理的结果，<code>sysrepo</code>可以按序确认是否需要新增额外的修改<br>， 确认修改是否合法，不合法则结束更新；合法则写入数据库，最后通告最终的配置变更，客户端接收到最终变更后做具体的动作。</p>
<p>插件的实现很简单，只要实现两个接口sr_plugin_init_cb() 和sr_plugin_cleanup_cb() 。在sr_plugin_init_cb实现对某个模块的路径、关心的数据变化事件进行注册回调函数， 在sr_plugin_cleanup_cb对回调函数解除注册。每个代码都编译成动态库so，放到指定的路径下。<code>sysrepo-plugind</code>程序启动的时候会从该路径下读取所有的so文件，并依次执行sr_plugin_init_cb函数进行注册。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/executables/sysrepo-plugind.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">load_plugins</span><span class="params">(<span class="keyword">struct</span> srpd_plugin_s **plugins, <span class="type">int</span> *plugin_count)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((ent = readdir(dir))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(ent-&gt;d_name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(ent-&gt;d_name, <span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* open the plugin */</span></span><br><span class="line">        <span class="keyword">if</span> (asprintf(&amp;path, <span class="string">&quot;%s/%s&quot;</span>, plugins_dir, ent-&gt;d_name) == <span class="number">-1</span>) &#123;</span><br><span class="line">            error_print(<span class="number">0</span>, <span class="string">&quot;asprintf() failed (%s).&quot;</span>, strerror(errno));</span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        handle = dlopen(path, RTLD_LAZY);</span><br><span class="line">        <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">            error_print(<span class="number">0</span>, <span class="string">&quot;Opening plugin \&quot;%s\&quot; failed (%s).&quot;</span>, path, dlerror());</span><br><span class="line">            <span class="built_in">free</span>(path);</span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* allocate new plugin */</span></span><br><span class="line">        mem = <span class="built_in">realloc</span>(*plugins, (*plugin_count + <span class="number">1</span>) * <span class="keyword">sizeof</span> **plugins);</span><br><span class="line">        <span class="keyword">if</span> (!mem) &#123;</span><br><span class="line">            error_print(<span class="number">0</span>, <span class="string">&quot;realloc() failed (%s).&quot;</span>, strerror(errno));</span><br><span class="line">            dlclose(handle);</span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *plugins = mem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* find required functions */</span></span><br><span class="line">        *(<span class="type">void</span> **)&amp;(*plugins)[*plugin_count].init_cb = dlsym(handle, SRP_INIT_CB);</span><br><span class="line">        <span class="keyword">if</span> (!(*plugins)[*plugin_count].init_cb) &#123;</span><br><span class="line">            error_print(<span class="number">0</span>, <span class="string">&quot;Failed to find function \&quot;%s\&quot; in plugin \&quot;%s\&quot;.&quot;</span>, SRP_INIT_CB, ent-&gt;d_name);</span><br><span class="line">            dlclose(handle);</span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *(<span class="type">void</span> **)&amp;(*plugins)[*plugin_count].cleanup_cb = dlsym(handle, SRP_CLEANUP_CB);</span><br><span class="line">        <span class="keyword">if</span> (!(*plugins)[*plugin_count].cleanup_cb) &#123;</span><br><span class="line">            error_print(<span class="number">0</span>, <span class="string">&quot;Failed to find function \&quot;%s\&quot; in plugin \&quot;%s\&quot;.&quot;</span>, SRP_CLEANUP_CB, ent-&gt;d_name);</span><br><span class="line">            dlclose(handle);</span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* finally store the plugin */</span></span><br><span class="line">        (*plugins)[*plugin_count].handle = handle;</span><br><span class="line">        (*plugins)[*plugin_count].private_data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        name_len = length_without_extension(ent-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span> (name_len == <span class="number">0</span>) &#123;</span><br><span class="line">            error_print(<span class="number">0</span>, <span class="string">&quot;Wrong filename \&quot;%s\&quot;.&quot;</span>, ent-&gt;d_name);</span><br><span class="line">            dlclose(handle);</span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (*plugins)[*plugin_count].plugin_name = strndup(ent-&gt;d_name, name_len);</span><br><span class="line">        <span class="keyword">if</span> (!((*plugins)[*plugin_count].plugin_name)) &#123;</span><br><span class="line">            error_print(<span class="number">0</span>, <span class="string">&quot;strndup() failed.&quot;</span>);</span><br><span class="line">            dlclose(handle);</span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++(*plugin_count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">/* init plugins */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; plugin_count; ++i) &#123;</span><br><span class="line">        r = plugins[i].init_cb(sess, &amp;plugins[i].private_data);</span><br><span class="line">        <span class="keyword">if</span> (r != SR_ERR_OK) &#123;</span><br><span class="line">            SRP_LOG_ERR(<span class="string">&quot;Plugin initialization failed (%s).&quot;</span>, sr_strerror(r));</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait for a terminating signal */</span></span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    <span class="keyword">while</span> (!loop_finish) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cleanup plugins */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; plugin_count; ++i) &#123;</span><br><span class="line">        plugins[i].cleanup_cb(sess, plugins[i].private_data);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从代码里可以看到具体的流程:</p>
<ul>
<li>读取指定目录下的so， 获取init和clean函数入口地址， 插件名等信息</li>
<li>依次执行init函数</li>
<li>等待结束信号， 调用clean函数清理注册函数</li>
</ul>
<p>在<code>sysrepo</code>的官方文档里面也有一个插件的示例，感兴趣可以去看看。 </p>
<p><a href="https://netopeer.liberouter.org/doc/sysrepo/master/html/example.html#oven_plugin">https://netopeer.liberouter.org/doc/sysrepo/master/html/example.html#oven_plugin</a></p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>近期使用的skills</title>
    <url>/2021/09/23/2021-20210923-skills/</url>
    <content><![CDATA[<p>最近编码get或者温故了一些skill，小结记录一下。</p>
<h1 id="core-dump"><a href="#core-dump" class="headerlink" title="core dump"></a>core dump</h1><p>Ubuntu系统产生core文件方法<br>ulimit -c unlimited<br>sysctl -w kernel.core_pattern&#x3D;&#x2F;tmp&#x2F;core-%e.%p</p>
<span id="more"></span>

<p>生成的core文件在&#x2F;tmp目录下，格式为core-程序名称.进程pid</p>
<p>ulimit设置后，仅对当前终端会话有效。</p>
<h1 id="gdb字符串打印不全"><a href="#gdb字符串打印不全" class="headerlink" title="gdb字符串打印不全"></a>gdb字符串打印不全</h1><p>有时候一个字符串比较长，调试时使用<code>p str_val</code>，仅展示一部分， 后面的会以省略号代替， 可以在gdb里面敲命令<br><code>set print element 0</code>， 然后再<code>p str_val</code>则可以显示完整的字符串。</p>
<h1 id="chroot以其他账户执行命令"><a href="#chroot以其他账户执行命令" class="headerlink" title="chroot以其他账户执行命令"></a>chroot以其他账户执行命令</h1><p>最近测试提了一个问题，程序在使用其他账户执行的时候会崩溃， 通过<code>chroot</code>命令可以用其他账户的权限执行命令。</p>
<p><code>chroot --userspec=other_username &quot;/&quot; sh -c &quot;my-program&quot;</code>, 可以快速重现问题， 不需要切换用户。</p>
<h1 id="shell如何延迟reboot"><a href="#shell如何延迟reboot" class="headerlink" title="shell如何延迟reboot"></a>shell如何延迟reboot</h1><p>在实现项目功能的时候， 需要在处理完后预留一段时间在重启设备。linux默认提供的reboot或者shutdown命令不支持延迟功能。 之前学习了dbus， 刚好项目python代码中有相关的命令实现。 OK， 那么我们就可以使用dbus-send命令，模拟python的dbus调用，实现延迟重启设备的功能。 具体的命令如下：</p>
<p><code>dbus-send --system  --type=method_call  --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.ScheduleShutdown string:&quot;reboot&quot; uint64:1632282493000000</code></p>
<p>uint64后面接的是执行命令的时间轴，单位为微妙，可以通过<code>date +%s</code>获取到当前的时间轴， 再加上延迟的秒数，然后乘以 1000*1000。</p>
<h1 id="buildroot编译debug程序"><a href="#buildroot编译debug程序" class="headerlink" title="buildroot编译debug程序"></a>buildroot编译debug程序</h1><p>一般c语言的库现在多使用cmake了， 可以添加一个选项 -DCMAKE_BUILD_TYP&#x3D;Debug，然后<code>make pkg-dirclean &amp;&amp; make pkg-rebuild</code>重新编译出来的程序就是带有符号的debug版本程序了， 可以方便地进行gdb调试。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>最近是比较忙的， 一边在学习sysrepo这个开源库，考虑如何解决这个库的性能问题。 另一边还要支撑处理项目的其他问题，还要一些的设计文档编写。之前的学习都暂时中断了， 工作优先。</p>
<p>今天公司领导发了一个后期知识分享的规划， 后期要引入极客时间专栏的学习分享，嗯， 当然学习了需要在部门内做分享。这样学习就变成了任务，习惯自学的我，总感觉怪怪的。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>返回值截断-不要忽略编译器的警告</title>
    <url>/2021/10/03/2021-20211003-truncret-md/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>国庆前一天，我在调试代码时产生了一个崩溃。 通过gdb定位，发现一个函数的返回值被截断了，函数的返回值是一个地址，在调用函数的地方只剩下低4个字节的值了。</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret is <span class="number">0x7fef44402a70</span></span><br><span class="line">get ret is <span class="number">0x44402a70</span></span><br></pre></td></tr></table></figure>

<p>然后访问返回的地址导致了程序崩溃。奇怪的是，我之前用自己的demo验证过了的，而且可以正常运行。</p>
<h1 id="究根结底"><a href="#究根结底" class="headerlink" title="究根结底"></a>究根结底</h1><p>上网查了一下，找到了一个类似的问题：</p>
<blockquote>
<p>在C工程中，一个64位系统中如果一个文件中的某个函数A调用另外一个文件中的函数B，但是A文件中没有包含B的声明，gcc可以编译通过，但是如果B函数的返回类型为指针，在64位系统应该返回64bit地址，实际上函数A调用B得到的B的返回指针却是32bit，高32bit被截断。</p>
</blockquote>
<p>主要就是gcc编译器对本函数调用未声明的函数，都强制将其返回值类型转为int类型，int在64bit系统中占4个字节，这样指针类型的返回值就会出现截断现象！</p>
<p>我写了一个简单的demo复现了这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// getData.c</span><br><span class="line"></span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">struct data *getData()</span><br><span class="line">&#123;</span><br><span class="line">    struct data *ret = (struct data *)malloc(sizeof(struct data));</span><br><span class="line">    printf(&quot;ret is %p\r\n&quot;, ret);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// truncret.c</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">void showData(struct data *pdata) &#123;</span><br><span class="line">    printf(&quot;data is a = %d, b = %d \r\n&quot;, pdata-&gt;a, pdata-&gt;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct data *ret = getData();</span><br><span class="line">    printf(&quot;get ret is %p\r\n&quot;, ret);</span><br><span class="line">    ret-&gt;a = 100;</span><br><span class="line">    ret-&gt;b = 200;</span><br><span class="line">    showData(ret);</span><br><span class="line"></span><br><span class="line">    free(ret);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接把两个文件一起编译生成目标文件，可以看到有警告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc truncret.c getData.c -o a</span><br><span class="line">truncret.c:11:24: warning: implicit declaration of function &#x27;getData&#x27; is invalid in C99</span><br><span class="line">      [-Wimplicit-function-declaration]</span><br><span class="line">    struct data *ret = getData();</span><br><span class="line">                       ^</span><br><span class="line">truncret.c:11:18: warning: incompatible integer to pointer conversion initializing &#x27;struct data *&#x27; with an</span><br><span class="line">      expression of type &#x27;int&#x27; [-Wint-conversion]</span><br><span class="line">    struct data *ret = getData();</span><br><span class="line">                       ^</span><br><span class="line">2 warnings generated.</span><br></pre></td></tr></table></figure>

<p>成功生成了目标文件，但是执行时段错误了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Keep:sysrepo keep$ ./a</span><br><span class="line">ret is 0x7faf01402a70</span><br><span class="line">get ret is 0x1402a70</span><br><span class="line">Segmentation fault: 11</span><br></pre></td></tr></table></figure>

<p>这种情况， 我们只需要在调用之前声明一下函数原型就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// truncret.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showData</span><span class="params">(<span class="keyword">struct</span> data *pdata)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data is a = %d, b = %d \r\n&quot;</span>, pdata-&gt;a, pdata-&gt;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> data *<span class="title function_">getData</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span> *<span class="title">ret</span> =</span> (<span class="keyword">struct</span> data *)getData();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get ret is %p\r\n&quot;</span>, ret);</span><br><span class="line">    ret-&gt;a = <span class="number">100</span>;</span><br><span class="line">    ret-&gt;b = <span class="number">200</span>;</span><br><span class="line">    showData(ret);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ret);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>再次编译没有报错， 执行正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Keep:sysrepo keep$ gcc truncret.c getData.c -o a</span><br><span class="line">Keep:sysrepo keep$ ./a</span><br><span class="line">ret is 0x7f8560c02a70</span><br><span class="line">get ret is 0x7f8560c02a70</span><br><span class="line">data is a = 100, b = 200 </span><br></pre></td></tr></table></figure>

<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>在编译的过程中，不要忽略任何细微的警告。实际在很多项目中，为了使编译的结果更稳定可靠，编译的时候就是要求做到告警清零的。gcc使用选项<code>-Werror</code>，只要有任一一个警告，编译都会报错。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Keep:sysrepo keep$ gcc truncret.c getData.c -o a -Werror</span><br><span class="line">truncret.c:11:24: error: implicit declaration of function &#x27;getData&#x27; is invalid in C99</span><br><span class="line">      [-Werror,-Wimplicit-function-declaration]</span><br><span class="line">    struct data *ret = getData();</span><br><span class="line">                       ^</span><br><span class="line">truncret.c:11:18: error: incompatible integer to pointer conversion initializing &#x27;struct data *&#x27; with an expression</span><br><span class="line">      of type &#x27;int&#x27; [-Werror,-Wint-conversion]</span><br><span class="line">    struct data *ret = getData();</span><br><span class="line">                 ^     ~~~~~~~~~</span><br><span class="line">2 errors generated.</span><br></pre></td></tr></table></figure>

<p>这里很奇怪的是，为什么我的demon没有出问题呢。 通过实际跟踪，主要是由于返回值和截断的值是一致的，导致在demo调试的过程中，问题没有被发现，在最后集成的时候才爆出问题。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>很快，今天就3号了，祝大家国庆节快乐! </p>
<p>国庆这几天，由于福建还是有疫情的，尽量就不出去浪了。前面两天给自己放了一个小假，不考虑工作和技术。</p>
<p>主要就是看了一下电视剧《功勋》，电视还是拍的很不错了，让我们缅怀一下那些共和国的英雄们。</p>
<p>电视剧不单单告诉我们，和平美好的生活来之不易，还告诉我们一个道理<code>everything is possible</code>。</p>
<p>在遇到挫折和困难的时候，一定要坚持下去，才会有成功的可能，当然，成功不是简单的坚持就可以获得的，需要我们动脑，需要有坚实的基础。</p>
<p>虽然说，只要功夫深，铁杵磨成针。但是有好的方法和条件，成功的概率更大，时间才能更短。做事情不能简单的愚公移山，遇到大山的时候，如果你有好技术和方案，直接挖隧道或者搭桥绕过去，离成功才会更近。</p>
<p>工作也是一样的，平常多学习一些知识，拓宽知识面。在遇到问题的时候，可以更轻松的迎刃而解。</p>
<p>加油，在IT这个技术瞬息万变的行业里，只要加强学习，认真巩固总结，我相信没有什么所谓的35岁危机可以吓到我们的。工程师嘛，就得攻城略地才有价值，活到老学到老。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>文件锁-sysrepo笔记(5)</title>
    <url>/2021/10/05/2021-20211005-filelock/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><code>sysrepo</code>是基于共享内存的数据库，实际共享内存的外在体现是一个共享的文件。对这个共享文件的访问控制又是通过文件锁的方式来实现的。因为<code>sysrepo</code>只是一个库而已，会被多个进程链接，共享内存文件的路径都是一致的，在编译的时候确定了的。多进程间的资源互斥这里使用的就是文件锁的方式。</p>
<span id="more"></span>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><code>sysrepo</code>对数据的存储主要分为两块，一个是<code>main shm</code>，用来保存概要的数据<code>sr_main_shm_t</code>和模块的信息数组<code>sr_mod_t</code>(大部分保存模块对应信息的一个偏移)。另一个是<code>ext shm</code>，用来保存具体的模块对应的数据信息。</p>
<p>其中对<code>main shm</code>的资源资源控制使用的是一个<code>sr_main</code>的文件锁来保护。同样的，对<code>ext shm</code>的资源资源控制使用的是一个<code>sr_ext</code>的文件锁来保护。</p>
<p>今天主要介绍一下<code>main shm</code>的文件锁<code>sr_main</code>的控制。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>涉及的锁接口主要有三个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Create main SHM file lock used for creating main SHM.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[out] shm_lock SHM create lock file descriptor.</span></span><br><span class="line"><span class="comment"> * @return err_info, NULL on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">sr_error_info_t</span> *<span class="title function_">sr_shmmain_createlock_open</span><span class="params">(<span class="type">int</span> *shm_lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Lock main SHM file lock. Note that the oldest standard file locks</span></span><br><span class="line"><span class="comment"> * are used, which lock for the whole process (every thread).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] shm_lock Opened SHM create lock file descriptor.</span></span><br><span class="line"><span class="comment"> * @return err_info, NULL on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">sr_error_info_t</span> *<span class="title function_">sr_shmmain_createlock</span><span class="params">(<span class="type">int</span> shm_lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Unlock main SHM file lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] shm_lock Locked SHM create lock file descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sr_shmmain_createunlock</span><span class="params">(<span class="type">int</span> shm_lock)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里<code>shm_lock</code>实际上是锁文件的文件描述符fd。</p>
<h3 id="锁文件创建"><a href="#锁文件创建" class="headerlink" title="锁文件创建"></a>锁文件创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">sr_error_info_t</span> *</span><br><span class="line"><span class="title function_">sr_shmmain_createlock_open</span><span class="params">(<span class="type">int</span> *shm_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sr_error_info_t</span> *err_info = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *path;</span><br><span class="line">    <span class="type">mode_t</span> um;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (asprintf(&amp;path, <span class="string">&quot;%s/%s&quot;</span>, sr_get_repo_path(), SR_MAIN_SHM_LOCK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        SR_ERRINFO_MEM(&amp;err_info);</span><br><span class="line">        <span class="keyword">return</span> err_info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set umask so that the correct permissions are really set */</span></span><br><span class="line">    um = umask(SR_UMASK);</span><br><span class="line"></span><br><span class="line">    *shm_lock = open(path, O_RDWR | O_CREAT, SR_MAIN_SHM_PERM);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line">    umask(um);</span><br><span class="line">    <span class="keyword">if</span> (*shm_lock == <span class="number">-1</span>) &#123;</span><br><span class="line">        SR_ERRINFO_SYSERRNO(&amp;err_info, <span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err_info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里获取到文件的路径，设置创建文件属性的掩码，然后使用<code>open</code>打开文件，如果文件不存在，创建文件并使用指定的访问属性。</p>
<h3 id="加锁操作"><a href="#加锁操作" class="headerlink" title="加锁操作"></a>加锁操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">sr_error_info_t</span> *</span><br><span class="line"><span class="title function_">sr_shmmain_createlock</span><span class="params">(<span class="type">int</span> shm_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">fl</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">sr_error_info_t</span> *err_info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    assert(shm_lock &gt; <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;fl, <span class="number">0</span>, <span class="keyword">sizeof</span> fl);</span><br><span class="line">    fl.l_type = F_WRLCK;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret = fcntl(shm_lock, F_SETLKW, &amp;fl);</span><br><span class="line">    &#125; <span class="keyword">while</span> ((ret == <span class="number">-1</span>) &amp;&amp; (errno == EINTR));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        SR_ERRINFO_SYSERRNO(&amp;err_info, <span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err_info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对文件加解锁使用了一个结构体<code>struct flock</code>，定义一些文件的锁的选项。还有<code>fcntl</code>这个函数来设置定义的选项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> filedes, <span class="type">int</span> cmd, ... <span class="comment">/* struct flock *flockptr */</span> )</span>; </span><br></pre></td></tr></table></figure>

<p>这是一个拥有可变参数的函数声明，filedes自然是要操作的文件描述符，对与记录锁相关的操作，cmd只能是F_GETLK, F_SETLK, 或者 F_SETLKW，而第三个参数则必须是一个指向flock结构体的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> l_type;<span class="comment">/*F_RDLCK, F_WRLCK, or F_UNLCK */</span></span><br><span class="line">    <span class="type">off_t</span> l_start;<span class="comment">/*offset in bytes, relative to l_whence */</span></span><br><span class="line">    <span class="type">short</span> l_whence;<span class="comment">/*SEEK_SET, SEEK_CUR, or SEEK_END */</span></span><br><span class="line">    <span class="type">off_t</span> l_len;<span class="comment">/*length, in bytes; 0 means lock to EOF */</span></span><br><span class="line">    <span class="type">pid_t</span> l_pid;<span class="comment">/*returned with F_GETLK */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一个成员是加锁的类型：只读锁，读写锁，或是解锁。<code>l_start</code>和<code>l_whence</code>用来指明加锁部分的开始位置，<code>l_len</code>是加锁的长度，<code>l_pid</code>是加锁进程的进程id。比如说，我们现在需要把一个文件的前三个字节加读锁，则该结构体的<code>l_type=F_RDLCK</code>, <code>l_start=0</code>, <code>l_whence=SEEK_SET</code>, <code>l_len=3</code>,<code>l_pid</code>不需要指定，然后调用<code>fcntl</code>函数时，<code>cmd</code>参数使用<code>F_SETLK</code>.</p>
<p>回到<code>sr_shmmain_createlock</code>函数， 设置了读写锁类型<code>F_WRLCK</code>，<code>cmd</code>为<code>F_SETLKW</code>，然后就调用<code>fcntl</code>加锁了。</p>
<h3 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sr_shmmain_createunlock</span><span class="params">(<span class="type">int</span> shm_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">fl</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;fl, <span class="number">0</span>, <span class="keyword">sizeof</span> fl);</span><br><span class="line">    fl.l_type = F_UNLCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(shm_lock, F_SETLK, &amp;fl) == <span class="number">-1</span>) &#123;</span><br><span class="line">        assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里设置<code>cmd</code>为<code>F_SETLK</code>, <code>l_type</code>类型为解锁。</p>
<h2 id="demo编程"><a href="#demo编程" class="headerlink" title="demo编程"></a>demo编程</h2><p>我写了一个<code>demo</code>程序，2个程序分别往一个共享内存写数据，对一个数进行累加。一个步进1， 加10次。 一个步进2，加10次。当两个程序结束后，都延迟10s钟，分别再读取数据，最终的结果应该是我们认为的30。</p>
<img src="/images/202110/filelock.png" alt="文件锁"  align="bottom" />

<p><code>demo</code>代码路径： </p>
<p> <a href="https://github.com/fishmwei/blog_code/tree/master/sysrepo/filelock">https://github.com/fishmwei/blog_code/tree/master/sysrepo/filelock</a></p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>共享内存文件的应用-sysrepo笔记(2)</title>
    <url>/2021/09/12/2021-20210912-mmap/</url>
    <content><![CDATA[<p>上一篇讲了<code>sysrepo</code>使用管道做事件通知，至于处理数据则通过共享内存文件来保存。<code>sysrepo</code>号称是共享内存型的数据库，主要就是由于其数据都是通过共享内存文件保存的。</p>
<span id="more"></span>

<p>创建的共享内存文件，默认都是在<code>/dev/shm</code>目录下，正常情况下，系统会以<code>/dev/shm</code>目录为根路径组织文件的路径，然后创建。</p>
<p>具体的操作流程就是：</p>
<ol>
<li>打开文件<br>  使用shm_open打开一个文件</li>
<li>设置初始大小<br>  使用ftruncate设置文件的大小为要写的内容的大小</li>
<li>映射到内存<br>  调用mmap映射到内存中，获取地址</li>
<li>写数据<br>  强制转换地址类型，然后设置数据</li>
<li>追加数据<br>  把之前的地址 munmap掉。根据计算的大小重新mmap， 然后获取到新地址后，计算偏移 写入内容。</li>
<li>读数据<br>  根据地址，计算偏移后 使用指针强转类型，直接读取数据</li>
<li>清理共享内存<br>  使用munmap卸载映射的关系，close最初使用shm_open获得的fd</li>
</ol>
<p>在<code>sysrepo</code>中，封装了几个函数， open_map, remap, clean_map。根据使用的场景调用。</p>
<p>示例代码  </p>
<p><a href="https://github.com/fishmwei/blog_code/tree/master/sysrepo/map_test.c">https://github.com/fishmwei/blog_code/tree/master/sysrepo/map_test.c</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> request_id;</span><br><span class="line">    <span class="type">int</span> event;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pripority;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125; <span class="type">content_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> request_id;</span><br><span class="line">    <span class="type">int</span> event;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pripority;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">4</span>];</span><br><span class="line">&#125; <span class="type">excontent_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">void</span> *addr;</span><br><span class="line">&#125; <span class="type">shm_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_get_size</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> *size)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fstat error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *size = st.st_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_file_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> **path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = asprintf(path, <span class="string">&quot;/sub2_%s&quot;</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">remap</span><span class="params">(<span class="type">shm_t</span> *shm, <span class="type">size_t</span> new_shm_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> file_size;</span><br><span class="line">    <span class="keyword">if</span> (!new_shm_size &amp;&amp; (file_get_size(shm-&gt;fd, &amp;file_size)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size not changed.</span></span><br><span class="line">    <span class="keyword">if</span> ((!new_shm_size &amp;&amp; (new_shm_size == file_size)) || (new_shm_size &amp;&amp;new_shm_size == file_size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shm-&gt;addr) &#123;</span><br><span class="line">        munmap(shm-&gt;addr, shm-&gt;size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;munmap\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize file </span></span><br><span class="line">    <span class="keyword">if</span> (new_shm_size &amp;&amp; (ftruncate(shm-&gt;fd, new_shm_size) == <span class="number">-1</span>)) &#123;</span><br><span class="line">        shm-&gt;addr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ftruncate error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shm-&gt;size = new_shm_size ? new_shm_size : file_size;</span><br><span class="line"></span><br><span class="line">    shm-&gt;addr = mmap(<span class="literal">NULL</span>, shm-&gt;size, PROT_READ | PROT_WRITE, MAP_SHARED, shm-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm-&gt;addr == MAP_FAILED) &#123;</span><br><span class="line">        shm-&gt;addr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mmap error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get addr %p\r\n&quot;</span>, shm-&gt;addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_map</span><span class="params">(<span class="type">shm_t</span> *shm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (shm-&gt;addr)</span><br><span class="line">    &#123;</span><br><span class="line">        munmap(shm-&gt;addr, shm-&gt;size);</span><br><span class="line">        shm-&gt;addr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shm-&gt;fd &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        close(shm-&gt;fd);</span><br><span class="line">        shm-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    shm-&gt;size =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_map</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">shm_t</span> *shm, <span class="type">size_t</span> struct_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> created = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (get_file_path(name, &amp;path)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get_file_path error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">mode_t</span> um = umask(<span class="number">0</span>);</span><br><span class="line">    shm-&gt;fd = shm_open(path, O_RDWR | O_CREAT | O_EXCL, <span class="number">00666</span>);</span><br><span class="line">    umask(um);</span><br><span class="line">    <span class="keyword">if</span> ((shm-&gt;fd == <span class="number">-1</span>) &amp;&amp; (errno == EEXIST)) &#123;</span><br><span class="line">        created = <span class="number">0</span>;</span><br><span class="line">        shm-&gt;fd = shm_open(path, O_RDWR, <span class="number">00666</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file exist %s, open agine\r\n&quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line">    <span class="keyword">if</span> (shm-&gt;fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open map file error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (created) &#123;</span><br><span class="line">        <span class="comment">// remap struct_size</span></span><br><span class="line">        <span class="keyword">if</span> (remap(shm, struct_size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// remap size 0 </span></span><br><span class="line">        <span class="keyword">if</span> (remap(shm, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">shm_t</span> first, second;</span><br><span class="line">    <span class="type">size_t</span> struct_size = <span class="keyword">sizeof</span>(<span class="type">content_t</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;first, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">shm_t</span>));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;second, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">shm_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = open_map(<span class="string">&quot;hello&quot;</span>, &amp;first, struct_size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">content_t</span> *pData = first.addr;</span><br><span class="line">    pData-&gt;count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    ret = open_map(<span class="string">&quot;hello&quot;</span>, &amp;second, struct_size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        clear_map(&amp;first);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pData = second.addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count is %d\r\n&quot;</span>, pData-&gt;count);</span><br><span class="line"></span><br><span class="line">    ret = remap(&amp;second, <span class="keyword">sizeof</span>(<span class="type">excontent_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret) &#123;</span><br><span class="line">        <span class="type">excontent_t</span> *pex = second.addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ext count is %d\n&quot;</span>, pex-&gt;count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    clear_map(&amp;first);</span><br><span class="line">    clear_map(&amp;second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc map_test.c -o map -lrt</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">strace ./map </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">shm_open will create file in /dev/shm </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>性能优化-sysrepo笔记(6)</title>
    <url>/2021/10/15/2021-20211015-timing/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几个月前了吧，团队有人测试了一下通过netconf给list类型的节点添加2w条表项，发现随着表项数目的增加，后面创建新表项的时间几乎呈一个线性的增长。到最后，每增加一个配置，大概就要耗时8s左右的时间，很显然，这是一个比较严重的性能问题。另外，即使你修改其他模块的配置，这个耗时也要6s左右的时间。就是如果一个模块的配置量很大，还会影响到其他模块的处理，这个就更严重了。</p>
<span id="more"></span>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过分析，耗时长的函数主要就是sr_modinfo_data_load、lyd_validate_modules、sr_modinfo_data_store。 其实很容易就可以看出来，在配置量巨大的情况下，保存的配置的数据量就更多，这样就导致加载&#x2F;校验&#x2F;保存的时间更长了。</p>
<p>这样看来，sysrepo的框架已经决定了它不适合大量配置的情形，动不动就上千万的配置就更不可能了。通过后期对代码的深入，我总结了几点sysrepo性能问题的根因：</p>
<ul>
<li>内容是否更改是通过字符串比对来实现的(参考函数lyd_anydata_equal实现), 配置大的时候，生成的字符串很长，比对耗时</li>
<li>顶级模块相同的不同模块配置保存在同一个文件(顶级模块的文件), 很多下级模块其实是对一个顶级模块的argument，这些下级模块的配置并没有拆分到独立的文件，某一个模块数据量很大的时候，加载配置文件就很慢，还会影响其他的模块</li>
<li>每次修改保存都重新写入文件，我们知道IO是一个比较慢的操作，数据量越大那么时间就更长了</li>
<li>共享内存文件锁，只要有一个进程在读取大数据配置，锁就会占用，其他进程就挂在那儿了</li>
<li>yang数据是一棵树，每一级其实都是一个双向链表，我们知道双向链表的查找效率是O(n)，这个也导致在数据检索和修改的耗时长。</li>
</ul>
<p>总的来说，框架的总体设计已经决定了sysrepo的瓶颈。综合看上面几个原因，也就只能通过拆分各个模块的数据，优化模块间相互依赖的问题了。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>针对我们项目的配置都在一个顶级模块下面，那么我就从次级模块进行了拆分， 顶级模块文件只保留其自身模块的数据，而次级模块文件保留顶级模块的部分数据和自身模块的数据。这样，就是顶级模块会有多个备份，每个有数据的次级模块几乎都会存一份顶级模块的数据。只能这样了，通过空间换时间吧。 </p>
<p>对配置的操作，需要根据请求的配置，加载对应模块及其依赖模块的数据(用于校验)，然后进行数据变更，相互依赖的配置还是会有影响的。</p>
<p>另外在处理逻辑上，需要在删除&#x2F;替换顶级模块配置的时候，同时同步到所有次级模块，也就是需要加载其下的所有模块。为了正确性，这个是没有办法避免的。</p>
<p>嗯， sysrepo还提供了缓存的功能，在缓存的处理上和拆分下级模块是一样的，不同的是，之前缓存的是running数据库的整个数据森林，只有一份。 但之前数据文件会有多份，因为有多个顶级模块。这个也没有多复杂，就是缓存按模块来分，除了项目的顶级模块只存自身数据外，其他顶级模及其下级模块不进行拆分，平常不需要用到。</p>
<p>拆分的示意图，我简单手绘了一下：</p>
<img src="/images/202110/sysrepo_split.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>sysrepo的优化前后耗时快一个半月了，sysrepo库总体代码量大概3w行，前面三周几乎都是在熟悉代码，后面按思路进行编码拆分，中间遇到很多问题，前后得有30个上下吧。昨天才把基本的逻辑调试完，今天小结一下。 还得设计一下测试用例，后面两周按照用例过一下，然后再优化一下代码。后面估计还有许多坑，加油吧!</p>
<p>这段时间，天天都很忙，在不停的调试问题，逢山开路，遇水搭桥。 国庆假期都贡献了2天免费加班了，精神高度集中，脑袋超负荷运转，真是有点儿疲惫不堪。终于快到尾声了，飒!!</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>读写锁的源码解读-sysrepo笔记(7)</title>
    <url>/2021/10/17/2021-20211017-wrlock/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>sysrepo对资源的保护自己实现了一个读写锁， 支持多个线程同时读，只有一个线程在写的保护。使用的是互斥量加条件量来实现的。读写互斥使用一个变量控制。结构如下(基于1.4.87版本，新版本变了，原理差不多)：</p>
<span id="more"></span>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Lock mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">sr_lock_mode_e</span> &#123;</span></span><br><span class="line">    SR_LOCK_NONE = <span class="number">0</span>,           <span class="comment">/**&lt; Not locked. */</span></span><br><span class="line">    SR_LOCK_READ,               <span class="comment">/**&lt; Read lock. */</span></span><br><span class="line">    SR_LOCK_WRITE,              <span class="comment">/**&lt; Write lock. */</span></span><br><span class="line">&#125; <span class="type">sr_lock_mode_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Sysrepo read-write lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sr_rwlock_s</span> &#123;</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;          <span class="comment">/**&lt; Lock mutex. */</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;            <span class="comment">/**&lt; Lock condition variable. */</span></span><br><span class="line">    <span class="type">uint16_t</span> readers;               <span class="comment">/**&lt; Current read-locked users. */</span></span><br><span class="line">&#125; <span class="type">sr_rwlock_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>对这个锁的操作主要有如下接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Initialize a sysrepo RW lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in,out] rwlock RW lock to initialize.</span></span><br><span class="line"><span class="comment"> * @param[in] shared Whether the RW lock will be shared between processes or not.</span></span><br><span class="line"><span class="comment"> * @return err_info, NULL on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">sr_error_info_t</span> *<span class="title function_">sr_rwlock_init</span><span class="params">(<span class="type">sr_rwlock_t</span> *rwlock, <span class="type">int</span> shared)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Destroy a sysrepo RW lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] rwlock RW lock to destroy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sr_rwlock_destroy</span><span class="params">(<span class="type">sr_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Lock a sysrepo RW lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] rwlock RW lock to lock.</span></span><br><span class="line"><span class="comment"> * @param[in] timeout_ms Timeout in ms for locking.</span></span><br><span class="line"><span class="comment"> * @param[in] mode Whether to write-lock or read-lock.</span></span><br><span class="line"><span class="comment"> * @param[in] func Name of the calling function for logging.</span></span><br><span class="line"><span class="comment"> * @return err_info, NULL on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">sr_error_info_t</span> *<span class="title function_">sr_rwlock</span><span class="params">(<span class="type">sr_rwlock_t</span> *rwlock, <span class="type">int</span> timeout_ms, <span class="type">sr_lock_mode_t</span> mode, <span class="type">const</span> <span class="type">char</span> *func)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Unlock a sysrepo RW lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] rwlock RW lock to unlock.</span></span><br><span class="line"><span class="comment"> * @param[in] mode Whether to write-unlock or read-unlock.</span></span><br><span class="line"><span class="comment"> * @param[in] func Name of the calling function for logging.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sr_rwunlock</span><span class="params">(<span class="type">sr_rwlock_t</span> *rwlock, <span class="type">sr_lock_mode_t</span> mode, <span class="type">const</span> <span class="type">char</span> *func)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>通过一个互斥量和一个条件量，还有锁结构的读者数目实现控制读写交互。</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>如果是写加锁，首先通过获取互斥量，然后等待读者数为0或者条件量(等待过程中，超时会释放掉互斥量)，写加锁成功。 此时互斥量被写者占用。<br>在写加锁后，互斥量被占用。此时，再有其他写加锁或者读加锁，都获取不到互斥量，保证了写安全。</p>
<p>如果是读加锁，首先通过获取互斥量，然后增加读者数，释放互斥量，读加锁成功。此时互斥量空闲。<br>在读加锁后，互斥量空闲。如果有其他写加锁来，那么互斥量被占用，但读者数目非0，读加锁操作会阻塞等待读者数为0。<br>如果有其他读加锁来，那么互斥量先被占用，增加读者数，然后释放互斥量。读加锁成功，此时同时有多个读者。</p>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>如果是写解锁，如果读者数为0，广播条件量，然后释放互斥量。之后，再有其他写加锁或者读加锁，可以获取到互斥量，进行操作。</p>
<p>如果是读解锁，先获取互斥量，然后读者数减去1，如读者数为0，广播条件量，释放互斥量。之后，再有其他写加锁或者读加锁，可以获取到互斥量，进行操作。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="sr-rwlock-init"><a href="#sr-rwlock-init" class="headerlink" title="sr_rwlock_init"></a>sr_rwlock_init</h3><p>初始化接口， 主要对锁的结构体进行初始化。 这里有个shared表示这个锁支持进程间的互斥， 实际上就是这个锁结构在共享内存空间里面，可以支持多个进程对其进行操作。如果不在共享内存中， 就是进程的私有变量，shared就不能为1.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sr_error_info_t</span> *</span><br><span class="line"><span class="title function_">sr_rwlock_init</span><span class="params">(<span class="type">sr_rwlock_t</span> *rwlock, <span class="type">int</span> shared)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sr_error_info_t</span> *err_info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err_info = sr_mutex_init(&amp;rwlock-&gt;mutex, shared))) &#123;</span><br><span class="line">        <span class="keyword">return</span> err_info;</span><br><span class="line">    &#125;</span><br><span class="line">    rwlock-&gt;readers = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((err_info = sr_cond_init(&amp;rwlock-&gt;cond, shared))) &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;rwlock-&gt;mutex);</span><br><span class="line">        <span class="keyword">return</span> err_info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">sr_error_info_t</span> *</span><br><span class="line"><span class="title function_">sr_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *lock, <span class="type">int</span> shared)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sr_error_info_t</span> *err_info = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check address alignment */</span></span><br><span class="line">    <span class="keyword">if</span> (SR_MUTEX_ALIGN_CHECK(lock)) &#123;</span><br><span class="line">        sr_errinfo_new(&amp;err_info, SR_ERR_INTERNAL, <span class="literal">NULL</span>, <span class="string">&quot;Mutex address not aligned.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err_info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shared) &#123;</span><br><span class="line">        <span class="comment">/* init attr */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = pthread_mutexattr_init(&amp;attr))) &#123;</span><br><span class="line">            sr_errinfo_new(&amp;err_info, SR_ERR_SYS, <span class="literal">NULL</span>, <span class="string">&quot;Initializing pthread attr failed (%s).&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="keyword">return</span> err_info;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = pthread_mutexattr_setpshared(&amp;attr, PTHREAD_PROCESS_SHARED))) &#123;</span><br><span class="line">            pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">            sr_errinfo_new(&amp;err_info, SR_ERR_SYS, <span class="literal">NULL</span>, <span class="string">&quot;Changing pthread attr failed (%s).&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="keyword">return</span> err_info;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ret = pthread_mutex_init(lock, &amp;attr))) &#123;</span><br><span class="line">            pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">            sr_errinfo_new(&amp;err_info, SR_ERR_SYS, <span class="literal">NULL</span>, <span class="string">&quot;Initializing pthread mutex failed (%s).&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="keyword">return</span> err_info;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = pthread_mutex_init(lock, <span class="literal">NULL</span>))) &#123;</span><br><span class="line">            sr_errinfo_new(&amp;err_info, SR_ERR_SYS, <span class="literal">NULL</span>, <span class="string">&quot;Initializing pthread mutex failed (%s).&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="keyword">return</span> err_info;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Wrapper for pthread_cond_init().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[out] cond Condition variable to initialize.</span></span><br><span class="line"><span class="comment"> * @param[in] shared Whether the condition will be shared among processes.</span></span><br><span class="line"><span class="comment"> * @return err_info, NULL on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">sr_error_info_t</span> *</span><br><span class="line"><span class="title function_">sr_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">int</span> shared)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sr_error_info_t</span> *err_info = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">pthread_condattr_t</span> attr;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check address alignment */</span></span><br><span class="line">    <span class="keyword">if</span> (SR_COND_ALIGN_CHECK(cond)) &#123;</span><br><span class="line">        sr_errinfo_new(&amp;err_info, SR_ERR_INTERNAL, <span class="literal">NULL</span>, <span class="string">&quot;Condition variable address not aligned.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err_info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shared) &#123;</span><br><span class="line">        <span class="comment">/* init attr */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = pthread_condattr_init(&amp;attr))) &#123;</span><br><span class="line">            sr_errinfo_new(&amp;err_info, SR_ERR_SYS, <span class="literal">NULL</span>, <span class="string">&quot;Initializing pthread attr failed (%s).&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="keyword">return</span> err_info;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = pthread_condattr_setpshared(&amp;attr, PTHREAD_PROCESS_SHARED))) &#123;</span><br><span class="line">            pthread_condattr_destroy(&amp;attr);</span><br><span class="line">            sr_errinfo_new(&amp;err_info, SR_ERR_SYS, <span class="literal">NULL</span>, <span class="string">&quot;Changing pthread attr failed (%s).&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="keyword">return</span> err_info;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ret = pthread_cond_init(cond, &amp;attr))) &#123;</span><br><span class="line">            pthread_condattr_destroy(&amp;attr);</span><br><span class="line">            sr_errinfo_new(&amp;err_info, SR_ERR_SYS, <span class="literal">NULL</span>, <span class="string">&quot;Initializing pthread rwlock failed (%s).&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="keyword">return</span> err_info;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_condattr_destroy(&amp;attr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = pthread_cond_init(cond, <span class="literal">NULL</span>))) &#123;</span><br><span class="line">            sr_errinfo_new(&amp;err_info, SR_ERR_SYS, <span class="literal">NULL</span>, <span class="string">&quot;Initializing pthread rwlock failed (%s).&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="keyword">return</span> err_info;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到如果shared为1，会为pthread_mutex_t和pthread_cond_t设置属性attr， 设置PTHREAD_PROCESS_SHARED。这就是支持进程间互斥的条件量和互斥量。</p>
<h3 id="sr-rwlock-destroy"><a href="#sr-rwlock-destroy" class="headerlink" title="sr_rwlock_destroy"></a>sr_rwlock_destroy</h3><p>销毁比较简单，就是释放pthread_mutex_t和pthread_cond_t的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sr_rwlock_destroy</span><span class="params">(<span class="type">sr_rwlock_t</span> *rwlock)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;rwlock-&gt;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;rwlock-&gt;cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sr-rwlock"><a href="#sr-rwlock" class="headerlink" title="sr_rwlock"></a>sr_rwlock</h3><p>sr_rwlock这个函数实现了互斥量的获取和锁定，可以传入超时时间，在指定时间内未获取到互斥量则失败。如果是要对锁进行写操作，需要等所有的读锁释放掉。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sr_error_info_t</span> *</span><br><span class="line"><span class="title function_">sr_rwlock</span><span class="params">(<span class="type">sr_rwlock_t</span> *rwlock, <span class="type">int</span> timeout_ms, <span class="type">sr_lock_mode_t</span> mode, <span class="type">const</span> <span class="type">char</span> *func)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sr_error_info_t</span> *err_info = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout_ts</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    assert(mode != SR_LOCK_NONE);</span><br><span class="line">    assert(timeout_ms &gt; <span class="number">0</span>);</span><br><span class="line">    sr_time_get(&amp;timeout_ts, timeout_ms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MUTEX LOCK */</span></span><br><span class="line">    ret = pthread_mutex_timedlock(&amp;rwlock-&gt;mutex, &amp;timeout_ts);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        SR_ERRINFO_LOCK(&amp;err_info, func, ret);</span><br><span class="line">        <span class="keyword">return</span> err_info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == SR_LOCK_WRITE) &#123;</span><br><span class="line">        <span class="comment">/* write lock */</span></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取条件量失败或者还有读锁，继续等待</span></span><br><span class="line">        <span class="keyword">while</span> (!ret &amp;&amp; rwlock-&gt;readers) &#123;</span><br><span class="line">            <span class="comment">/* COND WAIT */</span></span><br><span class="line">            ret = pthread_cond_timedwait(&amp;rwlock-&gt;cond, &amp;rwlock-&gt;mutex, &amp;timeout_ts); <span class="comment">// pthread_cond_timedwait 这个函数进入等待会释放互斥量，成功后会获得互斥量</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">/* MUTEX UNLOCK */</span></span><br><span class="line">            pthread_mutex_unlock(&amp;rwlock-&gt;mutex);</span><br><span class="line"></span><br><span class="line">            SR_ERRINFO_COND(&amp;err_info, func, ret);</span><br><span class="line">            <span class="keyword">return</span> err_info;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* read lock */</span></span><br><span class="line">        ++rwlock-&gt;readers;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* MUTEX UNLOCK */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;rwlock-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="sr-rwunlock"><a href="#sr-rwunlock" class="headerlink" title="sr_rwunlock"></a>sr_rwunlock</h3><p>sr_rwunlock这个函数释放锁。释放读锁就是简单的对读者数减去1，当读者数为0发送一个条件量，然后释放互斥量。释放写锁就是当读者数为0发送一个条件量，然后释放互斥量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sr_rwunlock</span><span class="params">(<span class="type">sr_rwlock_t</span> *rwlock, <span class="type">sr_lock_mode_t</span> mode, <span class="type">const</span> <span class="type">char</span> *func)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sr_error_info_t</span> *err_info = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout_ts</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    assert(mode != SR_LOCK_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == SR_LOCK_READ) &#123;</span><br><span class="line">        sr_time_get(&amp;timeout_ts, SR_RWLOCK_READ_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* MUTEX LOCK */</span></span><br><span class="line">        ret = pthread_mutex_timedlock(&amp;rwlock-&gt;mutex, &amp;timeout_ts);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            SR_ERRINFO_LOCK(&amp;err_info, func, ret);</span><br><span class="line">            sr_errinfo_free(&amp;err_info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rwlock-&gt;readers) &#123;</span><br><span class="line">            SR_ERRINFO_INT(&amp;err_info);</span><br><span class="line">            sr_errinfo_free(&amp;err_info);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* remove a reader */</span></span><br><span class="line">            --rwlock-&gt;readers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we are unlocking a write lock, there can be no readers */</span></span><br><span class="line">    assert((mode == SR_LOCK_READ) || !rwlock-&gt;readers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!rwlock-&gt;readers) &#123;</span><br><span class="line">        <span class="comment">/* broadcast on condition */</span></span><br><span class="line">        pthread_cond_broadcast(&amp;rwlock-&gt;cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MUTEX UNLOCK */</span></span><br><span class="line">    pthread_mutex_unlock(&amp;rwlock-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这就是sysrepo的读写锁实现。学习一个开源库，挖挖其内部的算法结构的实现，还是一个很不错的学习机会。IT行业就是工作到老，学习到老。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>超时实现-sysrepo笔记(8)</title>
    <url>/2021/10/23/2021-20211023-timeout/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近跟同事联调的时候，遇到了一个问题。我这边使用<code>sysrepo</code>实现了一个更改系统时间的功能的rpc，然后调用方每次调用的时候，如果设置的是将来的某个时刻，总是返回超时，设置当前时间以前的某个时刻，又是正常的。跟踪查看回调的代码，没有任何异常，而且时间的确设置下去了，也正常返回了。这是一个必现的问题，大概想了一下，应该是代码中使用系统时间判断超时了，需要深入看一下<code>sysrepo</code>的代码。</p>
<span id="more"></span>

<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>继续深入到<code>netopeer2</code>跟踪到了具体返回超时的代码行:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = sr_rpc_subscribe_tree(np2srv.sr_sess, xpath, cb, <span class="literal">NULL</span>, <span class="number">0</span>, SR_SUBSCR_CTX_REUSE, &amp;np2srv.sr_rpc_sub); \</span><br><span class="line"><span class="keyword">if</span> (rc != SR_ERR_OK) &#123; \</span><br><span class="line">    ERR(<span class="string">&quot;Subscribing for \&quot;%s\&quot; RPC failed (%s).&quot;</span>, xpath, sr_strerror(rc)); \</span><br><span class="line">    <span class="keyword">goto</span> error; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续sr_rpc_subscribe_tree看到超时相关代码，一层层深入调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sr_rpc_subscribe_tree</span><br><span class="line">--&gt;sr_shmsub_rpc_notify</span><br><span class="line">--&gt;sr_shmsub_notify_finish_wrunlock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">sr_error_info_t</span> *</span><br><span class="line"><span class="title function_">sr_shmsub_notify_finish_wrunlock</span><span class="params">(<span class="type">sr_sub_shm_t</span> *sub_shm, <span class="type">size_t</span> shm_struct_size, <span class="type">sr_sub_event_t</span> expected_ev,</span></span><br><span class="line"><span class="params">        <span class="type">uint32_t</span> timeout_ms, <span class="type">sr_error_info_t</span> **cb_err_info)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  sr_time_get(&amp;timeout_ts, timeout_ms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until this event was processed */</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!ret &amp;&amp; (sub_shm-&gt;lock.readers || (!SR_IS_NOTIFY_EVENT(sub_shm-&gt;event) &amp;&amp; (sub_shm-&gt;event != SR_SUB_EV_NONE)))) &#123;</span><br><span class="line">        <span class="comment">/* COND WAIT */</span></span><br><span class="line">        ret = pthread_cond_timedwait(&amp;sub_shm-&gt;lock.cond, &amp;sub_shm-&gt;lock.mutex, &amp;timeout_ts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret == ETIMEDOUT) &#123;</span><br><span class="line">            <span class="comment">/* handle corner-case when the subscriber has just woken up and is processing this event,</span></span><br><span class="line"><span class="comment">             * lock should never be held for long */</span></span><br><span class="line">            sr_time_get(&amp;timeout_ts, SR_RWLOCK_READ_TIMEOUT);</span><br><span class="line">            <span class="keyword">while</span> (sub_shm-&gt;lock.readers) &#123;</span><br><span class="line">                <span class="comment">/* COND WAIT */</span></span><br><span class="line">                pthread_cond_timedwait(&amp;sub_shm-&gt;lock.cond, &amp;sub_shm-&gt;lock.mutex, &amp;timeout_ts);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* event timeout */</span></span><br><span class="line">            sr_errinfo_new(cb_err_info, SR_ERR_TIME_OUT, <span class="literal">NULL</span>, <span class="string">&quot;Callback event \&quot;%s\&quot; with ID %u processing timed out.&quot;</span>,</span><br><span class="line">                    sr_ev2str(event), request_id);</span><br><span class="line">            <span class="keyword">if</span> ((event == sub_shm-&gt;event) &amp;&amp; (request_id == sub_shm-&gt;request_id)</span><br><span class="line">                    &amp;&amp; ((expected_ev == SR_SUB_EV_SUCCESS) || (expected_ev == SR_SUB_EV_ERROR))) &#123;</span><br><span class="line">                sub_shm-&gt;event = SR_SUB_EV_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* other error */</span></span><br><span class="line">            SR_ERRINFO_COND(&amp;err_info, __func__, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后确认了，是这边pthread_cond_timedwait调用返回了超时。可以看到，外面只是传入了超时间隔timeout_ms，这里调用sr_time_get获取当前的时间，加上timeout_ms计算出超时的时刻。继续看sr_time_get的实现，里面获取时间，传递的clockid是CLOCK_REALTIME，获取系统实时的时间。这边就可以肯定，后面超时就是以系统时间为准了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sr_time_get</span><span class="params">(<span class="keyword">struct</span> timespec *ts, <span class="type">uint32_t</span> add_ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sr_error_info_t</span> *err_info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clock_gettime(CLOCK_REALTIME, ts) == <span class="number">-1</span>) &#123;</span><br><span class="line">        SR_ERRINFO_SYSERRNO(&amp;err_info, <span class="string">&quot;clock_gettime&quot;</span>);</span><br><span class="line">        <span class="comment">/* will not happen anyway */</span></span><br><span class="line">        sr_errinfo_free(&amp;err_info);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_ms += ts-&gt;tv_nsec / <span class="number">1000000</span>;</span><br><span class="line">    ts-&gt;tv_nsec %= <span class="number">1000000</span>;</span><br><span class="line">    ts-&gt;tv_nsec += (add_ms % <span class="number">1000</span>) * <span class="number">1000000</span>;</span><br><span class="line">    ts-&gt;tv_sec += add_ms / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用rpc回调的时候，系统时间被修改为未来的时间，超过超时的时刻，那么pthread_cond_timedwait就会返回超时了。</p>
<h1 id="更深入一步"><a href="#更深入一步" class="headerlink" title="更深入一步"></a>更深入一步</h1><p>我们继续看一下pthread_cond_timedwait的实现，这个是在libc里面的代码，需要下载libc的源码。</p>
<p>跟随超时时间，可以获取一层层的调用关系(看64位的实现)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_timedwait</span><br><span class="line">--&gt; __pthread_cond_timedwait64</span><br><span class="line">--&gt; __pthread_cond_wait_common  <span class="comment">// 根据条件量的属性获取clockid</span></span><br><span class="line">--&gt; __futex_abstimed_wait_cancelable64</span><br><span class="line">--&gt; __futex_abstimed_wait_common</span><br><span class="line">--&gt; __futex_abstimed_wait_common64</span><br><span class="line">--&gt; futex_time64 <span class="comment">// 最后是这个系统调用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">___pthread_cond_timedwait (<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex,</span><br><span class="line">			    <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">timespec64</span> <span class="title">ts64</span> =</span> valid_timespec_to_timespec64 (*abstime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __pthread_cond_timedwait64 (cond, mutex, &amp;ts64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">___pthread_cond_timedwait64 (<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex,</span><br><span class="line">			     <span class="type">const</span> <span class="keyword">struct</span> __timespec64 *abstime)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check parameter validity.  This should also tell the compiler that</span></span><br><span class="line"><span class="comment">     it can assume that abstime is not NULL.  */</span></span><br><span class="line">  <span class="keyword">if</span> (! valid_nanoseconds (abstime-&gt;tv_nsec))</span><br><span class="line">    <span class="keyword">return</span> EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Relaxed MO is suffice because clock ID bit is only modified</span></span><br><span class="line"><span class="comment">     in condition creation.  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> flags = atomic_load_relaxed (&amp;cond-&gt;__data.__wrefs);</span><br><span class="line">  <span class="type">clockid_t</span> clockid = (flags &amp; __PTHREAD_COND_CLOCK_MONOTONIC_MASK)</span><br><span class="line">                    ? CLOCK_MONOTONIC : CLOCK_REALTIME;</span><br><span class="line">  <span class="keyword">return</span> __pthread_cond_wait_common (cond, mutex, clockid, abstime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h1><p>整个逻辑看下来比较清晰了。首先条件量可以设置属性，设置超时时刻的类型。然后，计算超时的时候获取对应类型的时间加上超时间隔，计算出超时的时刻，然后就是调用系统调用判断是否超时了。</p>
<p>因此我们可以修改条件量的的时间属性来根本解决这个问题。我们修改的是系统时间，那么我们就不以系统实时时间来判定超时，使用CLOCK_MONOTONIC类型来解决。主要代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 初始化条件量</span></span><br><span class="line"><span class="type">pthread_condattr_t</span> cattr;</span><br><span class="line"><span class="type">int</span> ret = pthread_condattr_init(&amp;cattr);</span><br><span class="line">ret = pthread_condattr_setclock(&amp;cattr, CLOCK_MONOTONIC);</span><br><span class="line"></span><br><span class="line">ret = pthread_cond_init(&amp;signal-&gt;cond, &amp;signal-&gt;cattr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间获取</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sr_time_get</span><span class="params">(<span class="keyword">struct</span> timespec *ts, <span class="type">uint32_t</span> add_ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sr_error_info_t</span> *err_info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CLOCK_REALTIME 改为CLOCK_MONOTONIC</span></span><br><span class="line">    <span class="keyword">if</span> (clock_gettime(CLOCK_MONOTONIC, ts) == <span class="number">-1</span>) &#123;</span><br><span class="line">        SR_ERRINFO_SYSERRNO(&amp;err_info, <span class="string">&quot;clock_gettime&quot;</span>);</span><br><span class="line">        <span class="comment">/* will not happen anyway */</span></span><br><span class="line">        sr_errinfo_free(&amp;err_info);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_ms += ts-&gt;tv_nsec / <span class="number">1000000</span>;</span><br><span class="line">    ts-&gt;tv_nsec %= <span class="number">1000000</span>;</span><br><span class="line">    ts-&gt;tv_nsec += (add_ms % <span class="number">1000</span>) * <span class="number">1000000</span>;</span><br><span class="line">    ts-&gt;tv_sec += add_ms / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样修改了一下，影响的面比较大，而且涉及修改的库比较多。 <code>netopeer2</code>、<code>sysrepo</code>、<code>libnetconf2</code>等都有相关修改，rpc这个机制是通用的，又不是仅为修改系统时间来用的。我简单验证了一下，虽然解决了修改系统rpc的问题，但是又出现了一些其他的超时，应该是没有改全。 OK，可以说这个方案可行，但是代价比较大，这样修改影响面太广了。</p>
<h1 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h1><p>我们看到这个出现问题的根因是修改了系统时间之后，pthrea_cond_timedwait返回了超时。那么根据处理逻辑，我们可以让接口先返回，然后再延迟设置系统时间，这样就可以规避问题了。我在回调函数里面，先对时间参数做合法性校验，基本就保证了修改系统时间一定成功了，然后启动一个线程，延迟1s再修改系统时间，之后线程结束。OK，验证效果达到预期，功能完美完成。改动量少，影响少，又可以完成功能。</p>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>不同的clockid对应不同的时间：</p>
<ul>
<li>CLOCK_REALTIME:系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,<br>中间时刻如果系统时间被用户改成其他,则对应的时间相应改变</li>
<li>CLOCK_MONOTONIC:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响</li>
<li>CLOCK_PROCESS_CPUTIME_ID:本进程到当前代码系统CPU花费的时间</li>
<li>CLOCK_THREAD_CPUTIME_ID:本线程到当前代码系统CPU花费的时间</li>
</ul>
<p>有时候遇到问题，获取到了根本原因，但是根据各个方面的考量，解决问题的方案不一定是从根本上解决问题，还可以绕过根本原因，让其不能达成。就好比遇到一座山，我们不一定要爬到山顶翻过去，还从山脚下找其他路绕过去。解决问题的方法总比问题多。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(三十四) - 网络通信</title>
    <url>/2021/11/06/2021-20211106-linux34-net/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面学习的进程间的通信主要适用于同一台机器的两个进程间的通信，不同机器间的进程间通信就由网络通信来实现。通过定义好的网络协议，不同机器的进程传递交互的内容。当然，网络通信也可以适用于同一台机器的进程间通信，效率比其他方式差一些。进程间通信最快的属于共享内存。</p>
<span id="more"></span>

<h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p>系统提供的网络通信功能主要由一个叫做Socket的接口簇来实现。网络协议通过分层的方式，把复杂的过程进一步简化了，不同层的协议提供不同的功能。</p>
<p>分层也有两种标准，分别是OSI 的标准七层模型 和 TCP&#x2F;IP 模型：</p>
<p><img src="/images/202111/netlayer.webp" alt="avatar"></p>
<p>由于在网络传输的过程中，会经过许多不一一的设备，比如路由器、交换机、分流器、防火墙、主机等，不同用途的设备关系的报文内容是不一样的，可以根据不同层的内容对其处理。</p>
<h2 id="Socket报文交互"><a href="#Socket报文交互" class="headerlink" title="Socket报文交互"></a>Socket报文交互</h2><p>Socket这个其实不属于任何层的，是系统对网络接口的实现，但是socket主要侧重的还是网络层以上的部分，开发者对更底层的实现则不需要关心。通过socket我们可以设置双方通信的ip、端口、传输层协议，还有具体的传输内容。</p>
<h3 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h3><p>通常面试的时候，如果涉及网络通信相关的，一般都会问一问tcp和udp的区别，这里简单列举一下：</p>
<ul>
<li>TCP 是面向连接的，UDP 是面向无连接的。</li>
<li>TCP 提供可靠交付，无差错、不丢失、不重复、并且按序到达；UDP 不提供可靠交付，不保证不丢失，不保证按顺序到达。</li>
<li>TCP 是面向字节流的，发送时发的是一个流，没头没尾；UDP 是面向数据报的，一个一个地发送。</li>
<li>TCP 是可以提供流量控制和拥塞控制的，既防止对端被压垮，也防止网络被压垮。</li>
</ul>
<p>所谓的连接实际就是双方维护了一个连接的状态，用于保证传递的可靠性。流量控制和拥塞控制其实就是根据收到的对端的网络包，调整两端数据结构的状态。</p>
<p>从中我们也能看出，TCP是比UDP复杂的多的协议，不过，具体内部的实现都有操作系统搞定了，我们自己不需要进行这些控制，当然系统也提供了一些接口让我们设置相关的参数，一般使用默认的就好，除非你有特殊的需求。那我们就需要了解这个协议内部的实现了，根据实际情况进行处理。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>使用Socket首先需要调用socket函数，创建一个socket，获取对应的fd：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>domain：表示使用什么 IP 层协议。AF_INET 表示 IPv4，AF_INET6 表示 IPv6。</li>
<li>type：表示 socket 类型。SOCK_STREAM，顾名思义就是 TCP 面向流的，SOCK_DGRAM 就是 UDP 面向数据报的，SOCK_RAW 可以直接操作 IP 层，或者非 TCP 和 UDP 的协议。例如 ICMP。</li>
<li>protocol 表示的协议，包括 IPPROTO_TCP、IPPTOTO_UDP。</li>
</ul>
<p>TCP的接口调用流程：</p>
<p><img src="/images/202111/tcp.webp" alt="avatar"></p>
<p>TCP的实现是一个CS的模型，客户端和服务端的处理不大一样：</p>
<p>TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 socket 赋予一个端口和 IP 地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="type">__kernel_sa_family_t</span>  sin_family;  <span class="comment">/* Address family    */</span></span><br><span class="line">  __be16    sin_port;  <span class="comment">/* Port number      */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>  <span class="comment">/* Internet address    */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    __pad[__SOCK_SIZE__ - <span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>) -</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  __be32  s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sockfd 是上面我们创建的 socket 文件描述符。在 sockaddr_in 结构中，sin_family 设置为 AF_INET，表示 IPv4；sin_port 是端口号；sin_addr 是 IP 地址。 addrlen就是sockaddr_in的大小。</p>
<p>然后调用listen进行监听，调用accept的接口获取连接的fd，获取fd后就基于这个fd进行内容的接收和发送了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>TCP建立连接的时候，有一个三步握手的流程：</p>
<p><img src="/images/202111/tcphandshake.webp" alt="avatar"></p>
<p>TCP客户端通过 connect 函数发起连接.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>连接建立完成后，系统会给客户端分配一个临时的端口，用于后续服务端返回信息使用。监听的 socket 和真正用来传送数据的 socket，是两个 socket，一个叫作监听 socket，一个叫作已连接 socket。成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<p>针对UDP的流程就比较简单一些，两端的端口都是需要指定的。</p>
<p><img src="/images/202111/udp.webp" alt="avatar"></p>
<p>每次通信时，调用 sendto 和 recvfrom，都要传入 IP 地址和端口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>系统对socket的实现分层：</p>
<p><img src="/images/202111/socket.webp" alt="avatar"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://gitee.com/fishmwei/blog_code/tree/master/socket">https://gitee.com/fishmwei/blog_code/tree/master/socket</a></p>
<p><img src="/images/202111/output_TCP.jpg" alt="avatar"></p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>之前对sysrepo的优化彻底结束了，解决了不相关模块的性能影响的问题，验证充分后上线测试了，转测试一周了暂时没有反馈相关的问题。</p>
<p>前面还有一个超时问题的解决，后面发现系统时间不是可以任意设置的，比如设置3000年的时间就不能设置成功，最后限定了可设置的时间范围 ‘1970-01-01 23:59:59’到’2200-01-01 00:00:00’，正常我们的设备可以用到那个时间就很不错了，哈哈，到时候的系统应该可以设置的时间应该更往后了，后继者再来修改吧。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(三十五) - 网络通信</title>
    <url>/2021/11/08/2021-20211108-linux35-socket/</url>
    <content><![CDATA[<p>主要来了解一下Socket在系统内核的实现。</p>
<h1 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h1><p>socket系统调用的主要代码：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(socket, <span class="type">int</span>, family, <span class="type">int</span>, type, <span class="type">int</span>, protocol)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> retval;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))</span><br><span class="line">    flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">  retval = sock_create(family, type, protocol, &amp;sock);</span><br><span class="line">......</span><br><span class="line">  retval = sock_map_fd(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK));</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 sock_create 创建一个 struct socket 结构，然后通过 sock_map_fd 和文件描述符对应起来。</p>
<p>参数family表示地址族，主要是2种，单机的基于文件的AF_UNIX， 支持多机的基于IP网络的AF_INET。还有其他类型的，可以用到在去看(比如Ipv6的AF_INET6)。</p>
<p>参数type表示socket的类型， 也只有几种：分别是 SOCK_STREAM、SOCK_DGRAM 和 SOCK_RAW。。</p>
<p>参数protocol 表示协议的。协议数目是比较多的，也就是说，多个协议会属于同一种类型。</p>
<p>SOCK_STREAM 是面向数据流的，协议 IPPROTO_TCP 属于这种类型。SOCK_DGRAM 是面向数据报的，协议 IPPROTO_UDP 属于这种类型。如果在内核里面看的话，IPPROTO_ICMP 也属于这种类型。SOCK_RAW 是原始的 IP 包，IPPROTO_IP 属于这种类型。</p>
<p>内核中有专门的数据结构来保存上面几个参数代表的数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//net/ipv4/af_inet.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123;</span><br><span class="line">  .family = PF_INET,</span><br><span class="line">  .create = inet_create,<span class="comment">//这个用于socket系统调用创建</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>地址族有数据结构struct net_proto_family 保存，inet_create用来创建socket。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    .type =       SOCK_STREAM,</span><br><span class="line">    .protocol =   IPPROTO_TCP,</span><br><span class="line">    .prot =       &amp;tcp_prot,</span><br><span class="line">    .ops =        &amp;inet_stream_ops,</span><br><span class="line">    .flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">            INET_PROTOSW_ICSK,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    .type =       SOCK_DGRAM,</span><br><span class="line">    .protocol =   IPPROTO_UDP,</span><br><span class="line">    .prot =       &amp;udp_prot,</span><br><span class="line">    .ops =        &amp;inet_dgram_ops,</span><br><span class="line">    .flags =      INET_PROTOSW_PERMANENT,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">    .type =       SOCK_DGRAM,</span><br><span class="line">    .protocol =   IPPROTO_ICMP,</span><br><span class="line">    .prot =       &amp;ping_prot,</span><br><span class="line">    .ops =        &amp;inet_sockraw_ops,</span><br><span class="line">    .flags =      INET_PROTOSW_REUSE,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        .type =       SOCK_RAW,</span><br><span class="line">      .protocol =   IPPROTO_IP,  <span class="comment">/* wild card */</span></span><br><span class="line">      .prot =       &amp;raw_prot,</span><br><span class="line">      .ops =        &amp;inet_sockraw_ops,</span><br><span class="line">      .flags =      INET_PROTOSW_REUSE,</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type和protocl由struct inet_protosw来保存。这里面保存对应类型的一些属性和操作函数。然后，在具体调用的时候获取到对应类型对应的结构，而后再调用。这个和以前讲的文件的操作的实现是一样样的。具体的就不深入了。</p>
<h1 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(bind, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, umyaddr, <span class="type">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">  <span class="type">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line">  sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">  <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">    err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);</span><br><span class="line">    <span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      err = sock-&gt;ops-&gt;bind(sock,</span><br><span class="line">                  (<span class="keyword">struct</span> sockaddr *)</span><br><span class="line">                  &amp;address, addrlen);</span><br><span class="line">    &#125;</span><br><span class="line">    fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>bind函数根据前面返回的fd，找到创建的socket， 将 sockaddr 从用户态拷贝到内核态。调用对应的bind接口。<br>TCP对应bind函数就是inet_bind</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_bind</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)uaddr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> snum;</span><br><span class="line">......</span><br><span class="line">  snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">......</span><br><span class="line">  inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line">  <span class="comment">/* Make sure we are allowed to bind here. */</span></span><br><span class="line">  <span class="keyword">if</span> ((snum || !inet-&gt;bind_address_no_port) &amp;&amp;</span><br><span class="line">      sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line">  inet-&gt;inet_daddr = <span class="number">0</span>;</span><br><span class="line">  inet-&gt;inet_dport = <span class="number">0</span>;</span><br><span class="line">  sk_dst_reset(sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要就是根据传入的端口号地址，来检查端口是否冲突，是否可以绑定。然后设置本端的端口和地址,对端的端口和地址设置为0， 后面连接建立后再赋值。 </p>
<h1 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE2(listen, <span class="type">int</span>, fd, <span class="type">int</span>, backlog)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">  <span class="type">int</span> err, fput_needed;</span><br><span class="line">  <span class="type">int</span> somaxconn;</span><br><span class="line"></span><br><span class="line">  sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">  <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">    somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)backlog &gt; somaxconn)</span><br><span class="line">      backlog = somaxconn;</span><br><span class="line">    err = sock-&gt;ops-&gt;listen(sock, backlog);</span><br><span class="line">    fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>listen 函数跟bind是一个模子的，根据fd获取到socket，然后调用对应的listen函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_listen</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> old_state;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  old_state = sk-&gt;sk_state;</span><br><span class="line">  <span class="comment">/* Really, if the socket is already in listen state</span></span><br><span class="line"><span class="comment">   * we can only allow the backlog to be adjusted.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (old_state != TCP_LISTEN) &#123;</span><br><span class="line">    err = inet_csk_listen_start(sk, backlog);</span><br><span class="line">  &#125;</span><br><span class="line">  sk-&gt;sk_max_ack_backlog = backlog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个 socket 还不在 TCP_LISTEN 状态，会调用 inet_csk_listen_start 进入监听状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_csk_listen_start</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">  <span class="type">int</span> err = -EADDRINUSE;</span><br><span class="line"></span><br><span class="line">  reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue);</span><br><span class="line"></span><br><span class="line">  sk-&gt;sk_max_ack_backlog = backlog;</span><br><span class="line">  sk-&gt;sk_ack_backlog = <span class="number">0</span>;</span><br><span class="line">  inet_csk_delack_init(sk);</span><br><span class="line"></span><br><span class="line">  sk_state_store(sk, TCP_LISTEN);</span><br><span class="line">  <span class="keyword">if</span> (!sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;inet_num)) &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立了一个新的结构 inet_connection_sock，这个结构一开始是 struct inet_sock，inet_csk 其实做了一次强制类型转换，扩大了结构.</p>
<p>struct inet_connection_sock 结构比较复杂。如果打开它，你能看到处于各种状态的队列，各种超时时间、拥塞控制等字眼。我们说 TCP 是面向连接的，就是客户端和服务端都是有一个结构维护连接的状态，就是指这个结构。</p>
<p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。</p>
<p>这里把改用的队列创建起来后，状态置成Listen。</p>
<h1 id="accetp函数"><a href="#accetp函数" class="headerlink" title="accetp函数"></a>accetp函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(accept, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, upeer_sockaddr,</span><br><span class="line">    <span class="type">int</span> __user *, upeer_addrlen)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sys_accept4(fd, upeer_sockaddr, upeer_addrlen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE4(accept4, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, upeer_sockaddr,</span><br><span class="line">    <span class="type">int</span> __user *, upeer_addrlen, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>, *<span class="title">newsock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">  <span class="type">int</span> err, len, newfd, fput_needed;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">......</span><br><span class="line">  sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">  newsock = sock_alloc();</span><br><span class="line">  newsock-&gt;type = sock-&gt;type;</span><br><span class="line">  newsock-&gt;ops = sock-&gt;ops;</span><br><span class="line">  newfd = get_unused_fd_flags(flags);</span><br><span class="line">  newfile = sock_alloc_file(newsock, flags, sock-&gt;sk-&gt;sk_prot_creator-&gt;name);</span><br><span class="line">  err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (upeer_sockaddr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newsock-&gt;ops-&gt;getname(newsock, (<span class="keyword">struct</span> sockaddr *)&amp;address, &amp;len, <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    err = move_addr_to_user(&amp;address,</span><br><span class="line">          len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line">  &#125;</span><br><span class="line">  fd_install(newfd, newfile);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟前面的listen、bind一样。找到socket结构，然后调用accept函数。这里根据旧的socket新建了一个newsock和新的newfd。同时也关联了一个file。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_accept</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> socket *newsock, <span class="type">int</span> flags, <span class="type">bool</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk1</span> =</span> sock-&gt;sk;</span><br><span class="line">  <span class="type">int</span> err = -EINVAL;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk2</span> =</span> sk1-&gt;sk_prot-&gt;accept(sk1, flags, &amp;err, kern);</span><br><span class="line">  sock_rps_record_flow(sk2);</span><br><span class="line">  sock_graft(sk2, newsock);</span><br><span class="line">  newsock-&gt;state = SS_CONNECTED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This will accept the next outstanding connection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> sock *<span class="title function_">inet_csk_accept</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> flags, <span class="type">int</span> *err, <span class="type">bool</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">request_sock_queue</span> *<span class="title">queue</span> =</span> &amp;icsk-&gt;icsk_accept_queue;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">newsk</span>;</span></span><br><span class="line">  <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)</span><br><span class="line">    <span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find already established connection */</span></span><br><span class="line">  <span class="keyword">if</span> (reqsk_queue_empty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">    <span class="type">long</span> timeo = sock_rcvtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line">    error = inet_csk_wait_for_connect(sk, timeo);</span><br><span class="line">  &#125;</span><br><span class="line">  req = reqsk_queue_remove(<span class="built_in">queue</span>, sk);</span><br><span class="line">  newsk = req-&gt;sk;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait for an incoming connection, avoid race conditions. This must be called</span></span><br><span class="line"><span class="comment"> * with the socket locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inet_csk_wait_for_connect</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">long</span> timeo)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">  DEFINE_WAIT(wait);</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    prepare_to_wait_exclusive(sk_sleep(sk), &amp;wait,</span><br><span class="line">            TASK_INTERRUPTIBLE);</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    <span class="keyword">if</span> (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))</span><br><span class="line">      timeo = schedule_timeout(timeo);</span><br><span class="line">    sched_annotate_sleep();</span><br><span class="line">    lock_sock(sk);</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    err = sock_intr_errno(timeo);</span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    err = -EAGAIN;</span><br><span class="line">    <span class="keyword">if</span> (!timeo)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  finish_wait(sk_sleep(sk), &amp;wait);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 icsk_accept_queue 为空，则调用 inet_csk_wait_for_connect 进行等待；等待的时候，调用 schedule_timeout，让出 CPU，并且将进程状态设置为 TASK_INTERRUPTIBLE。如果再次 CPU 醒来，我们会接着判断 icsk_accept_queue 是否为空，同时也会调用 signal_pending 看有没有信号可以处理。一旦 icsk_accept_queue 不为空，就从 inet_csk_wait_for_connect 中返回，在队列中取出一个 struct sock 对象赋值给 newsk。</p>
<p>这个新的newsock的状态最终为CONNECTED， 就可以用来发送和接收数据了。</p>
<h1 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(connect, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, uservaddr,</span><br><span class="line">    <span class="type">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">  <span class="type">int</span> err, fput_needed;</span><br><span class="line">  sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">  err = move_addr_to_kernel(uservaddr, addrlen, &amp;address);</span><br><span class="line">  err = sock-&gt;ops-&gt;connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, addrlen, sock-&gt;file-&gt;f_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>connect函数是发起三次握手的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Connect to a remote host. There is regrettably still a little</span></span><br><span class="line"><span class="comment"> *  TCP &#x27;magic&#x27; in here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __inet_stream_connect(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr,</span><br><span class="line">        <span class="type">int</span> addr_len, <span class="type">int</span> flags, <span class="type">int</span> is_sendmsg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  <span class="type">long</span> timeo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (sock-&gt;state) &#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">case</span> SS_UNCONNECTED:</span><br><span class="line">    err = -EISCONN;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE)</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</span><br><span class="line">    sock-&gt;state = SS_CONNECTING;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (!timeo || !inet_wait_for_connect(sk, timeo, writebias))</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    err = sock_intr_errno(timeo);</span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  sock-&gt;state = SS_CONNECTED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_connect</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">usin</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)uaddr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">  __be16 orig_sport, orig_dport;</span><br><span class="line">  __be32 daddr, nexthop;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> *<span class="title">fl4</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line">......</span><br><span class="line">  orig_sport = inet-&gt;inet_sport;</span><br><span class="line">  orig_dport = usin-&gt;sin_port;</span><br><span class="line">  rt = ip_route_connect(fl4, nexthop, inet-&gt;inet_saddr,</span><br><span class="line">            RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,</span><br><span class="line">            IPPROTO_TCP,</span><br><span class="line">            orig_sport, orig_dport, sk);</span><br><span class="line">......</span><br><span class="line">  tcp_set_state(sk, TCP_SYN_SENT);</span><br><span class="line">  err = inet_hash_connect(tcp_death_row, sk);</span><br><span class="line">  sk_set_txhash(sk);</span><br><span class="line">  rt = ip_route_newports(fl4, rt, orig_sport, orig_dport,</span><br><span class="line">             inet-&gt;inet_sport, inet-&gt;inet_dport, sk);</span><br><span class="line">  <span class="comment">/* OK, now commit destination to socket.  */</span></span><br><span class="line">  sk-&gt;sk_gso_type = SKB_GSO_TCPV4;</span><br><span class="line">  sk_setup_caps(sk, &amp;rt-&gt;dst);</span><br><span class="line">    <span class="keyword">if</span> (likely(!tp-&gt;repair)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tp-&gt;write_seq)</span><br><span class="line">      tp-&gt;write_seq = secure_tcp_seq(inet-&gt;inet_saddr,</span><br><span class="line">                   inet-&gt;inet_daddr,</span><br><span class="line">                   inet-&gt;inet_sport,</span><br><span class="line">                   usin-&gt;sin_port);</span><br><span class="line">    tp-&gt;tsoffset = secure_tcp_ts_off(sock_net(sk),</span><br><span class="line">             inet-&gt;inet_saddr,</span><br><span class="line">             inet-&gt;inet_daddr);</span><br><span class="line">  &#125;</span><br><span class="line">  rt = <span class="literal">NULL</span>;</span><br><span class="line">......</span><br><span class="line">  err = tcp_connect(sk);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里选定源地址和端口， 然后设置目标地址和端口，下面就是修改一下socket的状态，然后发送报文。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Build a SYN and send it off. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_connect</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">buff</span>;</span></span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">......</span><br><span class="line">  tcp_connect_init(sk);</span><br><span class="line">......</span><br><span class="line">  buff = sk_stream_alloc_skb(sk, <span class="number">0</span>, sk-&gt;sk_allocation, <span class="literal">true</span>);</span><br><span class="line">......</span><br><span class="line">  tcp_init_nondata_skb(buff, tp-&gt;write_seq++, TCPHDR_SYN);</span><br><span class="line">  tcp_mstamp_refresh(tp);</span><br><span class="line">  tp-&gt;retrans_stamp = tcp_time_stamp(tp);</span><br><span class="line">  tcp_connect_queue_skb(sk, buff);</span><br><span class="line">  tcp_ecn_send_syn(sk, buff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Send off SYN; include data in Fast Open. */</span></span><br><span class="line">  err = tp-&gt;fastopen_req ? tcp_send_syn_data(sk, buff) :</span><br><span class="line">        tcp_transmit_skb(sk, buff, <span class="number">1</span>, sk-&gt;sk_allocation);</span><br><span class="line">......</span><br><span class="line">  tp-&gt;snd_nxt = tp-&gt;write_seq;</span><br><span class="line">  tp-&gt;pushed_seq = tp-&gt;write_seq;</span><br><span class="line">  buff = tcp_send_head(sk);</span><br><span class="line">  <span class="keyword">if</span> (unlikely(buff)) &#123;</span><br><span class="line">    tp-&gt;snd_nxt  = TCP_SKB_CB(buff)-&gt;seq;</span><br><span class="line">    tp-&gt;pushed_seq  = TCP_SKB_CB(buff)-&gt;seq;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="comment">/* Timer for repeating the SYN until an answer. */</span></span><br><span class="line">  inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,</span><br><span class="line">          inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>struct tcp_sock 里面维护了更多的 TCP 的状态. 接下来 tcp_init_nondata_skb 初始化一个 SYN 包，tcp_transmit_skb 将 SYN 包发送出去，inet_csk_reset_xmit_timer 设置了一个 timer，如果 SYN 发送不成功，则再次发送。</p>
<p>在调用 sk-&gt;sk_prot-&gt;connect 之后，inet_wait_for_connect 会一直等待客户端收到服务端的 ACK。三次握手，实际就是实现了一个状态机，不同状态收到不同报文，作不同的处理。</p>
<p>这个和我今年初写的modbus的那个状态机实现就很像了，架构都差不多。C语言层层回调，最后核心代码都是同一个。</p>
<p>TCP接收到包后调用tcp_rcv_state_process</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_rcv_state_process</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span> =</span> tcp_hdr(skb);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line">  <span class="type">int</span> queued = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> acceptable;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">case</span> TCP_LISTEN:</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">      acceptable = icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &gt;= <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!acceptable)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      consume_skb(skb);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同类型的socket 有对应的结构保存处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock_af_ops</span> <span class="title">ipv4_specific</span> =</span> &#123;</span><br><span class="line">        .queue_xmit        = ip_queue_xmit,</span><br><span class="line">        .send_check        = tcp_v4_send_check,</span><br><span class="line">        .rebuild_header    = inet_sk_rebuild_header,</span><br><span class="line">        .sk_rx_dst_set     = inet_sk_rx_dst_set,</span><br><span class="line">        .conn_request      = tcp_v4_conn_request,</span><br><span class="line">        .syn_recv_sock     = tcp_v4_syn_recv_sock,</span><br><span class="line">        .net_header_len    = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr),</span><br><span class="line">        .setsockopt        = ip_setsockopt,</span><br><span class="line">        .getsockopt        = ip_getsockopt,</span><br><span class="line">        .addr2sockaddr     = inet_csk_addr2sockaddr,</span><br><span class="line">        .sockaddr_len      = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in),</span><br><span class="line">        .mtu_reduced       = tcp_v4_mtu_reduced,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>咻咻咻，that it is. 主要函数就是这些了。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>其实代码都不是很高深，只要花点时间深入进去，都可以看出个七八分，流程都可以梳理通。然后，对照网络协议的具体细节，就可以更深入的了解了，一万小时真香定律。</p>
<p>C语言经常会用到类型的强制转换，不同的结构体的头部是相同类型的，然后后面是扩展的数据。这个有点像面向对象的父类子类， 嗯 。特别在协议解析和处理的代码中，看到的就很多。最常见的就是TLV结构，前面是类型和长度，后面是具体的数据,根据前面的类型，我们就知道后面数据的结构了。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(三十三) - 信号量</title>
    <url>/2021/10/31/2021-20211031-linux33-sem/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>进程间通过共享内存实现进程间通信，但是临界资源需要保护，可以使用信号量进行控制。信号量在这里就起到了锁的作用， 对临界资源进行协调。</p>
<span id="more"></span>

<p>信号量也是System V体系的一部分， 跟共享内存、消息队列类似。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>之前讲sysrepo是一个基于共享内存的数据库，sysrepo主要还是通过文件映射的方式实现共享内存的，属于高一个层级的使用。这里讲一下，共享内存的底层接口使用。</p>
<h3 id="创建共享内存"><a href="#创建共享内存" class="headerlink" title="创建共享内存"></a>创建共享内存</h3><p>首先，创建之前，我们要有一个 key 来唯一标识这个共享内存。这个 key 可以根据文件系统上的一个文件的 inode 随机生成。</p>
<p>创建一个共享内存，都是使用 xxxget 来创建。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflag)</span>;</span><br></pre></td></tr></table></figure>

<p>key 就是前面生成的那个 key，shmflag 如果为 IPC_CREAT，就表示新创建，还可以指定读写权限 0777。这里返回一个共享内存的id。</p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>生成了共享内存以后，接下来就是将这个共享内存映射到进程的虚拟地址空间中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span>  shm_id, <span class="type">const</span>  <span class="type">void</span> *addr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p>这里面的 shm_id，就是上面创建的共享内存的 id，addr 就是指定映射在某个地方。如果不指定，则内核会自动选择一个地址，作为返回值返回。</p>
<p>然后，我们通过强制类型转换，对该内存进行数据写入。</p>
<p>当共享内存使用完毕，我们可以通过 shmdt 解除它到虚拟内存的映射。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span>  <span class="type">void</span> *shmaddr)</span>；</span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量，也是类似的。</p>
<p>首先，创建之前，我们同样需要有一个 key，来唯一标识这个信号量集合。这个 key 同样可以根据文件系统上的一个文件的 inode 随机生成。</p>
<p>然后，我们需要创建一个信号量集合，同样也是使用 xxxget 来创建，其中创建信号量集合使用的是下面这个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br></pre></td></tr></table></figure>

<p>这里面的 key，就是前面生成的那个 key，shmflag 如果为 IPC_CREAT，就表示新创建，还可以指定读写权限 0777。</p>
<p>信号量是以集合的形式存在，一次可以申请nsems个信号量，一般我们申请一个就可以了。</p>
<p>信号量对应的有P、V的操作，分别用于获取信号量和释放信号量。信号量可以设置同时并发的个数，每一个P操作就是对信号量的值减一，每一个V操作就是对信号量的值加一。当信号量的值为0的时候，P操作就会挂住，等待信号量的值大于0之后才继续执行。</p>
<p>我们设置信号量的初值为1，那么就可以实现同时仅能有一个访问者对资源操作的功能，就是锁的功能了。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>源码：</p>
<p><a href="https://gitee.com/fishmwei/blog_code/tree/master/linux-kernel/sem">https://gitee.com/fishmwei/blog_code/tree/master/linux-kernel/sem</a></p>
<p>运行效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Keep:sem keep$ ./p</span><br><span class="line">ftok error: No such file or directory</span><br><span class="line">how many integers to caculate : 2</span><br><span class="line">Input the 0 integer : 1</span><br><span class="line">Input the 1 integer : 2</span><br><span class="line">how many integers to caculate : </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Keep:sem keep$ ./c</span><br><span class="line">ftok error: No such file or directory</span><br><span class="line">1+2=3</span><br><span class="line">no tasks, waiting.</span><br><span class="line">no tasks, waiting.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>前几天到公司的时间早了一点，下车前突然想到很久没有在极客时间上面学习了，打开趣谈linux操作系统，开始学了大概半小时，感觉效果挺不错，四周挺安静的。嗯，每天挤出来半个小时，学习一下，积少成多，加油。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（1）-一个yang解析错误问题</title>
    <url>/2021/11/24/2021-20211124-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>
<p>当然，不保证每周都有值得分享的问题，当然也可能有多个问题可以分享，那有时候会谈谈自己近期工作生活中遇到的琐事种种，大忙的时候也可能缺更。嗯，从这周开始这一个系列的文章, 看看我能坚持多久，嘿嘿!</p>
<h2 id="一个yang解析错误问题"><a href="#一个yang解析错误问题" class="headerlink" title="一个yang解析错误问题"></a>一个yang解析错误问题</h2><p>情况是这样的，项目使用命令行进入，如果在未连接上netconf服务端的时候，马上敲入命令，会导致那个netconf连接不正常。好在这是一个必现的问题，通过定位发现一个日志报错的位于libyang库的代码中，然后打开netopeer2的日志，可以确定到出问题之前的那个rpc的xml内容。通过MG-SOFT netconf browser 软件发送这个rpc的xml， 知道的确是这个rpc导致的错误， 然后连接就断开了。</p>
<p>下一步就看为什么导致错误的了，这个又需要看libyang的代码了，通过设置buildroot工程下的libyang.mk， 增加CMAKE_BUILD_TYP&#x3D;Debug选项，编译出一个带符号的libyang，然后就是上gdb调试了。</p>
<p>后面定位到是一个xpath解析的问题，由于传入的xpath是没有带模块名的<code>/node0/node1/node2</code>, 在libyang中认为这是一个错误的xpath，然后就罢工抛异常了。紧接着libnetconf在应答接收不完全的情况下，认为连接异常了，然后把连接设置为invalid了，后续的命令就不能正常执行了。</p>
<p>通过分析xpath的格式，搜索了一下，锁定了问题的源头。是在订阅sysrepo事件的时候传入的xpath问题，缺失了模块名。 通过修改对外接口， 增加了对xpath格式的校验， xpath必须格式为 <code>/m0:node0/m1:node1/m2:node2</code>这样，修改验证后，问题解决。然后就是修改整个项目相关的xpath路径，合并提交代码。最后在部门发个通告，增加这个约束说明。 OK， 问题解决。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>开源代码也是人写的， 出现问题也是很正常。这个问题的根因是sysrepo的函数入口没有对xpath进行约束，却在libyang中又有对xpath有这种检查，导致了这个问题的出现。</p>
<p>程序员定位bug就像是侦探破案，首先是确认问题，现场勘查，然后找寻各种蛛丝马迹，推演问题的产生原因。程序员更方便的是可以复现问题，各种尝试，修改后还可以进行验证。在这个过程中，逻辑思维很重要。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（2）- 管道写满导致程序阻塞</title>
    <url>/2021/12/01/2021-20211201-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第二篇, 下面看问题。</p>
<h2 id="管道写满导致程序阻塞"><a href="#管道写满导致程序阻塞" class="headerlink" title="管道写满导致程序阻塞"></a>管道写满导致程序阻塞</h2><p>最近有业务开发反馈他们在执行一个命令的时候，在命令行分页停留的时候，会导致他们数据面的程序挂住。</p>
<p>分析了一下原因， 命令行使用<code>python</code>的<code>subprocess</code>执行<code>shell</code>命令，读取<code>shell</code>的输出。在命令分页停留的时候，命令行就不会去读取输出，这就导致了输出的缓冲满了，命令程序阻塞了，然后此时那个数据面又在等待他的那个命令程序取读取数据，这样他的数据面也挂住了，^_^。主要原因就是管道已经被写满了，再调用<code>write</code>的时候，命令程序阻塞了。</p>
<p>在<code>linux</code>中，管道也是一个文件，一端读一端写，实际上管道就是一块内存缓存区，是有容量限制的。当管道满的时候：</p>
<p>O_NONBLOCK disable： write调用阻塞，直到有进程读走数据, 一般都是设置这个。<br>O_NONBLOCK enable：调用返回-1，errno值为EAGAIN</p>
<p>我们通过ulimit -a命令查看到的pipe size定义的是内核管道缓冲区的大小，这个值的大小是由内核设定的；而pipe capacity指的是管道的最大值，即容量，是内核内存中的一个缓冲区。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Keep:~ keep$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">max locked memory       (kbytes, -l) unlimited</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 256</span><br><span class="line">pipe size            (512 bytes, -p) 1</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 709</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br></pre></td></tr></table></figure>

<p>网上有许多程序测试管道的最大容量， 结果是65536。</p>
<p>总的来说，管道就像是水管，堵住了总有最大容量吧。然后，每次写入的大小也是有限制的,超过了不保证写入的原子性。分别对应 capacity 和 pipe size。</p>
<h2 id="管道特性小结"><a href="#管道特性小结" class="headerlink" title="管道特性小结"></a>管道特性小结</h2><h3 id="读管道："><a href="#读管道：" class="headerlink" title="读管道："></a>读管道：</h3><ul>
<li><ol>
<li>管道中有数据，read返回实际读到的字节数。</li>
</ol>
</li>
<li><ol start="2">
<li>管道中无数据：<br>(1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)<br>(2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</li>
</ol>
</li>
</ul>
<h3 id="写管道："><a href="#写管道：" class="headerlink" title="写管道："></a>写管道：</h3><ul>
<li><ol>
<li>管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</li>
</ol>
</li>
<li><ol start="2">
<li>管道读端没有全部关闭：<br>(1) 管道已满，write阻塞。<br>(2) 管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ol>
</li>
</ul>
<p>管道之前将sysrepo的时候有用到过，就是使用了它的特性。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>最近项目进内测了，作为平台支撑的开发，总是格外的忙。许多业务定位不了的问题，都要被拉着去定位，忙的连改bug的时间都没有了。</p>
<p>项目还有各种奇葩的指标需要去满足。什么Bug缺陷率需要达到多少，测试用例数目啊，各种cli命令汇总等待。还有一些详细设计变更要补充。说到底，就是缺人。要求有点高，外加钱没给到位，招聘不到合格的人，只能尽量压榨现有人员。貌似是工作这么些年以来最忙的一段时间了。</p>
<p>说实在的，我还有点怀念之前那公司的管理风格和氛围了，虽然流程缺失了许多，但没有那么多的条条框框。给你充分发挥的空间和时间，任务也不是那么的紧张，有自我充电的时间，肯花些时间就可以很容易的胜任工作。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（3）- python调试</title>
    <url>/2021/12/11/2021-20211211-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第三篇, 下面看问题。</p>
<h2 id="python调试"><a href="#python调试" class="headerlink" title="python调试"></a>python调试</h2><p>刚开始定位问题的时候，如果python程序的进程挂住了或者是coredump了，使用gdb进行调试，只能通过bt看到c函数的调用栈，没有办法看到python对应的代码，问题的定位比较困难。</p>
<p>然后就到gdb官网上去看了，是可以支持调试python的。</p>
<p><code>https://sourceware.org/gdb/current/onlinedocs/gdb/Python.html#Python</code></p>
<p>首先编译gdb的时候，需要带上–with-python，才能够支持调试python。</p>
<p>如何进行gdb调试python， 可以参考python官网的文章<br><code>https://wiki.python.org/moin/DebuggingWithGdb</code></p>
<p>文章指出，有些python难以调试的bug需要使用到gdb，分别是：</p>
<ul>
<li>段错误(未捕获到python异常)</li>
<li>进程挂住（无法获取调用栈）</li>
<li>不可控的daemon进程</li>
</ul>
<p>然后需要安装python-debuginfo库，否则会读不到python的符号表。</p>
<p>最后使用命令 gdb attach <pid> 就可以开始调试python程序了。</p>
<p>怎么进行调试也有文档<br><code>https://fedoraproject.org/wiki/Features/EasierPythonDebugging</code></p>
<p>这个问题就讲这么多，最终使用py-bt可以看到python代码的调用栈，也就可以很轻松的看到问题了。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>这一周，要处理的问题比较多，还需要完成之前欠下的文档，就在周六发文了。</p>
<p>项目首轮内测快结束了，测试组开始性能压测了，那些个开源代码和商业源代码都抵挡不住败下阵来了，有程序死锁的问题，也有程序coredump的问题，还有就是执行慢的性能问题。根据coredump定位出了好几个异常分支，释放野指针的问题，基本上都是函数返回值未判断，变量未初始化导致的。这些问题，在正常的处理流程中不易暴露，但是在极端情况下，比如内存耗尽，CPU满载的时候，很容易就复现了。所以编码习惯很重要，如果在编码的时候，养成了习惯，对返回值进行了判断处理，变量都进行了初始化，那么程序将天生健壮。</p>
<p>当然，开源程序和商业代码也都是程序员贡献的，有问题也是正常的。毕竟人家很多是利用业余时间完成的，还有很多代码也是经验尚浅的人写的，或者是出于应用场景的局限有不同的考量。</p>
<p>遇到问题，解决就是了。</p>
<p>在定位问题的过程中，还是用top、perf等工具，后面整理了，​再来分享。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(5)-配置过多，服务启动不了</title>
    <url>/2021/12/25/2021-20211225-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第五篇, 下面看问题。</p>
<h1 id="配置过多，服务启动不了"><a href="#配置过多，服务启动不了" class="headerlink" title="配置过多，服务启动不了"></a>配置过多，服务启动不了</h1><p>问题现象是在大量配置的时候，设备重启或者升级之后，由于服务初始化加载配置运行时间过长，超过了systemd默认的90s，服务被systemd强制退出了。</p>
<p>设备的配置是通过yang来保存的，在重启的时候需要加载配置，加载配置的时候，管理进程会保存一个对象，对应到yang的结构去，后续便于业务查询。当有大量配置的时候，这个对象就很大， 再往这个对象塞数据的时候就变的很慢。这么说吧， 初始的时候塞100条需要100ms的时间， 当数据量达到2-3w的时候，每塞100条就需要1s的时间。所有3w条数据全部塞完就需要大概3分多钟了，远远超出了90s。这个还只是单个业务的配置，再叠加更多可以配置大量配置的业务，时间更不可估量了。</p>
<p>针对这个问题，只能把配置大量配置的业务的过滤掉，不保存到对象中。让业务自己保存处理这些数据。同时也修改一下服务进程的启动时长，就是在.service文件增加TimeOutStartSec&#x3D;600， 设置启动超时为10分钟。</p>
<h1 id="版本升级，服务启动不了"><a href="#版本升级，服务启动不了" class="headerlink" title="版本升级，服务启动不了"></a>版本升级，服务启动不了</h1><p>这个问题和上一个是一样的现象，就是在设备升级后，需要同步更新所有的yang文件定义。使用sysrepo提供的sysrepoctl命令升级对应的yang文件定义。每升级一个yang文件就要耗时5s左右，在项目存在许多个yang文件的时候，这个启动时长也就超过90s了。在设置.service 的TimeOutStartSec之后，问题基本解决了。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>厂商提供的商业系统只是一个架子，满足基本的需求。针对不同的产品，可能遇到各种限制，各种难题。这个时候，除了在原有的架子里填东西，还需要进行老屋改造，以适应不同的需求，解决各种问题。这个过程中，需要先吃透原来的框架，便于打补丁。同时还得自己造轮子，增加新的解法。</p>
<p>第一个版本都是比较艰难的，一个是对原有程序不熟悉，需要花费大量的时间去学习；另一个是需要在快速学习的过程中，活学活用，开发新的功能。近期遇到了许多程序崩溃、挂死、超时的问题，还是挺耗费精力的。</p>
<p>最近把人生第一套房子卖了，过几天就交房了，这几天搬家。下周有可能没有网络，也许会停更一周了。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（4）- 系统时间更改导致的问题</title>
    <url>/2021/12/17/2021-20211217-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第四篇, 下面看问题。</p>
<h1 id="系统时间更改导致的问题"><a href="#系统时间更改导致的问题" class="headerlink" title="系统时间更改导致的问题"></a>系统时间更改导致的问题</h1><p>修改系统时间是一个不是常用的功能，但是又是很必须的。看起来很简单的系统时间的修改，也出了好几个问题。</p>
<h2 id="rpc超时"><a href="#rpc超时" class="headerlink" title="rpc超时"></a>rpc超时</h2><p>修改系统时间，本身使用的是一个rpc调用，rpc使用超时机制的，就是在指定时间内如果执行函数没有返回，那么rpc就认为超时失败了。这个问题在前面的文章中讲过，具体可以看这篇文章 <a href="https://fishmwei.github.io/2021/10/23/timeout/">超时实现-sysrepo笔记(8)
</a></p>
<h2 id="dhcp接口ip失效"><a href="#dhcp接口ip失效" class="headerlink" title="dhcp接口ip失效"></a>dhcp接口ip失效</h2><p>同样的，接口配置了dhcp方式获取地址，由于修改了系统时间为未来的时间，导致dhcp的租期过期，接口自动释放了ip地址。相当于就是没有地址了。这样子，网络就不通的。网络不通算是一个挺大的问题吧，在web上面修改个时间，然后网络就断开了，无法连接了。</p>
<p>这个问题修改也简单，在修改ip的时候，还得触发dhcp续租。</p>
<h2 id="rpc返回时间与系统时间不一致"><a href="#rpc返回时间与系统时间不一致" class="headerlink" title="rpc返回时间与系统时间不一致"></a>rpc返回时间与系统时间不一致</h2><p>这个是又在rpc返回是使用的python代码，就是time模块获取时间。当系统时间更改之后，其实python并没有立刻同步到系统的时间，这样就导致了，rpc返回的时间跟使用date命令查看到的时间不一致。</p>
<p>这个问题只需要通过python调用date命令，获取返回结果就可以解决。</p>
<h2 id="系统时间修改之后，设备重启时间不正确"><a href="#系统时间修改之后，设备重启时间不正确" class="headerlink" title="系统时间修改之后，设备重启时间不正确"></a>系统时间修改之后，设备重启时间不正确</h2><p>操作系统的时间，有软件时间和硬件时间，平常使用date设置和获取的时间都是软件时间。在设备重启之后，系统时间会同步为硬件时间，这就导致了问题。</p>
<p>也就是在修改系统时间的同时，需要同步修改到硬件时间，调用命令<code>hwclock -w</code>。</p>
<h2 id="系统时间修改之后，如果不同零时区，设备重启后时间会快几个小时"><a href="#系统时间修改之后，如果不同零时区，设备重启后时间会快几个小时" class="headerlink" title="系统时间修改之后，如果不同零时区，设备重启后时间会快几个小时"></a>系统时间修改之后，如果不同零时区，设备重启后时间会快几个小时</h2><p>在上面那个问题修改之后，当当前时区是UTC时，功能正常。但是如果当前时区不是UTC时，重启之后，发现时间会快几个小时。这个就涉及到了时区跟时间轴的问题。</p>
<p>随着时区的不同，即使显示的时间是一致的，实际上它那个时间轴却是不同的。上一个问题中，使用<code>hwclock -w</code>命令，实际是把时区转换后的时间同步给了硬件时间，但是硬件时间重启后是没有时区概念的，就是认为是零时区。就是你保存了1000进去，1000对应的是8时区的。重启后，它又给设到软件时间1000， 告诉你这个是0时区的时间。然后，你软件时间是8时区，最后显示出来的时间是1000 + 8小时。</p>
<p>这个问题修改，需要在同步的时候，指定为0时区时间同步， 调用命令<code>hwclock -w -u</code>.</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>系统软件运行的时候，很多功能都是假定时间不变的基础上运行的。在修改了时间之后，系统实时时间就变了，很容易就导致了异常。只是这个时间更改是一个低频事件。</p>
<p>最开始开发这个功能的时候，看了深信服产品web端的效果，发现修改个时间，都要求系统要重启，感觉很暴力。看来是人家踩过了不少坑，最后采用了最行之有效的重启大法，虽然重启导致了业务的中断，但是这个是低频事件，重启可以解决许多未知的问题。系统时间的更改是一个还蛮有风险的动作。</p>
<p>时间更新除了手动修改外，还可以使用ntp自动同步，这里就不多说了。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>放空结束暨2022年小结</title>
    <url>/2023/02/07/2023-20230207-2023/</url>
    <content><![CDATA[<h1 id="2022年小结"><a href="#2022年小结" class="headerlink" title="2022年小结"></a>2022年小结</h1><p>自去年元宵节前夕独自开车到长沙，业已一年有余。趁着元宵节刚过，且昨晚下半夜没睡着，稍微回顾小结了一下刚过去的2022年。</p>
<span id="more"></span>

<p>这一年经历了很多，一切都在变化。 生活、工作、运动、健康、子女教育等各个方面。</p>
<h2 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a>生活上</h2><p>2022年，从一人漂泊到举家迁来长沙，这次是真的下定决心在长沙久居了。</p>
<p>两个娃，一个小学一年级一个幼儿园小班，也正式开始成为陪跑的鸡娃父母。养娃的费用也是蹭蹭蹭的上涨了。</p>
<p>这一年也是工作以来休息最长的一年了，从1月底辞职到3月15日才正式上班，间隔了一个半月。到11月份又连着休息了一个7天年假加4天周末， 共11天。这还不止， 到了12月中旬随着疫情的放开，不幸感染了新冠，遭受了连续9天的煎熬， 直到今天还在不时的咳嗽。</p>
<p>2022年还坚持了一件事，重新坚持跑步了，而且运动里程差点就突破高点了(要是没有感染新冠的话)。</p>
<p>另外就是股票基金还是小赚了几个W，嘻嘻！感觉就是得死扛，扛过最艰难的时期，而且相信自己，不断的定投进去，接着就是等着微笑曲线的到来。</p>
<p>然后，就是在春节前，经过一个多月的看房，最终签订了一套二手房；今年才发现长沙的房产交易坑真的很多啊，后面闲谈细聊。</p>
<p><img src="/images/202302/sport.jpg" alt="sport"></p>
<h2 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a>工作上</h2><p>就是换了家公司，专注安全领域了。我觉得这是一个不错的工作方向，很有技术含量，可以不断深耕的。内容很多，工作的时候几乎都在学习的状态中，很充实。</p>
<p>渐渐的也重新接触一些团队管理的事儿。一切都在向着好的方向发展，只要找对了方向，然后再来几个创新或者是自我突破，还是可以继续成长的。</p>
<p>活到老学到老，加油吧！</p>
<p>在这个公司里上班，没有九九六，进度也不是很赶，过得还是蛮惬意的，具体福利什么的也还可以。</p>
<p>工作上，学了一些驱动的知识，还有就是密码算法相关的内容了。</p>
<h1 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h1><h2 id="新冠"><a href="#新冠" class="headerlink" title="新冠"></a>新冠</h2><p>新冠防控放松之后，失去政府的庇佑，很不幸在第一轮就感染。</p>
<p>刚开始(暂时认为是第一天吧)，就是背部、腰有一点儿酸，有无力感，还是继续上班中。</p>
<p>第二天，头变得晕乎乎的，感觉冷，但是没有发烧症状，身边已经已经有同事开始因为感染而请假了。</p>
<p>第三天，头更晕乎乎了，后背和手臂酸痛加强，有点儿鼻塞了，当天晚上鼻塞加重，喉咙感觉干燥了，头依旧晕乎乎的。</p>
<p>第四天，刚好周六，想着这么难受应该是感染了。带着全家人去做了核酸，晚上结果就出来了，除了丈母娘阴性(那会儿我妈会老家了，丈母娘来帮忙带娃)，其他都是阳性了。这天，自我感觉身体好多了，头也不晕了，但是开始偶尔咳嗽了。自我以为，新冠就这样吧，没什么可怕的。倒是两个孩子开始发烧，流鼻涕，咳嗽了。带去社区医院开了点儿药，给他们吃下。</p>
<p>第五天，周日上午病毒开始发起总攻了。我感觉很冷，盖了两床被子。更可怕的是，感觉后背痛的都快断了似的，并且开始发烧到38度了。难受的我饭也吃不下了，一直在床上躺着。然而，两个小孩却好了，在家里活蹦乱跳了。开始吃药了。 </p>
<p>第六天，向领导请了假，好好养病了。感觉虚脱了，酸痛有所缓解，但是喉咙开始沙哑，依旧感觉冷。</p>
<p>第七天，喉咙跟吞了刀子似的难受，咳嗽加剧。鼻塞，呼吸困难。凌晨的时候，高烧，全是流汗都湿透了，继续煎熬着，整夜没睡觉，。。。</p>
<p>第八天，白天依旧煎熬着。傍晚，刷到视频，说是开空调可以缓解鼻塞。晚上就开着空调，果然有效，终于回过神了。鼻塞缓解了，但是，还是在发烧中。立马贴了一个退烧贴，那一瞬间，真的凉到大脑里去了，眼泪直接就流出来了，太艰难了。鼻塞是缓解了，但是喉咙特别的干燥，需要不断的喝水，不然就会咳嗽。但是，精神还是好了许多，鼻涕也变绿了。</p>
<p>第九天，自我以为到后期了，主要就是可算、口干、流浓鼻涕。咳嗽了好几天了，肚子的肌肉都酸痛了。这个时候，总是不自觉的要咳嗽，什么止咳糖浆根本无效。这会儿，感觉到身体很多部位还是酸痛，食欲也一直不好。看来道阻且长啊。</p>
<p>第十天，咳嗽更严重了，咳出了白痰，上网查说是伤到了肺。一直咳嗽，需要吃消炎、抗生素之类的了。复用了洛索洛芬钠片，睡过一觉之后，咳嗽好了许多。</p>
<p>第十一天，咳嗽好转了，也没有那么的口干了。真的到后期了。</p>
<p>第十二天，继续上班去了。</p>
<p>后面的日子，就好好调理了，经过这么大的一场病，跑步也不跑了，尽量的少动多休息。</p>
<p>现在，已经阳康了，但是，许多年前的慢性咽炎又犯了，哎！</p>
<p>我想说的是，健康真的很重要。 </p>
<p>新冠没有那么可怕，但是也不简单，要认真对待。</p>
<h2 id="购房"><a href="#购房" class="headerlink" title="购房"></a>购房</h2><p>春节前，和老婆也看了许多房子，最后确定了小区。看中的呢，就是居住体验、学校、地理位置和后期的升值空间，几者综合一下。也看了一些学区比较好的小区，但是那个居住体验感觉很不好，人车不分流，房间昏暗，采光不好。梅溪湖也去看过，房子和学校都还可以，就是位置远离市中心，价格偏高了，感觉就是睡城；春节后也去梅溪湖转了一下，人很少，空荡荡的。至于神盘八方小区，大户型高总价，不是我等平民可以hold住的。最终，选择了滨江的一个小区，入手了一套小户型江景房。学校就在家门口，离公司也不是很远。先这么着了，手里还可以留点钱，不至于没有任何扛风险能力。</p>
<p>可笑的是，我辛苦攒了11个月的社保，眼看着购房资格即将到手的时候。也就是，我刚签完购房合同后的几天，长沙又放松限购了，本科落户就可以买房了，呵呵。不过，对我没啥影响，就是资格提前一个月到手而已。</p>
<p>签了合同之后，就是贷款了。这里坑的是，那个房产中介说，长沙这边贷款，要中介代办的话需要给服务费，如果是纯商贷需要几千块就行，要是组合贷款那就要收总金额的两个点。哇塞，这钱真好赚。当然也可以自己去办理，不用给他们手续费，但是贷款这些流程要买家自己办理。我第一反应，就是要自己去办理，不通过中介。毕竟，在福州也买过一手房，那个组合贷款办理起来也很简单，只需要交下材料而已，就等着放款了。后面，发现自己太年轻了。</p>
<p>春节之后，就找了一个建行的人咨询贷款问题。组合贷，需要自己去公积金中心递交材料，然后等待审核，银行会找第三方公司来评估，确认贷款额度什么的。结果，发现长沙市的公积金二手房组合贷，必须过户后再去申请，也就是需要自己先全款给了买家，过完户拿到证了，一年之内到公积金中心去申请贷款，公积金最高只有70万额度，而商业贷款其实就是那个抵押贷，只有十年期限。XX的，这么折腾人，养了这群人，整出这种政策，也是无语。然后，想要直接商贷算了，问了几个银行都说不做那个中介的贷款，他们都有合作的中介。我去，办个房贷而已，还挑中介，银行也是黑啊。兜兜转转，最后还是交钱找中介来办了，花钱买服务吧，不知道后面是不是还有坑。后续再同步吧。 </p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>过去的已经过去，下面继续奋斗吧！</p>
<p>路虽远行则将至，事虽难做则必成。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（44）- fio工具使用</title>
    <url>/2023/02/26/2023-20230226-fio/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目组要调研一下Linux磁盘加密的技术，测试一下自研XTS模式算法的性能是否满足需求。</p>
<p>采用fio这个Linux下比较流行的磁盘IO性能工具来测试，浅浅地学习了一下fio的使用，所以就有了本文的小结。</p>
<p>fio最初是作者用来保存测试程序的，这些程序用于测试不同工作负载、定位性能问题或者重现bug。最后，作者就整了这么个工具，可以模拟各种IO负载，用于重复测试。</p>
<span id="more"></span>

<p>fio经过配置可以派生出许多进程或者线程用于处理用户指定类型的IO负载。fio定义了一些global参数，这些参数会被所有的进程或线程共享。进程或者线程也可以定义相同参数的值来覆盖global参数。fio可以读取一个job文件来根据配置进行处理。</p>
<p>fio支持运行于多种类型的操作系统上，一些特性或者选项只能运行于指定的操作系统。</p>
<h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><p>fio源码是开源的， 可以从github上下载后编译, 也可以直接使用apt安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/axboe/fio.git</span><br><span class="line"></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apt install fio</span><br><span class="line"></span><br><span class="line">apt install libaio-dev # 如果要使用libaio引擎 需要安装libaio-dev， 这边的工作原理没有深入研究，默认采用libaio， aio的话之前有文章介绍过了，就是linux下的一种异步io机制。</span><br></pre></td></tr></table></figure>


<h1 id="fio运行命令"><a href="#fio运行命令" class="headerlink" title="fio运行命令"></a>fio运行命令</h1><p>fio的运行命令比较简单，只需要给定一个或者job文件参数就可以运行了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fio [options] [jobfile] ...</span><br></pre></td></tr></table></figure>

<p>fio会根据job文件描述的参数进行处理。当出入多个job文件时，fio会串行的执行每个job文件。</p>
<p>如果一个job文件里只包含一个job，那么也可以通过命令行的方式执行这个job，命令行的参数等同于job文件内的参数。也可以使用命令行给定多个job的入口，每当fio遇到–name的选项后，就会从新开始一个job，名称就是name的值。name参数后面的值会被应用到该job上。</p>
<p>一般fio运行不需要root用户，除非指定的文件或者设备有权限要求。如果job文件用-替换，那么就会从标准输入读取job的参数。</p>
<p>fio的命令选项比较多，具体可以看源码中的HOWTO.rst文件。这里举例讲几个常用的job参数。</p>
<p>每个job一般包含如下参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">I/O type </span><br><span class="line">  定义io模式。我们可能只是顺序读某些文件，或者随机写某些文件。或者同时进行读写，顺序或者随机的。定义从缓存读写还是直接读写。</span><br><span class="line"></span><br><span class="line">Block size</span><br><span class="line">  定义读写I/O的粒度，可以是一个固定的值也可以是一个区间范围。测试的时候，这个值太小的话，会导致线程切换频繁，对结果影响很大。</span><br><span class="line"></span><br><span class="line">I/O size</span><br><span class="line">  读写I/O的数据总量，一般设置为读写文件的大小。</span><br><span class="line"></span><br><span class="line">I/O engine</span><br><span class="line">  如何定义IO，可以是内存映射文件，也可以是普通的读写，可以使用连续或者异步IO，甚至是SG(SCSI generic sg)。</span><br><span class="line"></span><br><span class="line">I/O depth:</span><br><span class="line">  如果使用异步IO引擎，设置每个队列的深度，就是允许最多flight的IO数。</span><br><span class="line"></span><br><span class="line">Target file/device:</span><br><span class="line">  指定多少个文件来分摊工作负载。</span><br><span class="line"></span><br><span class="line">Threads, process and job synchronization:</span><br><span class="line">  指定线程或者进程数。</span><br><span class="line"></span><br><span class="line">filename:</span><br><span class="line">  具体读写的文件或者设备路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上是基础的参数用来定义工作负载的，每个job还有额外的参数设置。</p>
<h1 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h1><p>我测试时，使用的场景就比较简单。</p>
<p>包含随机读、随机写、顺序读、顺序写。</p>
<p>如果磁盘加密的话，读的时候会调用算法的解密操作，写的时候会调用算法的加密操作。</p>
<p>分别测试得到加密和不加密的性能数据，然后对比就可以得到加密前后的性能损耗比。</p>
<p>这个是我测试时使用的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">100%顺序写，写10G数据</span></span><br><span class="line">fio -ioengine=libaio -bs=64k -direct=1 -thread -rw=write -filename=/mnt/sdb1/serial_write_test -name=&quot;BS 64KB serial write test&quot; -iodepth=16 -cpumask=12 -size=10G</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">100%随机写，写10G数据</span></span><br><span class="line">fio -ioengine=libaio -bs=64k -direct=1 -thread -rw=randwrite -filename=/mnt/sdb1/rand_write_test -name=&quot;BS 64KB rand write test&quot; -iodepth=16 -cpumask=12 -size=10G</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">100%随机读，使用前面随机写的数据，最多读60s</span></span><br><span class="line">fio -ioengine=libaio -bs=64k -direct=1 -thread -rw=randread -filename=/mnt/sdb1/rand_write_test -name=&quot;BS 64KB random read test&quot; -iodepth=16 -time_based -runtime=60 -cpumask=12 -size=10G</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">100%顺序读，使用前面顺序写的数据，最多读60s</span></span><br><span class="line">fio -ioengine=libaio -bs=64k -direct=1 -thread -rw=read -filename=/mnt/sdb1/serial_write_test -name=&quot;BS 64KB serial read test&quot; -iodepth=16 -time_based -runtime=60 -cpumask=12 -size=10G</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IO方式使用libaio，linux支持的异步IO。块大小选择64k，direct&#x3D;1不使用系统的文件缓存功能，thread 开启独立的线程处理， iodepth队列深度设置为16， time_based要求基于时间测试，time_based跟runtime组合使用，就是必须运行这么长的时间。cpumask选定执行IO的CPU核，size就是文件的大小为10G。</p>
<p>运行后的效果如图：</p>
<p><img src="/images/202303/fio_result.png" alt="fio_result"></p>
<p>圈红的就是具体的性能。</p>
<h1 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h1><p>测试时需要使用独立了一个分区进行测试。我们使用fdisk创建一个50G的分区，所有测试都在同一个分区进行。<br>分区文件系统使用ext4。</p>
<p>测试加密时，需要用到linux的磁盘加密的模块dm-crypt。在用户态用对应的命令cryptsetup来调用。</p>
<p>这块篇幅比较大，单独开个文章讲。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（45）-使用fdisk进程磁盘分区</title>
    <url>/2023/03/19/2023-20230319-fdisk/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面使用fio工具进行磁盘测试的时候，加密是针对每个分区进行的，所以需要创建一个独立的分区来进行测试，就用到了fdisk命令。</p>
<span id="more"></span>

<h1 id="fdisk磁盘分区"><a href="#fdisk磁盘分区" class="headerlink" title="fdisk磁盘分区"></a>fdisk磁盘分区</h1><p>首先使用lsblk查看当前系统中的块设备信息，里面就有磁盘的相关信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:~# lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0    7:0    0     4K  1 loop /snap/bare/5</span><br><span class="line">loop1    7:1    0  63.3M  1 loop /snap/core20/1822</span><br><span class="line">loop2    7:2    0 248.8M  1 loop /snap/gnome-3-38-2004/99</span><br><span class="line">loop3    7:3    0  63.3M  1 loop /snap/core20/1828</span><br><span class="line">loop4    7:4    0 346.3M  1 loop /snap/gnome-3-38-2004/119</span><br><span class="line">loop5    7:5    0  49.8M  1 loop /snap/snapd/17950</span><br><span class="line">loop6    7:6    0  45.9M  1 loop /snap/snap-store/599</span><br><span class="line">loop7    7:7    0  91.7M  1 loop /snap/gtk-common-themes/1535</span><br><span class="line">loop8    7:8    0  49.9M  1 loop /snap/snapd/18357</span><br><span class="line">loop9    7:9    0    46M  1 loop /snap/snap-store/638</span><br><span class="line">loop10   7:10   0  65.2M  1 loop /snap/gtk-common-themes/1519</span><br><span class="line">sda      8:0    0   100G  0 disk</span><br><span class="line">├─sda1   8:1    0   512M  0 part /boot/efi</span><br><span class="line">├─sda2   8:2    0     1K  0 part</span><br><span class="line">└─sda5   8:5    0  99.5G  0 part /</span><br><span class="line">sdb      8:16   0    10G  0 disk</span><br><span class="line">└─sdb1   8:17   0    10G  0 part</span><br><span class="line">sr0     11:0    1  58.3M  0 rom</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到有一个sdb的磁盘，里面分了一个区sdb1，这个是我分区好了的。为了安全起见，我也不建议大家直接使用实际的机器来测试，我这边使用的是virtualbox的虚拟机，手动添加了一个额外的磁盘。 具体步骤：设置-&gt;存储-&gt;控制器SATA  – 添加虚拟硬盘 。。。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用fdisk -l /dev/sdb查看磁盘信息</span></span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# fdisk -l /dev/sdb</span><br><span class="line">Disk /dev/sdb: 10 GiB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Disk model: VBOX HARDDISK</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x429cd5e6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到增加了一块10G的独立磁盘&#x2F;dev&#x2F;sdb，每个sector大小为512bytes， 需要在上面增加一个10G的分区。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用fdisk命令分区</span></span><br><span class="line"></span><br><span class="line">fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.34).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line">Command (m for help): n # 输入n创建新分区</span><br><span class="line">Partition number (1-128, default 1):</span><br><span class="line">First sector (34-20969472, default 2048):</span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-20969472, default 20969472): 20969472 # 输入计算好的结束扇区索引</span><br><span class="line"></span><br><span class="line">Created a new partition 1 of type &#x27;Linux filesystem&#x27; and of size 10 GiB.</span><br><span class="line">Partition #1 contains a ext4 signature.</span><br><span class="line"></span><br><span class="line">Do you want to remove the signature? [Y]es/[N]o: Y</span><br><span class="line"></span><br><span class="line">The signature will be removed by a write command.</span><br><span class="line"></span><br><span class="line">Command (m for help): w # 输入w使修改生效</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>OK，这样就分区好了。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（47）- cpu亲和性设置</title>
    <url>/2023/04/22/2023-20230422-cpu-affinity/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在测试程序的性能，发现测试出来的数据波动比较大，不是很稳定。</p>
<p>测试的机器上存在大小核的区别，系统在空闲的时候尽量会使用小核进行运算，这样就可以降低功耗。</p>
<p>正常一个程序在运行的时候，也是会在不同的cpu之间进行切换的。通过设置了CPU亲和性后，测试出来的数据就基本变化不大了。</p>
<span id="more"></span>

<h1 id="CPU亲和性"><a href="#CPU亲和性" class="headerlink" title="CPU亲和性"></a>CPU亲和性</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>CPU亲和性就是绑定某一进程（或线程）到特定的CPU（或CPU集合），从而使得该进程（或线程）只能运行在绑定的CPU（或CPU集合）上。CPU亲和性利用了这样一个事实：进程上一次运行后的残余信息会保留在CPU的状态中（也就是指CPU的缓存）。如果下一次仍然将该进程调度到同一个CPU上，就能避免缓存未命中等对CPU处理性能不利的情况，从而使得进程的运行更加高效。</p>
<p>这样使用者可以根据机器对不同的CPU进行功能划分，根据自己的策略来利用好CPU。</p>
<h2 id="CPU核"><a href="#CPU核" class="headerlink" title="CPU核"></a>CPU核</h2><p>我们可以通过命令查看当前系统的核数，实际使用的核数目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cat /proc/cpuinfo | grep processor | wc -l </span><br><span class="line">或者</span><br><span class="line">lscpu</span><br><span class="line">或者</span><br><span class="line">nproc</span><br></pre></td></tr></table></figure>
<p><img src="/images/202304/nproc.png" alt="nproc"></p>
<p>如果是写代码，那么C语言也有函数可以获取CPU数目。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内核</span></span><br><span class="line">pr_info(<span class="string">&quot;Cpu count %d&quot;</span>, NR_CPUS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户态</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysconf</span><span class="params">(_SC_NPROCESSORS_CONF)</span>;<span class="comment">/* 返回系统可以使用的核数，但是其值会包括系统中禁用的核的数目，因此该值并不代表当前系统中可用的核数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysconf</span><span class="params">(_SC_NPROCESSORS_ONLN)</span>;<span class="comment">/* 返回值真正的代表了系统当前可用的核数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下两个函数与上述类似 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_nprocs_conf</span> <span class="params">(<span class="type">void</span>)</span>;<span class="comment">/* 可用核数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_nprocs</span> <span class="params">(<span class="type">void</span>)</span>;<span class="comment">/* 真正的反映了当前可用核数 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CPU亲和性设置"><a href="#CPU亲和性设置" class="headerlink" title="CPU亲和性设置"></a>CPU亲和性设置</h2><p>对于已经存在的程序，我们也可以使用taskset这个命令来限制程序运行的CPU。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taskset -c 3 &lt;program_cmd&gt; # 设置程序在0和1两个CPU上运行 </span><br><span class="line">taskset -p &lt;pid&gt;  # 查看对应进程的CPU亲和性， 输出的实际是个16进制值， 每一位代表一个cpu， 该位为1 表示进程会在该CPU上运行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自己编写代码的话，可以通过CPU_SET设置，C语言的话就是调用相应的API接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*设置或者获取进程的CPU亲和性*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">                        <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置或者获取线程的CPU亲和性*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">cpu_set_t</span> *cpuset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_getaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">                            <span class="type">cpu_set_t</span> *cpuset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>对于内核态的线程kthread也有对应的接口设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是启动的内核线程的话 kthread , include/linux/kthread.h</span></span><br><span class="line"><span class="comment">// 可以创建到指定的cpu上</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create_on_cpu</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">					  <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">					  <span class="type">unsigned</span> <span class="type">int</span> cpu,</span></span><br><span class="line"><span class="params">					  <span class="type">const</span> <span class="type">char</span> *namefmt)</span>;</span><br><span class="line"><span class="comment">// 也可以在创建后，指定运行cpu</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *</span><br><span class="line"><span class="title function_">kthread_run_on_cpu</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data), <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">int</span> cpu, <span class="type">const</span> <span class="type">char</span> *namefmt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	p = kthread_create_on_cpu(threadfn, data, cpu, namefmt);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(p))</span><br><span class="line">		wake_up_process(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这段时间比较忙，渐渐进入了一个技术leader的角色，每天都过得很快。</p>
<p>除了自己一部分的任务外，还得把控团队的代码质量，进行代码检视，指导刚毕业的同事，优化实现逻辑，处理外部需求，跟踪同事的任务进度。</p>
<p>每天的时间感觉都不够用了，一天天一周周的过去了，同时落了很多篇周谈。</p>
<p>还有就是下班后，回到家里，就没有了一个人那时候的学习的氛围了，家里有小孩的话，没有安静的氛围了，经常被打断。</p>
<p>总之，这个写博客文章的习惯还是值得继续坚持的，大家一起共勉！</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（48）- 网络配置</title>
    <url>/2023/06/05/2023-20230606-netplan-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我有一台机器，经常换内核版本调试。机器是公司的产品，如果使用标准的内核启动的话，常常因为配置问题那个图形用户界面会登录不进去，就没办法在用户界面下配置IP。</p>
<p>之前也没有进行详细的了解，不晓得有一个netplan的工具可以配置IP。所以使用的方法也比较挫，就是在<code>/etc/profile</code>文件中添加了几个命令配置IP的。<br>这样，就有一个问题，必须有用户登录才能触发执行这些命令。又刚好我有一个串口线接着机器，所以每次重启后我就先通过串口登录，触发IP配置命令，后面就可以使用ssh网络连接了。</p>
<p>最近呢，串口线让同事借走了，然后又有人连着我的机器进行驱动调试，经常就奔溃了，重启后又要接串口，一个串口线就要来回使用，很麻烦。</p>
<span id="more"></span>

<p>然后就上网查了一下，配置静态IP的方法，找到了netplan这个工具,尝试了一下，可以解决我的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/profile</span></span><br><span class="line"></span><br><span class="line">ifconfig enp1s0 10.0.0.96/24</span><br><span class="line">route add default gw 10.0.0.254</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="netplan"><a href="#netplan" class="headerlink" title="netplan"></a>netplan</h1><p>Ubuntu 18.04开始，Ubuntu和Debian移除了以前的ifup&#x2F;ifdown命令和&#x2F;etc&#x2F;network&#x2F;interfaces配置文件，转而使用ip link set或者&#x2F;etc&#x2F;netplan&#x2F;01-netcfg.yaml模板和sudo netplan apply命令实现网络管理。<br>Netplan 是抽象网络配置描述器，用于配置Linux网络。 通过netplan命令，你只需用一个 YAML文件描述每个网络接口所需配置。netplan并不关心底层管理工具是NetworkManager还是networkd。</p>
<p>netplan是一个基于YAML文件的网络配置工具，在YAML里面描述具体的网络接口的配置，netplan在启动的时候会在&#x2F;run目录下生成对应的配置文件供后台程序使用(NetworkManager&#x2F;networkd),具体使用那个后台程序是在YAML里描述了的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/netplan/01-netcfg.yaml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For more information, see netplan(5).</span></span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd # 后台程序</span><br><span class="line">  ethernets:</span><br><span class="line">          enp1s0:</span><br><span class="line">                  addresses: [10.0.0.96/24]</span><br><span class="line">                  dhcp4: false</span><br><span class="line">                  gateway4: 10.0.0.254</span><br><span class="line">                  nameservers:</span><br><span class="line">                          addresses: [8.8.8.8]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这个文件就是配置了enp1s0网络接口， ip地址为10.0.0.96&#x2F;24, 不开启DHCP， 网关为10.0.0.254, DNS服务器使用8.8.8.8。</p>
<p>我们修改完yaml文件后，可以使用<code>netplan try</code> 测试一下配置是否正确，然后再执行<code>netplan apply</code>，这样重启后就会按配置来配置网络了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netplan try</span></span><br><span class="line">Do you want to keep these settings?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Press ENTER before the timeout to accept the new configuration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Changes will revert in 119 seconds</span><br><span class="line">Configuration accepted.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netplan apply</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这中间遇到了一个错误，因为系统自带的netplan 没有get&#x2F;set命令， 然后我就重新apt install netplan。 但是新的netplan其实跟旧的那个冲突了。重启后发现配置又不生效了。使用新的netplan执行会报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatal error: cannot bind to port 2983, is another daemon running?</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要重新安装会 netplan.io</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先删掉之前的netplan，</span></span><br><span class="line"></span><br><span class="line">sudo apt remove netplan</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后再</span></span><br><span class="line"></span><br><span class="line">sudo apt install netplan.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后</span></span><br><span class="line"></span><br><span class="line">sudo netplan apply</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样才恢复正常了。</p>
<h1 id="快捷键切换命令模式"><a href="#快捷键切换命令模式" class="headerlink" title="快捷键切换命令模式"></a>快捷键切换命令模式</h1><p>后来想想，毕竟机器还连着显示器，用户界面登录不了的话，应该可以使用命令行界面登录的。 今天，也在网络上查找了一下，可以通过快捷键切换Ctrl + ALT + (F1~F6)。</p>
<p>F1的时候是图形界面， F2-F6会创建不同的命令界面。</p>
<p><img src="/images/202306/gui.png" alt="gui"><br><img src="/images/202306/cmd.png" alt="cmd"></p>
<p>这样通过命令行界面登录进去之后，也可以用命令配置网络，其他电脑也就可以顺利的ssh了。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>知之为知之，不知为不知。在实际工作中，带着问题去查找解决方法总是可以学到新的知识。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（49）- 从系统获取acpi表</title>
    <url>/2023/08/10/2023-20230811-acpi/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一直在忙项目，需要跟固件的同事打交道。<br>在Linux中，目前设备的信息很多是通过ACPI表描述的，而这个ACPI表是需要固件写入的，我们操作系统驱动没办法控制。在调试的过程中，经常会遇到在不同的机器上面，驱动执行不一致的问题。驱动代码都是同一份的，不同的就是固件了。而固件内部，除了一些硬件寄存器配置外，就是ACPI表的描述了。很多时候，不晓得别人是不是给你描述对了，与其去问，还不如自己动手去看ACPI表了。</p>
<p>上网查了一下，get一个新技能。</p>
<span id="more"></span>

<h1 id="ACPI表"><a href="#ACPI表" class="headerlink" title="ACPI表"></a>ACPI表</h1><p>APCI, Advanced Configuration and Power Interface，高级配置与电源接口，是BIOS到操作系统的一系列接口，ACPI接口中包含了很多预定义的表格，这些表格的定义存储在BIOS芯片中，由BIOS生成到内存中提交给操作系统，各种不同的操作系统都可以提取BIOS提交的原始ACPI表格文件,其中最重要的就是DSDT和SSDT表格。</p>
<p>DSDT，Differentiated System Description Table，差分系统描述表，包含大部分硬件信息的主体表格。</p>
<p>SSDT，Secondary System Description Table，辅助系统描述表，包含少部分硬件补充信息的表格。</p>
<h1 id="APCI表解析"><a href="#APCI表解析" class="headerlink" title="APCI表解析"></a>APCI表解析</h1><p>在系统目录<code>/sys/firmware/acpi/tables</code>下存储了ACPI表信息，不过这个是不能够明文查看的，需要使用工具解析。这个工具就是iasl, 这是一个编译和解析ACPI的工具，一般系统中没有，需要自行安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install iasl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝APIC文件</span></span><br><span class="line">cp /sys/firmware/acpi/tables/DSDT /tmp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解析DSDT文件，输出 DSDT.dsl</span></span><br><span class="line">cd /tmp</span><br><span class="line">iasl -d DSDT</span><br><span class="line"></span><br><span class="line">root@VirtualBox:/tmp# ls</span><br><span class="line">DSDT  DSDT.dsl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开dsdt.dsl， 找到对应的device，可以看到具体的描述。</p>
<p><img src="/images/202308/dsdt.png" alt="dstt"></p>
<p>上面我们从&#x2F;sys&#x2F;firmware&#x2F;acpi&#x2F;tables拷贝了DSDT表文件到&#x2F;tmp目录。其实，我们也可以使用acpidump工具直接生成表文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install acpidump </span><br><span class="line"></span><br><span class="line">acpidump -n DSDT -b  # 生成DSDT表文件 dsdt.dat</span><br><span class="line"></span><br><span class="line">iasl -d dsdt.dat # </span><br><span class="line"></span><br><span class="line">root@keep:/tmp/812# iasl -d dsdt.dat  # 生成dsdt.dsl文件</span><br><span class="line"></span><br><span class="line">Intel ACPI Component Architecture</span><br><span class="line">ASL+ Optimizing Compiler/Disassembler version 20190509</span><br><span class="line">Copyright (c) 2000 - 2019 Intel Corporation</span><br><span class="line"></span><br><span class="line">File appears to be binary: found 2605 non-ASCII characters, disassembling</span><br><span class="line">Binary file appears to be a valid ACPI table, disassembling</span><br><span class="line">Input file dsdt.dat, Length 0x1B46 (6982) bytes</span><br><span class="line">ACPI: DSDT 0x0000000000000000 001B46 (v02 PHYLTD PHYTIUM. 00000001 INTL 20180629)</span><br><span class="line">Pass 1 parse of [DSDT]</span><br><span class="line">Pass 2 parse of [DSDT]</span><br><span class="line">Parsing Deferred Opcodes (Methods/Buffers/Packages/Regions)</span><br><span class="line"></span><br><span class="line">Parsing completed</span><br><span class="line">Disassembly completed</span><br><span class="line">ASL Output:    dsdt.dsl - 59176 bytes</span><br><span class="line"></span><br><span class="line">acpidump -s # 可以查看当前apci所有的表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了iasl， 还可以使用acpidump工具。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>重启学习历程！</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（50）- 内核编译打包</title>
    <url>/2023/08/23/2023-20230823-kernel-package/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在技术支持的时候，需要在客户机器上编译驱动代码，遇到了一个问题，客户机器上面没有相应的内核头文件编译环境，没办法编译。</p>
<p>后面由同事通过安装deb包的形式把头文件之类的安装后，就可以正常编译了。</p>
<p>在我之前的理解中，要替换内核的话，只能在目标机器上编译内核，然后按照之前编译内核的文章讲的步骤替换内核。</p>
<p>现在发现，内核也是可以通过软件包的方式安装的，自己动手走一下打包流程。</p>
<span id="more"></span>

<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>关于内核打包的方法在网络上找到了一些文章，本人也实践了一下，确实可行，主要流程如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载内核源码, 并编译， 提前编译可以加快后面打包速度</span></span><br><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.10.tar.xz</span><br><span class="line"></span><br><span class="line">tar xvf linux-5.10.tar.xz</span><br><span class="line"></span><br><span class="line">cd linux-5.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方便起见，直接使用当前的配置</span></span><br><span class="line"></span><br><span class="line">cp /boot/config-5.15.56 .config</span><br><span class="line"></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line">make -j 8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">准备打包环境</span></span><br><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt install kernel-package</span><br><span class="line">sudo apt install dwarves</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在内核源码目录中执行以下命令</span></span><br><span class="line">cd linux-5.10</span><br><span class="line">sudo make-kpkg --initrd --revision 001 --append-to-version -20230823 kernel_image kernel_headers --config menuconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make-kpkg 用于为内核源码打包debian包， 这个命令需要在内核源码根目录下运行，打包结束后会在上层目录生成目标文件。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--initrd:选项会让make-kpkg自动帮我们生成initramfs。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--revision:会给生成的deb文件加上一个版本信息，这个参数只是影响到文件名，如果不指定，默认会是“10.00.Custom”。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--append-to-version:是一种版本信息，它不仅出现在deb安装包的文件名里，也会影响到kernel的名称，比如本例中，内核更新完成之后，用“<span class="built_in">uname</span> -r”查看会得到 5.10.0-20230823</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kernel_image:表示生成内核和默认模块的安装包。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kernel_headers:表示生成一个内核头文件的安装包；如果不生成这个deb包，那么我们就无法在/usr/src目录下生成linux-headers-x.x.x，这样就无法编译自己的内# 核模块（虽然可以通过apt-get来安装，但是通过这个方式安装的不一定是自己正在使用的内核版本）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--config=menuconfig:表示以menuconfig的方式编译。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译完成后，会在linux-5.10的上一级目录生成2个文件，一个是image的，一个是headers的</span></span><br><span class="line"></span><br><span class="line">linux-headers-5.10.0-20230823_001_arm64.deb</span><br><span class="line">linux-image-5.10.0-20230823_001_arm64.deb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dpkg -i linux-headers-5.10.0-20230823_001_arm64.deb linux-image-5.10.0-20230823_001_arm64.deb</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（46）-Linux磁盘加密测试</title>
    <url>/2023/03/19/2023-20230319-linux-crypt-disk/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux内部提供了一个dm-crypt的模块，支持对映射设备进行加密。Cryptsetup是一个基于DMCrypt内核模块来设置磁盘加密的工具。<br>此文主要介绍使用该工具实现磁盘加密的步骤，不涉及实现原理。</p>
<span id="more"></span>

<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>运行cryptsetup系统需要cryptsetup-bin软件包，并且安装dm_crypt模块，支持相应的算法。一般发行版linux都已经编译了相关模块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">apt install cryptsetup-bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核编译 dm_crypt模块</span></span><br><span class="line">make menuconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中 &gt; Device Drivers &gt; Multiple devices driver support (RAID and LVM) &gt;Crypt target support</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 dmsetup targets查看是否安装了dm_crypt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没有安装的话， 执行 modprobe dm_crypt 进行安装</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# dmsetup targets</span><br><span class="line">striped          v1.6.0</span><br><span class="line">linear           v1.4.0</span><br><span class="line">error            v1.5.0</span><br><span class="line">root@keep-VirtualBox:~# modprobe dm_crypt</span><br><span class="line">root@keep-VirtualBox:~# dmsetup targets</span><br><span class="line">crypt            v1.23.0</span><br><span class="line">striped          v1.6.0</span><br><span class="line">linear           v1.4.0</span><br><span class="line">error            v1.5.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="创建加密分区"><a href="#创建加密分区" class="headerlink" title="创建加密分区"></a>创建加密分区</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/testfile文件中存放密码，可以省去输入密码的步骤</span></span><br><span class="line">echo -n 123456 &gt;/testfile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用aes-ecb算法创建加密分区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# cryptsetup -c aes-ecb -d /testfile -y luksFormat /dev/sdb1</span><br><span class="line">WARNING: Device /dev/sdb1 already contains a &#x27;ext4&#x27; superblock signature.</span><br><span class="line"></span><br><span class="line">WARNING!</span><br><span class="line">========</span><br><span class="line">This will overwrite data on /dev/sdb1 irrevocably.</span><br><span class="line"></span><br><span class="line">Are you sure? (Type uppercase yes): YES</span><br><span class="line">root@keep-VirtualBox:~#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进行磁盘映射， /dev/sdb1映射到 /dev/mapper/loop200_disk</span></span><br><span class="line">root@keep-VirtualBox:~# cryptsetup -d /testfile open /dev/sdb1 loop200_disk</span><br><span class="line">root@keep-VirtualBox:~# ll /dev/mapper/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  2 root root      80 3月  19 17:27 ./</span><br><span class="line">drwxr-xr-x 19 root root    4220 3月  19 17:27 ../</span><br><span class="line">crw-------  1 root root 10, 236 3月  19 17:00 control</span><br><span class="line">lrwxrwxrwx  1 root root       7 3月  19 17:27 loop200_disk -&gt; ../dm-0</span><br><span class="line">root@keep-VirtualBox:~#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过命令可以查看映射设备的信息。</span></span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:~#  cryptsetup status loop200_disk</span><br><span class="line">/dev/mapper/loop200_disk is active.</span><br><span class="line">  type:    LUKS2</span><br><span class="line">  cipher:  aes-ecb</span><br><span class="line">  keysize: 256 bits</span><br><span class="line">  key location: keyring</span><br><span class="line">  device:  /dev/sdb1</span><br><span class="line">  sector size:  512</span><br><span class="line">  offset:  32768 sectors</span><br><span class="line">  size:    20936704 sectors</span><br><span class="line">  mode:    read/write</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件系统并挂载</span></span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# mkfs.ext4 /dev/mapper/loop200_disk # 创建ext4文件系统</span><br><span class="line">mke2fs 1.45.5 (07-Jan-2020)</span><br><span class="line">Creating filesystem with 2617088 4k blocks and 655360 inodes</span><br><span class="line">Filesystem UUID: 14c88785-a680-4eb8-9807-22db87da8ce7</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632</span><br><span class="line"></span><br><span class="line">Allocating group tables: done</span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (16384 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# mkdir -p /mnt/loop200_disk</span><br><span class="line">root@keep-VirtualBox:~# mount /dev/mapper/loop200_disk /mnt/loop200_disk/</span><br><span class="line">root@keep-VirtualBox:~#</span><br><span class="line">root@keep-VirtualBox:~#</span><br><span class="line">root@keep-VirtualBox:~# lsblk</span><br><span class="line">NAME             MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINT</span><br><span class="line">loop0              7:0    0     4K  1 loop  /snap/bare/5</span><br><span class="line">loop1              7:1    0  63.3M  1 loop  /snap/core20/1822</span><br><span class="line">loop2              7:2    0 248.8M  1 loop  /snap/gnome-3-38-2004/99</span><br><span class="line">loop3              7:3    0  63.3M  1 loop  /snap/core20/1828</span><br><span class="line">loop4              7:4    0 346.3M  1 loop  /snap/gnome-3-38-2004/119</span><br><span class="line">loop5              7:5    0  49.8M  1 loop  /snap/snapd/17950</span><br><span class="line">loop6              7:6    0  45.9M  1 loop  /snap/snap-store/599</span><br><span class="line">loop7              7:7    0  91.7M  1 loop  /snap/gtk-common-themes/1535</span><br><span class="line">loop8              7:8    0  49.9M  1 loop  /snap/snapd/18357</span><br><span class="line">loop9              7:9    0    46M  1 loop  /snap/snap-store/638</span><br><span class="line">loop10             7:10   0  65.2M  1 loop  /snap/gtk-common-themes/1519</span><br><span class="line">sda                8:0    0   100G  0 disk</span><br><span class="line">├─sda1             8:1    0   512M  0 part  /boot/efi</span><br><span class="line">├─sda2             8:2    0     1K  0 part</span><br><span class="line">└─sda5             8:5    0  99.5G  0 part  /</span><br><span class="line">sdb                8:16   0    10G  0 disk</span><br><span class="line">└─sdb1             8:17   0    10G  0 part</span><br><span class="line">  └─loop200_disk 253:0    0    10G  0 crypt /mnt/loop200_disk</span><br><span class="line">sr0               11:0    1  58.3M  0 rom</span><br><span class="line">root@keep-VirtualBox:~#</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以了，后面在&#x2F;mnt&#x2F;loop200_disk里面读写的数据都会自动解密加密了。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这段时间比较忙了，开始管理一个小团队，很多事情都要过自己这关，慢慢的时间就觉得不够用了。慢慢习惯了就好了吧。 </p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（51）- gdb调试基础</title>
    <url>/2023/10/15/2023-20231015-gdb1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>GDB是程序员调试的必备工具，使用GDB可以解决大部分程序错误问题。</p>
<p>当然还有其他的使用方式，比如近期在项目中就使用GDB截图的方式通过了商密检测，截图作为一种方式证明了数据的确是真实的。</p>
<p>这几天刷头条，偶然刷到了GDB相关的文章，顺便搞个文章重新梳理一下GDB的知识结构及使用方法。</p>
<span id="more"></span>

<h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>为了便于调试，最好在程序编译时为gcc命令加上-g选项进行编译。测试程序随机生成给定数目的数据数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># test.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max_length = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">get_rand</span><span class="params">(<span class="type">uint8_t</span> *a, <span class="type">uint32_t</span> byteLen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fd = open(<span class="string">&quot;/dev/random&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;get rand fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = read(fd, a, byteLen);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;get rand fail 2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">generate</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> * buffer = (<span class="type">char</span>*) <span class="built_in">malloc</span> (length+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">  get_rand(buffer, length);</span><br><span class="line">	buffer[length] = <span class="string">&#x27;\0&#x27;</span>;dd</span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">char</span> * buffer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;Input the string length : &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(num &gt; max_length)&#123;</span><br><span class="line">    num = max_length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buffer = generate(num);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;Random string is: %s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span> (buffer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h2><p>启动调试命令最简单的方式是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gcc -g test.c -o test</span><br><span class="line"></span><br><span class="line">GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1</span><br><span class="line">Copyright (C) 2022 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from test...</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x12b2: file test.c, line 21.</span><br><span class="line">(gdb)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>设置断点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">break  main # 函数断点</span><br><span class="line"></span><br><span class="line">b test.c:58 # 文件行号断点, b是break的省略写法</span><br><span class="line"></span><br><span class="line">b test.c:28 58 num == 9 # 条件断点</span><br><span class="line"></span><br><span class="line">tbreak test.c:58 # 临时断点，这个断点只会断一次，后续不会再断到</span><br><span class="line"></span><br><span class="line">info b # 查看已经设置的断点</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用断点</span></span><br><span class="line"></span><br><span class="line">disable  	# 禁用所有断点</span><br><span class="line">disable bnum # 禁用指定标号的断点</span><br><span class="line">enable  	# 启用所有断点</span><br><span class="line">enable bnum # 启用指点标号的断点</span><br><span class="line">enable delete bnum      # 启动标号为bnum的断点，并且在断到后删除该断点</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">断点清除</span></span><br><span class="line"> clear                   # 删除当前行所有breakpoints</span><br><span class="line">clear function          # 删除函数名为function处的断点</span><br><span class="line">clear filename:function # 删除文件filename中函数function处的断点</span><br><span class="line">clear lineNum           # 删除行号为lineNum处的断点</span><br><span class="line">clear f:lename:lineNum  # 删除文件filename中行号为lineNum处的断点</span><br><span class="line">delete                  # 删除所有breakpoints,watchpoints和catchpoints  delete可以省略为d</span><br><span class="line">delete bnum             # 删除断点号为bnum的断点 </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h2><p>变量查看： 最常用的就是print（简写为p） 变量</p>
<p>查看内存： 使用examine(简写为x) 内存地址, 语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">x/[n][f][u] addr</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式 f</span></span><br><span class="line">b 字节</span><br><span class="line">h 半字，即双字节</span><br><span class="line">w 字，即四字节</span><br><span class="line">g 八字节</span><br><span class="line"></span><br><span class="line">n 表示要显示的内存单元数，默认值为1</span><br><span class="line">f 表示要打印的格式，前面已经提到了格式控制字符</span><br><span class="line">u 要打印的单元长度</span><br><span class="line">addr 内存地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如：</span></span><br><span class="line">(gdb) x/32b buffer</span><br><span class="line">0x555555559ac0: 0xa2    0x0a    0xc6    0x6c    0xcb    0xe8    0xb4    0x66</span><br><span class="line">0x555555559ac8: 0x5a    0x96    0xb1    0x6a    0x00    0xc4    0x5b    0x5b</span><br><span class="line">0x555555559ad0: 0xa2    0x05    0x12    0x73    0x04    0x97    0x13    0xc6</span><br><span class="line">0x555555559ad8: 0x9e    0x2c    0x5a    0x8f    0x18    0xb3    0xd2    0x35</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看寄存器： info registers</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) info registers</span><br><span class="line">rax            0x555555559ac0      93824992254656</span><br><span class="line">rbx            0x0                 0</span><br><span class="line">rcx            0x7ffff7d15157      140737351078231</span><br><span class="line">rdx            0x20                32</span><br><span class="line">rsi            0x555555559ac0      93824992254656</span><br><span class="line">rdi            0x3                 3</span><br><span class="line">rbp            0x7fffffffe350      0x7fffffffe350</span><br><span class="line">rsp            0x7fffffffe320      0x7fffffffe320</span><br><span class="line">r8             0x1999999999999999  1844674407370955161</span><br><span class="line">r9             0x555555559ac0      93824992254656</span><br><span class="line">r10            0x0                 0</span><br><span class="line">r11            0x246               582</span><br><span class="line">r12            0x7fffffffe468      140737488348264</span><br><span class="line">r13            0x555555555388      93824992236424</span><br><span class="line">r14            0x555555557d78      93824992247160</span><br><span class="line">r15            0x7ffff7ffd040      140737354125376</span><br><span class="line">rip            0x5555555553fd      0x5555555553fd &lt;main+117&gt;</span><br><span class="line">eflags         0x207               [ CF PF IF ]</span><br><span class="line">cs             0x33                51</span><br><span class="line">ss             0x2b                43</span><br><span class="line">ds             0x0                 0</span><br><span class="line">es             0x0                 0</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x0                 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>单步调试，使用next（简写为n）, next num &#x2F;&#x2F; 继续执行num行</p>
<p>单步进入， step（简写为s）， 一般用于进入当前行的函数，但前提是该函数有调试信息并且有源码信息。</p>
<p>断点继续， continue（简写为c），直接继续后面的程序</p>
<h2 id="源码查看list"><a href="#源码查看list" class="headerlink" title="源码查看list"></a>源码查看list</h2><p>我们可以使用list命令， 显示当前运行的代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) list  # 默认显示前后共10行代码</span><br><span class="line">46</span><br><span class="line">47        return buffer;</span><br><span class="line">48      &#125;</span><br><span class="line">49</span><br><span class="line">50      int main(int argc, char *argv[])</span><br><span class="line">51      &#123;</span><br><span class="line">52        int num;</span><br><span class="line">53        char * buffer;</span><br><span class="line">54</span><br><span class="line">55        printf (&quot;Input the string length : &quot;);</span><br><span class="line">(gdb)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">敲回车，继续显示后面10行</span></span><br><span class="line">(gdb)</span><br><span class="line">56        scanf (&quot;%d&quot;, &amp;num);</span><br><span class="line">57</span><br><span class="line">58        if(num &gt; max_length)&#123;</span><br><span class="line">59          num = max_length;</span><br><span class="line">60        &#125;</span><br><span class="line">61</span><br><span class="line">62        buffer = generate(num);</span><br><span class="line">63</span><br><span class="line">64        printf (&quot;Random string is: %s\n&quot;,buffer);</span><br><span class="line">65</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list + 行号， 显示行号周围的10行</span></span><br><span class="line"></span><br><span class="line">(gdb) list 10</span><br><span class="line">5       #include &lt;stdint.h&gt;</span><br><span class="line">6       #include &lt;sys/types.h&gt;</span><br><span class="line">7       #include &lt;sys/stat.h&gt;</span><br><span class="line">8       #include &lt;sys/time.h&gt;</span><br><span class="line">9       #include &lt;fcntl.h&gt;</span><br><span class="line">10      #include &lt;unistd.h&gt;</span><br><span class="line">11      #include &lt;pthread.h&gt;</span><br><span class="line">12      #include &lt;sys/ioctl.h&gt;</span><br><span class="line">13      #include &lt;sys/mman.h&gt;</span><br><span class="line">14      #include &lt;sys/sysinfo.h&gt;</span><br><span class="line">(gdb)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list  开始行号，结束行号 ， 显示开始行号 ---》 结束行号的代码</span></span><br><span class="line"></span><br><span class="line">(gdb) list 10, 20</span><br><span class="line">10      #include &lt;unistd.h&gt;</span><br><span class="line">11      #include &lt;pthread.h&gt;</span><br><span class="line">12      #include &lt;sys/ioctl.h&gt;</span><br><span class="line">13      #include &lt;sys/mman.h&gt;</span><br><span class="line">14      #include &lt;sys/sysinfo.h&gt;</span><br><span class="line">15      #include &lt;signal.h&gt;</span><br><span class="line">16</span><br><span class="line">17      int max_length = 128;</span><br><span class="line">18</span><br><span class="line">19      static uint32_t get_rand(uint8_t *a, uint32_t byteLen)</span><br><span class="line">20      &#123;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list -  查看前面那个list命令前的10行</span></span><br><span class="line"></span><br><span class="line">(gdb) list -</span><br><span class="line">1</span><br><span class="line">2       #include &lt;stdio.h&gt;</span><br><span class="line">3       #include &lt;stdlib.h&gt;</span><br><span class="line">4       #include &lt;unistd.h&gt;</span><br><span class="line">5       #include &lt;stdint.h&gt;</span><br><span class="line">6       #include &lt;sys/types.h&gt;</span><br><span class="line">7       #include &lt;sys/stat.h&gt;</span><br><span class="line">8       #include &lt;sys/time.h&gt;</span><br><span class="line">9       #include &lt;fcntl.h&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list 函数名，查看函数附近的10行</span></span><br><span class="line"></span><br><span class="line">(gdb) list  get_rand</span><br><span class="line">15      #include &lt;signal.h&gt;</span><br><span class="line">16</span><br><span class="line">17      int max_length = 128;</span><br><span class="line">18</span><br><span class="line">19      static uint32_t get_rand(uint8_t *a, uint32_t byteLen)</span><br><span class="line">20      &#123;</span><br><span class="line">21          int result = 0;</span><br><span class="line">22          int fd = open(&quot;/dev/urandom&quot;, O_RDONLY);</span><br><span class="line">23          if (fd &lt; 0) &#123;</span><br><span class="line">24                  fd = open(&quot;/dev/random&quot;, O_RDONLY);</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list  文件名：行号  查看指定文件的行号附近10行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list 文件名：函数名 查看指定文件的函数附近10行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>layout命令可以分隔窗口，让我们一边看源码一边调试。</p>
<p>主要有以下几种用法：<br>layout src：显示源代码窗口<br>layout asm：显示汇编窗口<br>layout regs：显示源代码&#x2F;汇编和寄存器窗口<br>layout split：显示源代码和汇编窗口<br>layout next：显示下一个layout<br>layout prev：显示上一个layout<br>Ctrl + L：刷新窗口<br>Ctrl + x，再按1：单窗口模式，显示一个窗口<br>Ctrl + x，再按2：双窗口模式，显示两个窗口</p>
<p>Ctrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。</p>
<p><img src="/images/202310/gdb_layout.png" alt="gdb layout"></p>
<h1 id="其他1"><a href="#其他1" class="headerlink" title="其他1"></a>其他1</h1><p>这段时间在忙一个新项目，项目组只有我一个人在吭哧吭哧的投入，其他人指望不了，工作一两年的那些同事真的没有战斗力。</p>
<p>硅前的工作，使用pld(paladin)环境进行验证，效率还是蛮低的，但是工作量却不少。</p>
<p>去年，做另一个项目的时候，投入了3个人搞了近两个月的时间，到这个项目的时候就我一个人，时间也只给三个月，呵呵，其中的滋味只有自己知道了。</p>
<p>而且工作量可以说比前面那个项目更多了，以前只验证基础的功能，这次还得测试各种不一样的场景及性能，加油吧。</p>
<p>So，忙的博客都没时间搞了，这边已经积累了很多素材了，争取每周末继续总结回顾，活到老学到老啊。</p>
<h1 id="其他2"><a href="#其他2" class="headerlink" title="其他2"></a>其他2</h1><p>本来下半年准备报考系统架构师考试的，昨天才想起来，9月底报名的时间已经错过了，那就准备准备明年的系统分析师吧。</p>
<p>像我这等普通人，真的是没有毅力按计划自觉复习，进度慢而且不成体系，针对这种应试类的考试，就上网报了个班，也许只有花了真金白银了，才能驱使自己去努力了，不然每天的时间其实都是被浪费了。</p>
<p>加油吧，争取明年上半年通过系统分析师，明年下半年再考系统架构师。</p>
<p>在国企里面上班，学历已经落后他人了，虽然有想法想要提升学历，但是考研没有个一年半载的准备，自己肯定是拿不下的。先从职称这方面入手，一步步来，精力毕竟是有限的，各个击破吧。</p>
<p>回想高三那段拼搏的岁月，还是蛮怀念的，累是累，但是结果还是好的，毕竟考上了大学，走出了农村，不再需要如父辈那般干着体力活，为基本的生活而奔波。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（51）- gdb调试多线程</title>
    <url>/2023/11/26/2023-20231126-gdb2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>小结一下多线程下的gdb调试技巧。</p>
<h1 id="多线程gdb调试"><a href="#多线程gdb调试" class="headerlink" title="多线程gdb调试"></a>多线程gdb调试</h1><p>测试程序创建两个线程，每个线程都有一个循环递增数值，同时分别调用sleep。</p>
<span id="more"></span>

<h2 id="线程信息查看"><a href="#线程信息查看" class="headerlink" title="线程信息查看"></a>线程信息查看</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">info threads</span><br><span class="line"></span><br><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id                              Frame</span><br><span class="line">  1    Thread 0x7ffff7faa740 (LWP 2778) &quot;sem&quot; clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:62</span><br><span class="line">* 2    Thread 0x7ffff7bff640 (LWP 2781) &quot;sem&quot; enqueue (arg=0x7fffffffe300) at test_sem.c:48</span><br><span class="line">  3    Thread 0x7ffff73fe640 (LWP 2782) &quot;sem&quot; __sleep (seconds=2) at ../sysdeps/posix/sleep.c:34</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  enqueue (arg=0x7fffffffe300) at test_sem.c:48</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7c94ac3 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff7d26a40 <span class="keyword">in</span> clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个线程有三个ID：</p>
<p>Pthread库为线程分配的pthread ID，也就是用pthread_self()返回的ID, Thread 0x7ffff7faa740<br>Linux kernel为线程分配的thread ID，也就是gettid()返回的ID, LWP 2956<br>GDB为线程分配的ID。执行GDB调试命令时要指定的线程ID，如无特殊说明，都是指的这个ID, 最前面的1，2,3</p>
<p>如上， 带*号表示当前在2号线程， 可以在另外的终端使用ps -eT | grep sem查看线程信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:~# ps -eT | grep sem</span><br><span class="line">   2778    2778 pts/1    00:00:00 sem</span><br><span class="line">   2778    2781 pts/1    00:00:00 sem</span><br><span class="line">   2778    2782 pts/1    00:00:00 sem</span><br><span class="line">root@keep-VirtualBox:~#</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下，执行的GDB命令是针对当前线程。比如此时执行bt(backtrace)命令，获取的是线程2的调用栈</p>
<h2 id="切换当前线程"><a href="#切换当前线程" class="headerlink" title="切换当前线程"></a>切换当前线程</h2><p>thread <thread-id>命令可以切换当前线程，如thread 1把线程1切换为当前线程。</p>
<p>针对指定线程执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) thread 1</span><br><span class="line">[Switching to thread 1 (Thread 0x7ffff7faa740 (LWP 2778))]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:62</span></span><br><span class="line">62      ../sysdeps/unix/sysv/linux/x86_64/clone3.S: 没有那个文件或目录.</span><br><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id                              Frame</span><br><span class="line">* 1    Thread 0x7ffff7faa740 (LWP 2778) &quot;sem&quot; clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:62</span><br><span class="line">  2    Thread 0x7ffff7bff640 (LWP 2781) &quot;sem&quot; enqueue (arg=0x7fffffffe300) at test_sem.c:48</span><br><span class="line">  3    Thread 0x7ffff73fe640 (LWP 2782) &quot;sem&quot; __sleep (seconds=2) at ../sysdeps/posix/sleep.c:34</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:62</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7d26a91 <span class="keyword">in</span> __GI___clone_internal (cl_args=cl_args@entry=0x7fffffffe0b0,</span></span><br><span class="line">    func=func@entry=0x7ffff7c947d0 &lt;start_thread&gt;, arg=arg@entry=0x7ffff73fe640)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/clone-internal.c:54</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff7c946d9 <span class="keyword">in</span> create_thread (pd=pd@entry=0x7ffff73fe640, attr=attr@entry=0x7fffffffe1d0,</span></span><br><span class="line">    stopped_start=stopped_start@entry=0x7fffffffe1ce, stackaddr=stackaddr@entry=0x7ffff6bfe000, stacksize=8388352,</span><br><span class="line">    thread_ran=thread_ran@entry=0x7fffffffe1cf) at ./nptl/pthread_create.c:295</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00007ffff7c95200 <span class="keyword">in</span> __pthread_create_2_1 (newthread=&lt;optimized out&gt;, attr=&lt;optimized out&gt;,</span></span><br><span class="line">    start_routine=&lt;optimized out&gt;, arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:828</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x00005555555554ad <span class="keyword">in</span> main () at test_sem.c:77</span></span><br><span class="line">(gdb)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="在指定线程执行命令"><a href="#在指定线程执行命令" class="headerlink" title="在指定线程执行命令"></a>在指定线程执行命令</h2><p>thread apply [thread-id-list | all] command 可以针对指定线程执行命令</p>
<p>如：<br>thread apply all bt：打印所有线程的调用栈信息<br>thread apply 3 bt：打印线程3的调用栈信息<br>thread apply 2-3 bt：打印线程2和线程3的调用栈信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) thread apply all bt</span><br><span class="line"></span><br><span class="line">Thread 3 (Thread 0x7ffff73fe640 (LWP 2782) &quot;sem&quot;):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  __sleep (seconds=2) at ../sysdeps/posix/sleep.c:34</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00005555555552d9 <span class="keyword">in</span> dequeue (arg=0x7fffffffe300) at test_sem.c:31</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff7c94ac3 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00007ffff7d26a40 <span class="keyword">in</span> clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"></span><br><span class="line">Thread 2 (Thread 0x7ffff7bff640 (LWP 2781) &quot;sem&quot;):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  enqueue (arg=0x7fffffffe300) at test_sem.c:48</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7c94ac3 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff7d26a40 <span class="keyword">in</span> clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"></span><br><span class="line">Thread 1 (Thread 0x7ffff7faa740 (LWP 2778) &quot;sem&quot;):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:62</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7d26a91 <span class="keyword">in</span> __GI___clone_internal (cl_args=cl_args@entry=0x7fffffffe0b0, func=func@entry=0x7ffff7c947d0 &lt;start_thread&gt;, arg=arg@entry=0x7ffff73fe640) at ../sysdeps/unix/sysv/linux/clone-internal.c:54</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff7c946d9 <span class="keyword">in</span> create_thread (pd=pd@entry=0x7ffff73fe640, attr=attr@entry=0x7fffffffe1d0, stopped_start=stopped_start@entry=0x7fffffffe1ce, stackaddr=stackaddr@entry=0x7ffff6bfe000, stacksize=8388352, thread_ran=thread_ran@entry=0x7fffffffe1cf) at ./nptl/pthread_create.c:295</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00007ffff7c95200 <span class="keyword">in</span> __pthread_create_2_1 (newthread=&lt;optimized out&gt;, attr=&lt;optimized out&gt;, start_routine=&lt;optimized out&gt;, arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:828</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x00005555555554ad <span class="keyword">in</span> main () at test_sem.c:77</span></span><br><span class="line">(gdb)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="在特定线程设置断点"><a href="#在特定线程设置断点" class="headerlink" title="在特定线程设置断点"></a>在特定线程设置断点</h2><p>break <location>  # 在<location>设置断点，并对所有线程生效<br>break <location> thread <thread-id> # 在<location>设置断点，仅对<thread-id>指定的线程生效<br>break <location> thread <thread-id> if <condition> # 在<location>设置条件断点断点，仅对<thread-id>指定的线程生效</p>
<h2 id="控制线程创建和退出信息"><a href="#控制线程创建和退出信息" class="headerlink" title="控制线程创建和退出信息"></a>控制线程创建和退出信息</h2><p>gdb的时候，默认创建和退出线程会打印信息。 可以通过命令关闭该打印。</p>
<p>set print thread-events on&#x2F;off</p>
<h2 id="命令缩写"><a href="#命令缩写" class="headerlink" title="命令缩写"></a>命令缩写</h2><p>taas command 相当于 thread apply all -s command<br>tfaas command 相当于 thread apply all -s – frame apply all -s command </p>
<p>tfaas这个命令非常有用。比如，有时我们只记得一个变量或参数的名字，却忘了或不知道它是在哪个具体的函数中，就可以用这个命令：tfaas p var_name，这个命令会搜索所有线程的调用栈，找到名字为var_name的变量，并打印它的值，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) tfaas p enq</span><br><span class="line"></span><br><span class="line">Thread 1 (Thread 0x7ffff7faa740 (LWP 2956) &quot;sem&quot;):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x0000555555555499 <span class="keyword">in</span> main () at test_sem.c:93</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 140737349940800</span></span><br><span class="line">(gdb)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="控制程序执行的两种模式"><a href="#控制程序执行的两种模式" class="headerlink" title="控制程序执行的两种模式"></a>控制程序执行的两种模式</h2><p>为了更好的调试多线程程序，GDB提供了两种模式来控制程序的执行：</p>
<p>All-Stop Mode：在该模式下，不管因为什么原因，一个线程被中断执行，其他所有的线程都会同时被中断执行。<br>Non-Stop Mode：在该模式下，一个线程被中断执行，不会影响其他线程的正常执行。</p>
<h3 id="All-Stop-Mode"><a href="#All-Stop-Mode" class="headerlink" title="All-Stop Mode"></a>All-Stop Mode</h3><p>默认处于All-Stop Mode。这也给程序调试带来了一些困难，比如，无法100%精确地进行单步调试。有时你会发现，在执行step命令之后，程序却停在了另外一个线程中。</p>
<p>可以通过命令 set scheduler-locking mode来锁定线程模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mode</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">off  -- 不锁定线程，恢复时所有线程继续执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on  -- 锁定当前线程，执行<span class="built_in">continue</span>， step， next， finish等命令后，只有当前线程继续执行，其他线程还是停止状态</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">step -- 只有step时，当前线程 继续执行，其他线程还是停止状态。 其他命令 所有线程都会恢复执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">replay -- 反向调试时， 当前线程执行，其他线程停止</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) show scheduler-locking</span><br><span class="line">Mode for locking scheduler during execution is &quot;replay&quot;.</span><br><span class="line">(gdb) set schedule-l</span><br><span class="line">Display all 150 possibilities? (y or n)</span><br><span class="line">(gdb) set schedule-lock</span><br><span class="line">lock              lock_fd           locked_map_ptr    locked_vfxprintf  lockf             lockf64</span><br><span class="line">(gdb) set schedule-lock</span><br><span class="line">lock              lock_fd           locked_map_ptr    locked_vfxprintf  lockf             lockf64</span><br><span class="line">(gdb) set schedule-lock</span><br><span class="line">Display all 200 possibilities? (y or n)</span><br><span class="line">(gdb) set scheduler-locking on</span><br><span class="line">(gdb) show scheduler-locking</span><br><span class="line">Mode for locking scheduler during execution is &quot;on&quot;.</span><br><span class="line">(gdb)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Non-Stop-Mode"><a href="#Non-Stop-Mode" class="headerlink" title="Non-Stop Mode"></a>Non-Stop Mode</h3><p>在Non-Stop模式下，一个线程被中断执行，并不会影响到其他线程。比如，一个线程触发断点，只有这一个线程会被中断执行，其余线程不受影响继续执行。同样的，在程序运行时，执行Ctrl+C，也只会中断一个线程。</p>
<p>开启Non-stop Mode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set pagination off</span><br><span class="line">set non-stop on</span><br><span class="line"></span><br><span class="line">set non-stop off # 恢复 All-stop模式</span><br><span class="line"></span><br><span class="line">show non-stop</span><br><span class="line"></span><br><span class="line">(gdb) set non-stop on</span><br><span class="line">(gdb) show non-stop</span><br><span class="line">Controlling the inferior in non-stop mode is on.</span><br><span class="line">(gdb) b enqueue</span><br><span class="line">Breakpoint 1 at 0x138d: file test_sem.c, line 48.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /media/VM_SHARE/code/blog_code/condition/sem</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">[New Thread 0x7ffff7bff640 (LWP 2930)]</span><br><span class="line">[New Thread 0x7ffff73fe640 (LWP 2931)]</span><br><span class="line"></span><br><span class="line">Thread 2 &quot;sem&quot; hit Breakpoint 1, enqueue (arg=0x7fffffffe300) at test_sem.c:48</span><br><span class="line">48              thrd_args_t *thrd_args = (thrd_args_t *)arg;</span><br><span class="line">(gdb) set print thread-events off</span><br><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id                              Frame</span><br><span class="line">* 1    Thread 0x7ffff7faa740 (LWP 2927) &quot;sem&quot; (running)</span><br><span class="line">  2    Thread 0x7ffff7bff640 (LWP 2930) &quot;sem&quot; enqueue (arg=0x7fffffffe300) at test_sem.c:48</span><br><span class="line">  3    Thread 0x7ffff73fe640 (LWP 2931) &quot;sem&quot; (running)</span><br><span class="line">(gdb)</span><br><span class="line">(gdb) interrupt -a</span><br><span class="line">(gdb)</span><br><span class="line">Thread 3 &quot;sem&quot; stopped.</span><br><span class="line">0x00007ffff7ce57f8 in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7ffff73fddf0, rem=rem@entry=0x7ffff73fddf0) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78</span><br><span class="line">78      ../sysdeps/unix/sysv/linux/clock_nanosleep.c: 没有那个文件或目录.</span><br><span class="line"></span><br><span class="line">Thread 1 &quot;sem&quot; stopped.</span><br><span class="line">__futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, expected=2930, futex_word=0x7ffff7bff910) at ./nptl/futex-internal.c:57</span><br><span class="line">57      ./nptl/futex-internal.c: 没有那个文件或目录.</span><br><span class="line">info threads</span><br><span class="line">  Id   Target Id                              Frame</span><br><span class="line">* 1    Thread 0x7ffff7faa740 (LWP 2927) &quot;sem&quot; __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265,</span><br><span class="line">    expected=2930, futex_word=0x7ffff7bff910) at ./nptl/futex-internal.c:57</span><br><span class="line">  2    Thread 0x7ffff7bff640 (LWP 2930) &quot;sem&quot; enqueue (arg=0x7fffffffe300) at test_sem.c:48</span><br><span class="line">  3    Thread 0x7ffff73fe640 (LWP 2931) &quot;sem&quot; 0x00007ffff7ce57f8 in __GI___clock_nanosleep (clock_id=clock_id@entry=0,</span><br><span class="line">    flags=flags@entry=0, req=req@entry=0x7ffff73fddf0, rem=rem@entry=0x7ffff73fddf0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78</span><br><span class="line">(gdb)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到执行到断点函数enqueue时， 只有线程2停止，线程1， 3还在执行</p>
<p>interrupt -a命令可以中断所有线程的执行。</p>
<h2 id="命令后台执行"><a href="#命令后台执行" class="headerlink" title="命令后台执行"></a>命令后台执行</h2><p>像shell命令一样，后面加一个&amp;符号，可以把程序放在后台执行。在GDB中同样可以在命令后面加一个&amp;符号，这样就能把命令放在后台执行。这样子，gdb就可以继续接收命令，比如我们可以run &amp;, 然后interrupt 中断线程，继续查看线程状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) c&amp;</span><br><span class="line">Continuing.</span><br><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id                              Frame</span><br><span class="line">* 1    Thread 0x7ffff7faa740 (LWP 2927) &quot;sem&quot; (running)</span><br><span class="line">  2    Thread 0x7ffff7bff640 (LWP 2930) &quot;sem&quot; enqueue (arg=0x7fffffffe300) at test_sem.c:48</span><br><span class="line">  3    Thread 0x7ffff73fe640 (LWP 2931) &quot;sem&quot; 0x00007ffff7ce57f8 in __GI___clock_nanosleep (clock_id=clock_id@entry=0,</span><br><span class="line">    flags=flags@entry=0, req=req@entry=0x7ffff73fddf0, rem=rem@entry=0x7ffff73fddf0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78</span><br><span class="line">(gdb) thread apply all bt</span><br><span class="line"></span><br><span class="line">Thread 3 (Thread 0x7ffff73fe640 (LWP 2931) &quot;sem&quot;):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007ffff7ce57f8 <span class="keyword">in</span> __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7ffff73fddf0, rem=rem@entry=0x7ffff73fddf0) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7cea677 <span class="keyword">in</span> __GI___nanosleep (req=req@entry=0x7ffff73fddf0, rem=rem@entry=0x7ffff73fddf0) at ../sysdeps/unix/sysv/linux/nanosleep.c:25</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff7cea5ae <span class="keyword">in</span> __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00005555555552d9 <span class="keyword">in</span> dequeue (arg=0x7fffffffe300) at test_sem.c:31</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x00007ffff7c94ac3 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x00007ffff7d26a40 <span class="keyword">in</span> clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"></span><br><span class="line">Thread 2 (Thread 0x7ffff7bff640 (LWP 2930) &quot;sem&quot;):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  __sleep (seconds=1) at ../sysdeps/posix/sleep.c:34</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00005555555553b5 <span class="keyword">in</span> enqueue (arg=0x7fffffffe300) at test_sem.c:52</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff7c94ac3 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00007ffff7d26a40 <span class="keyword">in</span> clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span></span><br><span class="line"></span><br><span class="line">Thread 1 (Thread 0x7ffff7faa740 (LWP 2927) &quot;sem&quot;):</span><br><span class="line">Selected thread is running.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这个文章主要就是记录一些命令的使用，后续便于查找。很多时候我们用过或者看过一些命令，知道有这个东西，但是就是想不起来怎么用了，那么写博文就可以帮助到我们。</p>
<p>测试程序代码路径： <a href="https://gitee.com/fishmwei/blog_code/blob/master/gdb/test_sem.c">https://gitee.com/fishmwei/blog_code/blob/master/gdb/test_sem.c</a></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（51）- DMA问题定位小结</title>
    <url>/2023/12/02/2023-20231202-dma/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目上出了个比较重大的bug，驱动注册的时候会偶发挂死、计算结果不正确，而且在不同内核版本，不同PAGE_SIZE下还表现不一样。<br>鉴于有合作方已经在使用了我们的驱动了，问题等级就上升了。项目组的小妹搞了快1个半月了，依然没有任何头绪，期间组内也组织过一次代码评审，都没有看出啥问题。<br>最后我就临时被拉去救火了，其他的工作全部暂停。<br>目前大部分问题已经定位解决，除了异常分支错误处理外，其他就是DMA-API的滥用了。</p>
<span id="more"></span>

<h1 id="DMA-API"><a href="#DMA-API" class="headerlink" title="DMA-API"></a>DMA-API</h1><p>关于DMA映射API的使用在去年八月份有写过一篇文章介绍<a href="https://fishmwei.github.io/2022/08/27/dma-weekly/">周谈(34)-DMA地址映射api使用</a>，文章是刚接触DMA学习后的小结，只是对API函数及概念有了基础的理解，这次是遇到事儿，再看一遍内核的Document，就有不同的看法了。</p>
<p>带着问题去学习目的是比较明确的，在看API接口的同时会有更多的理解，下面简要地讲下遇到的问题及以后需要注意的点。</p>
<h2 id="一致性和流式DMA"><a href="#一致性和流式DMA" class="headerlink" title="一致性和流式DMA"></a>一致性和流式DMA</h2><p>DMA分为两种，一致性DMA和流式DMA。</p>
<p>前者使用的是带coherent的API，不需要开发者关心内存的一致性，系统会自动进行同步（但是你需要保证buffer在被设备读取时已经flush了？没太看懂这个说法？），申请时一般至少以页为单位，即使你申请小于1页，内部也会占用一个页的空间，一般在驱动注册时申请，卸载后注销，使用的生命周期比较长一些。</p>
<p>流式DMA，则是通过已有的内存进行映射，使用完后再注销，最后才释放内存。流式DMA需要开发者关注内存的DMA方向，一旦进行映射后，理论上这块内存就属于设备的了，如果在注销映射之前CPU要访问这块内存，需要调用XXX_for_cpu的接口获取该内存的所有权，xxx_for_cpu接口根据传入的direction参数，会进行数据的同步，如果是DMA_FROM_DEVICE，那么会把数据从设备端同步到内存，并无效掉对应的CACHE，这样CPU访问的内容就是设备返回的内容了。如果是DMA_TO_DEVICE，那么CPU就可以往该内存写入数据。CPU访问结束后，再通过xxx_for_device接口把内存的所有权还给设备，设备就可以使用修改后的内存了。如果xxx_for_cpu方向为DMA_FROM_DEVICE，那么写入内存的地址是无法同步到设备端的，这个要特别注意。</p>
<h2 id="工具接口"><a href="#工具接口" class="headerlink" title="工具接口"></a>工具接口</h2><p><code>dma_max_mapping_size</code>会返回映射API接口支持的最大内存长度，一般为0xffffffff；<br><code>dma_need_sync</code>返回一个dma地址是否需要调用xxx_for_cpu&#x2F;device修改内存权限，奇怪的是即使你调用的是xxx_coherent接口申请的地址，返回的也是true；<br><code>dma_get_merge_boundary</code>返回DMA合并的边界，这个也没太搞懂，默认为PAGE_SIZE-1，当dma_map_sg的sglist大小超过boundary时，开启dma api debug时会报错误；<br><code>dma_get_max_seg_size</code>获取dma_map_sg支持的segment的最大长度，默认返回64k；<br><code>dma_mapping_error</code>用于判断返回的地址是否合法，当我们开启了DMA-API DEBUG功能时，如果某个地址没有调用该API接口判断，那么在注销映射的时候将会有警告调用栈输出；<br><code>dma_get_cache_alignment</code>返回处理器的缓存对齐，处理mapping后的内存需要以该大小对齐进行处理，可能返回的值大于实际的缓存行，基于此后续进行mapping的地址最好都是CACHELIEN对齐的，长度至少是CACHELINE大小。</p>
<h2 id="dma-map-sg"><a href="#dma-map-sg" class="headerlink" title="dma_map_sg"></a>dma_map_sg</h2><p>这个接口用来映射scatterlist的，使用方式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i, count = dma_map_sg(dev, sglist, nents, direction);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">sg</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_sg(sglist, sg, count, i) &#123;</span><br><span class="line">	hw_address[i] = sg_dma_address(sg);</span><br><span class="line">	hw_len[i] = sg_dma_len(sg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数nents为sglist的段数，返回count可能小于nents，因为接口内部会合并相邻物理地址连续的段，需要注意的是，经过dma_map_sg后，我们需要使用sg_dma_address， sg_dma_len接口获取地址的值及长度。失败的话，count返回值为0。相应的注销时调用dma_unmap_sg， 参数必须和映射时一致。</p>
<h2 id="dma-api-debug"><a href="#dma-api-debug" class="headerlink" title="dma api debug"></a>dma api debug</h2><p>dma-api有许多限制，随着硬件IOMMU的出现，驱动程序变得越来越重要不要违反这些限制，任意一个地方违法了就会导致系统挂掉。开启DMA API debug功能，可以帮助开发者查找隐藏的bug，在编译内核的时候，在kernel configuration中勾选 “Enable debugging of DMA-API usage”。</p>
<p>通过开启了DMA API debug后，我也是找到了许多问题了的。dma api debug还通过debugfs暴露了一些接口用于调试定位。</p>
<p>默认情况只会输出一个错误&#x2F;警告信息，其他错误只会计数不输出， 这样可以防止内核信息泛滥，可以通过debugfs过滤指定的驱动，并配置相应的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dma-api/all_errors 只要不为<span class="number">0</span>，就会打印错误调用栈</span><br><span class="line"></span><br><span class="line">dma-api/disabled 指示当前debug功能是否禁用了，一般只有内存耗尽或者启动时禁用时为<span class="number">1</span></span><br><span class="line"></span><br><span class="line">dma-api/dump 显示当前所有的内存映射</span><br><span class="line"></span><br><span class="line">dma-api/error_count	显示总的错误数</span><br><span class="line"></span><br><span class="line">dma-api/num_errors 设置最多打印的错误数目默认是<span class="number">1</span> </span><br><span class="line"></span><br><span class="line">dma-api/min_free_entrie 为<span class="number">0</span>时会继续申请entry</span><br><span class="line"></span><br><span class="line">dma-api/num_free_entries <span class="built_in">free</span>的entry数</span><br><span class="line"></span><br><span class="line">dma-api/nr_total_entries 已申请的entry数，包含<span class="built_in">free</span>、used</span><br><span class="line"></span><br><span class="line">dma-api/driver_filter 可以用于指定驱动， 比如要调试test.ko, 则echo test&gt;/sys/kernel/debug/dma-api/driver_filter，那么前面的计数也都只针对这个驱动了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="遇到的问题回顾"><a href="#遇到的问题回顾" class="headerlink" title="遇到的问题回顾"></a>遇到的问题回顾</h2><ol>
<li><p>IOMMU报物理地址错误，但是那个地址其实已经释放掉了，理论上不会再用到的。这个主要是同步内存给设备的时候，代码都是按64字节大小依次同步的，每个队列有一片缓冲区用于下发命令给设备，每次都最后一段时，错误就发生了。需要扩充缓冲区的大小，最后一片64字节其实也是按dma_get_cache_alignment即128字节同步的，最后64字节长度不足128字节，同步就异常了，再往后扩个64字节问题就解决了。</p>
</li>
<li><p>结果报wrong result，这个主要就是在内存mapping之后，没有调用xxx_for_cpu就去更新内存，导致最终内容没有同步到设备，设备使用的数据是错误的。还有一种情况，就是dma_map_single的内存不是cacheline对齐的，这个通过在相应的结构体中使用____cacheline_aligned定义，使该成员的首地址是cacheline对齐的。</p>
</li>
<li><p>umap的时候报错，这个主要是映射后地址没有调用dma_mapping_error接口检查导致的。</p>
</li>
<li><p>挂死问题，这个是由于使用的是sg-&gt;length而不是sg_dma_len函数获取映射后的长度，最终导致地址访问越界。</p>
</li>
<li><p>其他就是特殊的异常分支处理的问题了。</p>
</li>
</ol>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>其实问题也就几类，但是架不住文件多啊，而且先前是两三个人协作写的代码，大家便于调试，很多本可以合并的代码都是重复存在了好几处，改起来也是累，最后花时间重构了一部分代码，代码行数都少了3000多行。剩余的代码交给另外一个同事改的，能解决问题就ok了，等有空再去重构吧。</p>
<p>中间遇到一部分新员工解bug的代码，各种if else判断，遇到问题解决问题，补丁一大堆，剪不断理还乱的，各种条件写的莫名其妙，调试起来还是一堆错。无奈，又花了三四天琢磨算法标准，解决异常处理问题。</p>
<p>这个救火任务前后也花了我一个月左右，终于要告一段落。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（53）- clang-format代码格式化配置</title>
    <url>/2024/03/23/2024-20240323-clang-format/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>组内代码格式不统一，每当我review的时候，总发现各种规范问题，比如代码行缩进不一致， 操作数和运算符之间空格时有时无，对于代码洁癖的人这是很难忍受。<br>那么就只能用工具了，鉴于Windows下编码大部分时候使用vscode，所以就找到了clang-format插件，而且在Linux下clang-format还可以集成到git hook里。</p>
<p>我抽空研究了一下，然后形成配置文档，让组里的同事照着配置一下。</p>
<span id="more"></span>

<p>下面描述了在windows下vscode+clang-format和linux下git+clang-format的配置，记录以供后续查询，也可以跟大家交流一下。</p>
<h2 id="vscode下配置clang-format"><a href="#vscode下配置clang-format" class="headerlink" title="vscode下配置clang-format"></a>vscode下配置clang-format</h2><p>以下在Windows环境下配置。</p>
<h3 id="1-进行插件安装，查找clang-format，选择安装人数比较多的那个"><a href="#1-进行插件安装，查找clang-format，选择安装人数比较多的那个" class="headerlink" title="1. 进行插件安装，查找clang-format，选择安装人数比较多的那个"></a>1. 进行插件安装，查找clang-format，选择安装人数比较多的那个</h3><p><img src="/images/202403/vscode_clang_format.png" alt="vscode_clang_format"></p>
<h3 id="2-下载LLVM-17-0-6-win64并安装"><a href="#2-下载LLVM-17-0-6-win64并安装" class="headerlink" title="2. 下载LLVM-17.0.6-win64并安装"></a>2. 下载LLVM-17.0.6-win64并安装</h3><p>LLVM自带clang-format.exe， 我选择安装到d:\Program Files\LLVM目录。</p>
<p>LLVM文件大小为332MB, 下载比较慢，可以从我分享的百度网盘下载(目前还是有效的)：<br>链接: <a href="https://pan.baidu.com/s/1Q8ntN13JlPHdaJJt9Cdm_g?pwd=smvd">https://pan.baidu.com/s/1Q8ntN13JlPHdaJJt9Cdm_g?pwd=smvd</a> 提取码: smvd</p>
<h3 id="3-创建-clang-format规则文件"><a href="#3-创建-clang-format规则文件" class="headerlink" title="3. 创建.clang-format规则文件"></a>3. 创建.clang-format规则文件</h3><p>规则内容则是从linux-6.1拷贝过来，在linux内核源码根目录下有一个.clang-format文件，仅将行数修改为120行。</p>
<p><img src="/images/202403/clang_format_rule.png" alt="clang_format_rule"></p>
<p>保存路径为D:\Program Files\LLVM\clang-format.txt</p>
<h3 id="4-配置扩展插件"><a href="#4-配置扩展插件" class="headerlink" title="4. 配置扩展插件"></a>4. 配置扩展插件</h3><p>Vscode 文件-&gt;首选项-&gt;设置-&gt;扩展-&gt;Clang-Format configuration ：</p>
<p>主要是选择Executalbe为 clang-format，Fallback Style LLVM, 还有就是Style的路径配置为D:\Program Files\LLVM\clang-format.txt。</p>
<p><img src="/images/202403/clang_format_cfg1.png" alt="clang_format_cfg1"></p>
<p><img src="/images/202403/clang_format_cfg2.png" alt="clang_format_cfg2"></p>
<p>好了，这样每次保存C语言文件时，就会自动格式化代码了。</p>
<h2 id="git-commit-自动调用clang-format格式化提交的代码文件"><a href="#git-commit-自动调用clang-format格式化提交的代码文件" class="headerlink" title="git commit 自动调用clang-format格式化提交的代码文件"></a>git commit 自动调用clang-format格式化提交的代码文件</h2><p>以下在Ubuntu环境下配置。</p>
<h3 id="1-安装clang-format工具"><a href="#1-安装clang-format工具" class="headerlink" title="1. 安装clang-format工具"></a>1. 安装clang-format工具</h3><p>执行命令安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install clang-format </span><br></pre></td></tr></table></figure>

<h3 id="2-配置-clang-format规则文件"><a href="#2-配置-clang-format规则文件" class="headerlink" title="2. 配置.clang-format规则文件"></a>2. 配置.clang-format规则文件</h3><p>从linux 6.1 根目录下.clang-format拷贝而来，删除了2行不支持的规则，行数修改为120行，放到工程根目录下，命名为.clang-format。</p>
<p>下面是.clang-format的一个链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/.clang-format</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-配置git提交格式化脚本"><a href="#3-配置git提交格式化脚本" class="headerlink" title="3. 配置git提交格式化脚本"></a>3. 配置git提交格式化脚本</h3><p>将下面内容保存到你的工程的.git&#x2F;hooks&#x2F;pre-commit 文件中，记得chmod +x pre-commit。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">STYLE=$(git config --get hooks.clangformat.style)</span><br><span class="line">if [ -n &quot;$&#123;STYLE&#125;&quot; ] ; then</span><br><span class="line">  STYLEARG=&quot;-style=$&#123;STYLE&#125;&quot;</span><br><span class="line">else</span><br><span class="line">  STYLEARG=&quot;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">format_file() &#123;</span><br><span class="line">  file=&quot;$&#123;1&#125;&quot;</span><br><span class="line">  if [ -f $file ]; then</span><br><span class="line">    clang-format -i $&#123;STYLEARG&#125; $&#123;1&#125;</span><br><span class="line">    echo &quot;clang-format  $&#123;STYLEARG&#125; -i $&#123;1&#125;&quot;</span><br><span class="line">    git add $&#123;1&#125;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$&#123;1&#125;&quot; in</span><br><span class="line">  --about )</span><br><span class="line">    echo &quot;Runs clang-format on source files&quot;</span><br><span class="line">    ;;</span><br><span class="line">  * )</span><br><span class="line">    for file in `git diff-index --cached --name-only HEAD | grep -iE &#x27;\.(c|cpp|cc|h|hpp)$&#x27; ` ; do</span><br><span class="line">      format_file &quot;$&#123;file&#125;&quot;</span><br><span class="line">    done</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>git commit时的效果如下：</p>
<p><img src="/images/202403/git_clang_format.png" alt="git_clang_format"></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（54）- sysfs属性文件使用</title>
    <url>/2024/04/04/2024-20240404-sysfs/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看华为加速引擎KAE的源码，该库通过sysfs文件将设备驱动的一些信息导出到用户态，在用户态代码中通过访问&#x2F;sys下的文件，获取或者操作加速引擎，而不是使用ioctl的方式。抽空看看内核文档，了解一下sysfs的系统使用及编程。</p>
<span id="more"></span>

<h1 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h1><p>sysfs是一个导出内核对象的文件系统。sysfs是基于ramfs的一个内存文件系统。为用户态提供了一种访问内核数据和属性的方式。</p>
<p>sysfs始终与kobject的底层结构紧密相关。要深入理解的话，还需要了解kobject。</p>
<h2 id="使用sysfs"><a href="#使用sysfs" class="headerlink" title="使用sysfs"></a>使用sysfs</h2><p>内核是否编译了sysfs可以通过是否定义宏CONFIG_SYSFS来确定。<br>一旦有 kobject 在系统中注册，就会有一个目录在sysfs中被创建。这个目录是作为 kobject 的 parent 下的子目录创建的，以准确的传递内核的对象层次到用户空间。比如我们使用class_create创建了一个class，那么对应&#x2F;sys&#x2F;class下就会增加一个文件夹，sysfs中的顶层目录代表着内核对象层次的共同祖先；</p>
<p>kobject 的属性能在文件系统中以普通文件的形式导出，Sysfs 为属性定义了面向文件 I&#x2F;O 操作的方法，以提供对内核属性的读写。属性应为ASCII 码文本文件，以一个文件只存储一个属性值为宜，也可以存一个数组。</p>
<p>后面主要说一下属性的编程使用，属性文件可以方便内核数据的查看及操作。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>驱动子系统定义了设备的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>	<span class="title">attr</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">		    <span class="type">char</span> *buf);</span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">		    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>;</span><br><span class="line">   <span class="type">void</span> <span class="title function_">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_ATTR_RW(_name) \</span></span><br><span class="line"><span class="meta">struct device_attribute dev_attr_##_name = __ATTR_RW(_name)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_ATTR_RO(_name) \</span></span><br><span class="line"><span class="meta">struct device_attribute dev_attr_##_name = __ATTR_RO(_name)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_ATTR_WO(_name) \</span></span><br><span class="line"><span class="meta">struct device_attribute dev_attr_##_name = __ATTR_WO(_name)</span></span><br></pre></td></tr></table></figure>

<p>通过宏定义可以很方便的设置一个属性，然后实现对应的xxx_show, xxx_store函数，再通过device_create_file创建属性文件，这个文件默认位于&#x2F;sys&#x2F;class&#x2F;xxx_class&#x2F;xxx&#x2F;目录下， xxx位设备名。<br>相应的我们会创建&#x2F;dev&#x2F;xxx字符设备。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>在struct device下有一个groups成员，可以把属性文件聚合成多个组，创建组对应的目录，目录下生成各个属性的文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">dev_state_show</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test_dev</span> *<span class="title">testdev</span> =</span> dev_get_drvdata(dev);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;dev_state %lu\n&quot;</span>, testdev-&gt;dev_state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">dev_state_store</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test_dev</span> *<span class="title">testdev</span> =</span> dev_get_drvdata(dev);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;dev_state store buf: %s, count %lu\r\n&quot;</span>, buf, count);</span><br><span class="line">	<span class="keyword">if</span> (kstrtoul(buf, <span class="number">0</span>, &amp;val) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	testdev-&gt;dev_state = val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR_RW</span><span class="params">(dev_state)</span>;</span><br><span class="line"><span class="comment">/* 属性数组 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">test_dev_attrs</span>[] =</span> &#123;</span><br><span class="line">	&amp;dev_attr_id.attr,</span><br><span class="line">	&amp;dev_attr_dev_state.attr,</span><br><span class="line">	&amp;dev_attr_api_ver.attr,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*包装后的属性组*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">test_dev_attr_group</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;attrs&quot;</span>,</span><br><span class="line">	.attrs = test_dev_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多个属性组*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> *<span class="title">test_dev_attr_groups</span>[] =</span> &#123; &amp;test_dev_attr_group, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_create_chrdev</span><span class="params">(<span class="keyword">struct</span> test_dev *testdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = idr_alloc(&amp;test_idr, testdev, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;testdev-&gt;cdev, &amp;testdev_fops);</span><br><span class="line">	testdev-&gt;dev_id = ret;</span><br><span class="line">	testdev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">	device_initialize(&amp;testdev-&gt;dev);</span><br><span class="line">	testdev-&gt;dev.devt = MKDEV(MAJOR(test_devt), testdev-&gt;dev_id);</span><br><span class="line">	testdev-&gt;dev.class = test_class; </span><br><span class="line">	testdev-&gt;dev.groups = test_dev_attr_groups; </span><br><span class="line">	testdev-&gt;dev.release = test_dev_release; </span><br><span class="line">	dev_set_name(&amp;testdev-&gt;dev, <span class="string">&quot;%s&quot;</span>, testdev-&gt;name);</span><br><span class="line">	dev_set_drvdata(&amp;testdev-&gt;dev, testdev);</span><br><span class="line">	ret = cdev_device_add(&amp;testdev-&gt;cdev, &amp;testdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_with_idr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// device_create_file(&amp;testdev-&gt;dev, &amp;dev_attr_dev_state);</span></span><br><span class="line">	dev_dbg(&amp;testdev-&gt;dev, <span class="string">&quot;create testdev minior=%d\n&quot;</span>, testdev-&gt;dev_id);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_with_idr:</span><br><span class="line">	idr_remove(&amp;test_idr, testdev-&gt;dev_id);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动安装后，生成对应的结构</span></span><br><span class="line"></span><br><span class="line">root@Ubuntu:<span class="meta"># tree /sys/class/test/testdev/</span></span><br><span class="line">/sys/<span class="class"><span class="keyword">class</span>/<span class="title">test</span>/<span class="title">testdev</span>/</span></span><br><span class="line"><span class="class">|-- <span class="title">attrs</span>  // 属性组</span></span><br><span class="line"><span class="class">|   |-- <span class="title">api_ver</span></span></span><br><span class="line"><span class="class">|   |-- <span class="title">dev_state</span>  // <span class="title">dev_state</span>属性文件</span></span><br><span class="line"><span class="class">|   `-- <span class="title">id</span></span></span><br><span class="line"><span class="class">|-- <span class="title">dev</span></span></span><br><span class="line"><span class="class">|-- <span class="title">power</span></span></span><br><span class="line"><span class="class">|   |-- <span class="title">async</span></span></span><br><span class="line"><span class="class">|   |-- <span class="title">autosuspend_delay_ms</span></span></span><br><span class="line"><span class="class">|   |-- <span class="title">control</span></span></span><br><span class="line"><span class="class">|   |-- <span class="title">runtime_active_kids</span></span></span><br><span class="line"><span class="class">|   |-- <span class="title">runtime_active_time</span></span></span><br><span class="line"><span class="class">|   |-- <span class="title">runtime_enabled</span></span></span><br><span class="line"><span class="class">|   |-- <span class="title">runtime_status</span></span></span><br><span class="line"><span class="class">|   |-- <span class="title">runtime_suspended_time</span></span></span><br><span class="line"><span class="class">|   `-- <span class="title">runtime_usage</span></span></span><br><span class="line"><span class="class">|-- <span class="title">subsystem</span> -&gt;</span> ../../../../<span class="class"><span class="keyword">class</span>/<span class="title">test</span></span></span><br><span class="line"><span class="class">`-- <span class="title">uevent</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">root</span>@<span class="title">Ubuntu</span>:</span>/sys/<span class="class"><span class="keyword">class</span>/<span class="title">test</span>/<span class="title">testdev</span># <span class="title">cat</span> <span class="title">attrs</span>/<span class="title">dev_state</span></span></span><br><span class="line"><span class="class"><span class="title">dev_state</span> 0</span></span><br><span class="line"><span class="class"><span class="title">root</span>@<span class="title">Ubuntu</span>:</span>/sys/<span class="class"><span class="keyword">class</span>/<span class="title">test</span>/<span class="title">testdev</span># <span class="title">echo</span> 10 &gt;</span> attrs/dev_state</span><br><span class="line">root@Ubuntu:/sys/<span class="class"><span class="keyword">class</span>/<span class="title">test</span>/<span class="title">testdev</span># [ 6793.317838] <span class="title">dev_state</span> <span class="title">store</span> <span class="title">buf</span>:</span> <span class="number">10</span></span><br><span class="line">               , count <span class="number">3</span></span><br><span class="line"></span><br><span class="line">root@Ubuntu:/sys/<span class="class"><span class="keyword">class</span>/<span class="title">test</span>/<span class="title">testdev</span># <span class="title">cat</span> <span class="title">attrs</span>/<span class="title">dev_state</span></span></span><br><span class="line"><span class="class"><span class="title">dev_state</span> 10</span></span><br><span class="line"><span class="class"><span class="title">root</span>@<span class="title">Ubuntu</span>:</span>/sys/<span class="class"><span class="keyword">class</span>/<span class="title">test</span>/<span class="title">testdev</span>#</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p>完整代码见链接文件：</p>
<p><a href="https://gitee.com/fishmwei/blog_code/blob/master/linux-kernel/chrdev/chrdev.c">https://gitee.com/fishmwei/blog_code/blob/master/linux-kernel/chrdev/chrdev.c</a></p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>又是一个充实的一天，早上八点起床就在刷系分的在线视频，上次写了个论文不及格，好好构思准备再写一遍。</p>
<p>下午休息，带娃去看个电影，回来后倒头睡一觉。然后开始看sysfs，写个blog。</p>
<p>清明节假期给自己的安排也是满满的，太多知识空白需要填补了，循序渐进吧！</p>
<p>相信有付出就会有收获！</p>
<p><img src="/images/202403/enroll_success.png" alt="enroll_success"></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（54）- DPDK dmadev lib学习</title>
    <url>/2024/03/31/2024-20240331-dmadev/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>dmadev lib顾名思义就是用来使用dma设备的框架，伴随着摩尔定律的失效，现在CPU的性能几乎很难进行提升了。那么提高性能的方式就只能是软件不够硬件来凑了，让许多工作从CPU卸载到硬件去。<br>dmadev lib库是DPDK中的一个软件库，提供管理和配置DMA poll mode drivers的软件，定义了统一的操作接口。支持一系列不同的DMA操作。</p>
<span id="more"></span>

<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><h2 id="设计约束"><a href="#设计约束" class="headerlink" title="设计约束"></a>设计约束</h2><p>库支持物理的（硬件）和虚拟的（软件）DMA设备。</p>
<p><img src="/images/202403/dmadev_arch.png" alt="dmadev_arch"></p>
<p>DMA框架的组成如上图所示：</p>
<ol>
<li>DMA控制器有多个硬件的DMA通道（队列），每个硬件DMA通道呈现为一个dmadev。</li>
<li>dmadev可以创建多个虚拟的DMA通道，每个虚拟DMA通道呈现为不通的transfer context， 比如virtual DMA channel 0 用作memory-to-memory场景，而virtual dma channel 1用作 memory-to-device场景。</li>
<li>DMA操作必须提交给虚拟DMA通道。</li>
</ol>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="设备创建"><a href="#设备创建" class="headerlink" title="设备创建"></a>设备创建</h3><p>物理的DMA controller在DPDK初始化时，由PCI扫描枚举出来，基于设备的BDF（bus、device、function）。其他物理DMA controller可以在DPDK命令行中指定。<br>dmadev由rte_dma_pmd_allocate函数根据物理DMA channel的个数创建。</p>
<h3 id="设备标识"><a href="#设备标识" class="headerlink" title="设备标识"></a>设备标识</h3><p>每个DMA(不论是物理还是虚拟的)设备由2个id唯一标识。</p>
<ol>
<li>一个唯一的设备索引，用在DMA API接口中指派dma设备。</li>
<li>一个设备名，用在串口信息或者管理调试。</li>
</ol>
<h2 id="设备特性和能力"><a href="#设备特性和能力" class="headerlink" title="设备特性和能力"></a>设备特性和能力</h2><p>不同的dma设备可能支持不一样的特性，rte_dma_info_get API可以获取设备信息和支持的特性。<br>Silent mode是一种特殊的设备能力，这种设备不需要应用调用dequeue APIs。</p>
<h3 id="出入队接口"><a href="#出入队接口" class="headerlink" title="出入队接口"></a>出入队接口</h3><p>DPDK主要基于轮询的方式操作，因此所有的pmd都会有出入队的接口。<br>Enqueue API 可以把操作传递到设备，这样的接口有rte_dma_copy和rte_dma_fill。如果入队成功，会返回一个ring_idx。ring_idx可以让应用知道到其环中定为操作的元信息。如果入队失败ring_idx是一个负值。<br>rte_dma_submit用于发送一个doorbell通知硬件。也可以在入队的时候，带上RTE_DMA_OP_FLAG_SUBMIT 标记自动发送doorbell通知硬件。</p>
<p>下面的代码描述如何入队多个拷贝操作到设备，并启动硬件进行操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">srcs</span>[<span class="title">DMA_BURST_SZ</span>], *<span class="title">dsts</span>[<span class="title">DMA_BURST_SZ</span>];</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RTE_DIM(srcs); i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (rte_dma_copy(dev_id, vchan, rte_pktmbuf_iova(srcs[i]),</span><br><span class="line">         rte_pktmbuf_iova(dsts[i]), COPY_LEN, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      PRINT_ERR(<span class="string">&quot;Error with rte_dma_copy for buffer %u\n&quot;</span>, i);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">rte_dma_submit(dev_id, vchan);</span><br></pre></td></tr></table></figure>

<p>rte_dma_completed 和rte_dma_completed_status接口用于出队获取操作的结果。rte_dma_completed用于获取成功的个数，rte_dma_completed_status返回个数以及每个操作的执行状态（存放到一个status数组中）。这两个接口还会返回最后一个操作的ring_idx。</p>
<h3 id="查询设备统计"><a href="#查询设备统计" class="headerlink" title="查询设备统计"></a>查询设备统计</h3><p>使用rte_dma_stats_get()接口获取dmadev的统计信息，包含每个设备的如下数据：<br>Submitted： 提交的操作数量<br>Completed：已完成的操作数量（包含成功的和失败的）<br>Errors：完成发送错误的数量<br>库也支持调试接口显示相关信息:</p>
<p><img src="/images/202403/dmadev_stats.png" alt="dmadev_stats"></p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="设备使用前需要进行配置，然后再开始使用："><a href="#设备使用前需要进行配置，然后再开始使用：" class="headerlink" title="设备使用前需要进行配置，然后再开始使用："></a>设备使用前需要进行配置，然后再开始使用：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rte_dma_configure()</span><br><span class="line">rte_dma_vchan_setup()</span><br><span class="line">rte_dma_start()</span><br></pre></td></tr></table></figure>

<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>可以调用rte_dma_configure() or rte_dma_vchan_setup()， 但前提要先调用rte_dma_stop()，配置完后rte_dma_start()开始。设备停止状态下，不要往设备发送操作。</p>
<h3 id="关闭设备"><a href="#关闭设备" class="headerlink" title="关闭设备"></a>关闭设备</h3><p>使用完毕需要调用rte_dma_close关闭设备。</p>
<h3 id="提交操作"><a href="#提交操作" class="headerlink" title="提交操作"></a>提交操作</h3><p>先入队再发送doorbell给硬件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rte_dma_copy()</span><br><span class="line">rte_dma_copy_sg(</span><br><span class="line">rte_dma_fill()</span><br><span class="line">rte_dma_submit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ring-idx说明"><a href="#ring-idx说明" class="headerlink" title="ring_idx说明"></a>ring_idx说明</h3><ul>
<li><ol>
<li>每个virtual dma channel的ring_idx是独立的</li>
</ol>
</li>
<li><ol start="2">
<li>ring_idx是单调递增的数，直到UINT16_MAX才回到0</li>
</ol>
</li>
<li><ol start="3">
<li>ring_idx初始时是0，如果设备停止了，需要重置ring_idx</li>
</ol>
</li>
</ul>
<h3 id="操作地址"><a href="#操作地址" class="headerlink" title="操作地址"></a>操作地址</h3><p>操作内部的地址类型为rte_iova_t。<br>dmadev支持两种类型的地址： 内存地址和设备地址。</p>
<ul>
<li><ol>
<li>内存地址：memory-to-memory操作的源目地址，memory-to-device的源地址， device-to-memory操作的目的地址，如果设备支持SVA，那么这种地址可以是VA，否则必须是IOVA。</li>
</ol>
</li>
<li><ol start="2">
<li>设备地址：memory-to-device的目的地址，device-to-memory操作的源地址</li>
</ol>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>所有的API都是不加锁的，不支持多个线程并发访问，不考虑多个同时调用同一个dmadev。<br>同一个dmadev的virtual dma channel也不支持同时调用，因为这些channel共用同一个硬件的dma channel。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>初步了解一下dma引擎在DPDK中的使用框架。很多公司已经实现了其dma引擎，在大数据、虚拟化等方面开始应用了。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>周谈（55）- 本周杂事小结</title>
    <url>/2024/04/13/2024-20240413-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本周事儿挺多，原先计划的代码开发一行也没写啊，又写文档，又参加会议各种评审，代码review， 然后又支持了几个客户，问题定位修改验证的。</p>
<p>简要挑两三个事简单聊一下。</p>
<span id="more"></span>

<h1 id="ARM-CPU指令支持情况获取"><a href="#ARM-CPU指令支持情况获取" class="headerlink" title="ARM CPU指令支持情况获取"></a>ARM CPU指令支持情况获取</h1><p>在代码review的时候，发现代码直接调用一些指令，不考虑CPU差异，在一些机型下报非法指令的错误，会导致用户程序崩溃。对于不支持的平台上就应该屏蔽掉该功能。<br>本来建议使用的lscpu，通过grep获取flags对应的指令，比如aes，然后编译时通过宏控制，对不支持的功能不进行编译，或者进行代码报错处理。发现这样编译的程序不通用，需要为不通的机型编译不同的二进制程序，最好能动态获取指令支持的情况。</p>
<p><img src="/images/202404/lscpu.png" alt="lscpu"></p>
<blockquote>
<p>上面这个机器是在龙蜥实验室临时借用的阿里云机器，想要学习的同学可以访问<code>https://lab.openanolis.cn/</code>注册个账号试试，也支持付费使用的。</p>
</blockquote>
<p>通过网络搜索，查找到了getauxval方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/hwcap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> hwcaps= getauxval(AT_HWCAP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hwcaps &amp; HWCAP_AES)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AES instructions are available\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hwcaps &amp; HWCAP_CRC32)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CRC32 instructions are available\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hwcaps &amp; HWCAP_PMULL)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PMULL/PMULL2 instructions that operate on 64-bit data are available\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hwcaps &amp; HWCAP_SHA1)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SHA1 instructions are available\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hwcaps &amp; HWCAP_SHA2)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SHA2 instructions are available\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/202404/test_cpu.png" alt="test_cpu"></p>
<p>可以看到支持的情况跟lscpu一致。</p>
<h1 id="在中断函数中使用spinlock避免panic"><a href="#在中断函数中使用spinlock避免panic" class="headerlink" title="在中断函数中使用spinlock避免panic"></a>在中断函数中使用spinlock避免panic</h1><p>有客户使用linux的xfrm框架处理ipsec流报文，发现在大流量的情况下，内核会挂死，但是小流量的情况下又很正常。由于使用的是我们的驱动，问题就反馈到我这儿了。<br>大概看了一下Oops的调用栈，大概就是进程切换导致的死锁。然后到驱动对应的函数看了一下，结合调用栈里的irq函数，大概原因就清楚了。就是在中断处理函数中调用了mutex_lock这个函数，会导致任务切换。而中断执行到一半切出去，就没有办法再切回来的，因为本身切回来也要中断触发的，而在中断处理的过程中，中断实际已经被关掉了。</p>
<p>知道原因了，剩下就好办了，把相关的struct mutex修改成struct spin_lock。相关加锁也使用spin_lock_irqsave替换。最后，发给客户验证一下，确认问题解决了。</p>
<p>正常是要自己验一下，但是xfrm这个框架不了解，需要一些学习成本，记一个待办任务吧。</p>
<p>秉着我们遇到的问题别人肯定都遇到过的思想，到内核找一下其他厂商的代码确认了一下，人家的确都是用的spinlock。哈哈，又挖了一个前人埋的雷。排查一下代码，好家伙，每个项目都有问题，下周又有的忙了。</p>
<p>至于为啥小流量没有问题，只可能是业务处理不频繁的时候，没有触发任务切换。</p>
<h1 id="uboot启动环境"><a href="#uboot启动环境" class="headerlink" title="uboot启动环境"></a>uboot启动环境</h1><p>本来产品基本都使用的UEFI+ACPI的形式了，奈何用户说他们只使用uboot+设备树。客户就是上帝啊，那就找了一堆人，拉操作系统的&#x2F;固件的，一起整出了个uboot启动的环境，还得自己编uImage和设备树。人家本来就对uboot方式投入很少，也没有现成的环境，我们只能硬着头皮去推动了。</p>
<p>本来很简单的，主要就是mkimage把image生成uImage，使用dtc把dts转换为dtb，最后使用bootz启动就好了。结果，各种环境起不来，bootloader和设备树改了好多版本，终于把单numa的测过了。多numa的环境又不对，起来后只有一个numa，下周也还有的忙的了。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>本周就是事儿突然多了起来，前面欠的债都回来找你了。当然，这也是好事啊，说明自个儿做的产品有人在用了，准备造福社会了，哈哈。</p>
<p>学习上面，写的第一篇论文经过多个日夜的5个版本的迭代修改，终于批改合格了，上半年软考就剩一个多月了，还得快马加鞭的复习啊！</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（56）- linux 6.6版本内核驱动适配</title>
    <url>/2024/06/03/2024-20240603-driver-for-linux6-6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本周突然在聊天群里被合作方@了，需要我们提供一般适配linux6.6内核版本的驱动，客户是上帝，马上响应~</p>
<span id="more"></span>

<h1 id="驱动适配"><a href="#驱动适配" class="headerlink" title="驱动适配"></a>驱动适配</h1><p>第一步就是从官网下个6.6版本的内核，然后在机器上编译替换内核，这个比较简单~；</p>
<p>然后就是基于6.6内核的build路径，修改驱动Makefile后编译，后面就是遇水搭桥了，有问题解决问题。</p>
<p>最后，就基于修改后的代码跑一下测试用例。最终打包发布版本。</p>
<h1 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h1><p>主要解决了4个问题，都是内核接口变更导致的。</p>
<h2 id="Class-create-参数变化"><a href="#Class-create-参数变化" class="headerlink" title="Class_create 参数变化"></a>Class_create 参数变化</h2><p>在linux6.4.0之后，Class_create删除了module参数，编译时报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In file included from ./include/linux/device.h:31,</span><br><span class="line">                 from ./include/linux/platform_device.h:13,</span><br><span class="line">                 from /root/hmw/s5000c_ce/driver/src/usr/pce_char.c:3:</span><br><span class="line">./include/linux/device/class.h:230:54: 附注：需要类型‘const char *’，但实参的类型为‘struct module *’</span><br><span class="line">  230 | struct class * __must_check class_create(const char *name);</span><br><span class="line">      |                                          ~~~~~~~~~~~~^~~~</span><br></pre></td></tr></table></figure>

<p>使用LINUX_VERSION_CODE判断版本大小，作一下适配就好了。</p>
<h2 id="非对称结构struct-akcipher-alg成员变更"><a href="#非对称结构struct-akcipher-alg成员变更" class="headerlink" title="非对称结构struct akcipher_alg成员变更"></a>非对称结构struct akcipher_alg成员变更</h2><p>编译时报错信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/root/xxx/rsa.c:1234:3: 错误：‘struct akcipher_alg’没有名为‘reqsize’的成员</span><br><span class="line"> 1365 |  .reqsize = sizeof(rsa_context_t) ,</span><br><span class="line">      |   ^~~~~~~</span><br><span class="line">/root/xxxx/rsa.c:1234:13: 警告：initialization of ‘struct list_head *’ from ‘long unsigned int’ ma                                                                                kes pointer from integer without a cast [-Wint-conversion]</span><br><span class="line"> 1365 |  .reqsize = sizeof(rsa_context_t)  ,</span><br><span class="line">      |             ^~~~~~</span><br></pre></td></tr></table></figure>

<p>reqsize成员挪动了位置，需要在算法init函数中set_reqsize。</p>
<h2 id="内存映射结构体struct-vm-area-struct成员属性变更"><a href="#内存映射结构体struct-vm-area-struct成员属性变更" class="headerlink" title="内存映射结构体struct vm_area_struct成员属性变更"></a>内存映射结构体struct vm_area_struct成员属性变更</h2><p>编译时报错信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> 错误：向只读成员‘vm_flags’赋值</span><br><span class="line">  171 |   vma-&gt;vm_flags |= VM_LOCKED | VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP;</span><br><span class="line">      |                 ^~</span><br><span class="line">make[3]: *** [scripts/Makefile.build:24</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不允许设置vma-&gt;vm_flags了，直接注释掉。</p>
<h2 id="注册算法的时候，直接挂死了"><a href="#注册算法的时候，直接挂死了" class="headerlink" title="注册算法的时候，直接挂死了"></a>注册算法的时候，直接挂死了</h2><p>这个主要是在计算结束时，不能直接调用req-&gt;base.complete了，complete的参数变更了，需要使用相应的接口替换 如aead_request_complete。</p>
<h2 id="注册xts模式时，额外测试失败了"><a href="#注册xts模式时，额外测试失败了" class="headerlink" title="注册xts模式时，额外测试失败了"></a>注册xts模式时，额外测试失败了</h2><p>这个属于与内核软算法不一致的处理，导致extra tests返回失败。参考xts模式处理，当req-&gt;cryptlen &lt; 16时返回值与默认的不一致， 改为-EINVAL<br>解密错误时 返回-EINVAL。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>刚开始接到需求的时候，以为跟之前的5.x版本一样，只需要稍微编译一下就可以解决了，没料到6.x一开始编译就有几个问题，以为要花费一周以上来修改了。最终3天就搞定了，进度还是提前了。<br>加上前面对checkpatch的格式修订一起，这回发布的版本改动还是蛮大的。总之，开发遇到问题解决问题就是了，就怕那些遇到问题就卡住不动了的。</p>
<p>四五月这两个月的业余时间都花在软考系统分析师上面了，平均每天下班都花1~2个小时学习，越是临近考试发现准备的越不充分了，硬着头皮去考了，感觉有点悬啊，坐等6月底或者七月初的成绩，不行就要备战下半年了。6月这段时间就补一下工作用得到的基础吧！</p>
<p>今年软考又改革了，系统分析师和架构师可以一年考两次，说实话，虽然这个学习有点儿纯粹为了应试，但还是可以系统的学到许多知识，包括计算机综合知识、数据库、软件工程、需求工程及新技术等各个方面。</p>
<p>活到老学到老，加油吧，先提升自己，摆脱焦虑！</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础复学（1）- 内核简介</title>
    <url>/2024/06/03/2024-20240603-linux1-overview/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总感觉自己在linux驱动这块的基础比较薄弱，再学一下linux内核驱动的基础，重新巩固一下。趁着最近有时间尽快巩固一下，活到老学到老，温故而知新。</p>
<span id="more"></span>

<h1 id="内核架构"><a href="#内核架构" class="headerlink" title="内核架构"></a>内核架构</h1><p>内核分为微内核和宏内核（单体内核）架构。</p>
<h2 id="宏内核"><a href="#宏内核" class="headerlink" title="宏内核"></a>宏内核</h2><p>广泛开源的Linux内核属于宏内核，把设备驱动、文件系统等功能全部在内核中实现，运行在内核状态和同一个地址空间内。</p>
<ul>
<li>优点：减少进程间的通信和状态切换的开销，可以获得比较高的运行效率；</li>
<li>缺点：内核庞大，占用更自由较多且不易裁剪。系统的稳定性和安全性不高，随便一个驱动挂了都会导致内核宕掉；</li>
</ul>
<h2 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h2><p>据说鸿蒙系统属于微内核架构的，内核只实现基本的功能，把图形、文件系统、设备驱动和通信相关功能放到内核外。</p>
<ul>
<li>优点：结构清晰，易于协作开发。内核精练，灵活便于裁剪和移植。系统服务程序运行在内核外，系统的可靠性、安全性较高。</li>
<li>缺点：用户态和内核态频繁切换，效率低，性能偏低。</li>
</ul>
<h1 id="Linux内核概貌"><a href="#Linux内核概貌" class="headerlink" title="Linux内核概貌"></a>Linux内核概貌</h1><p>Linux内核采用分层架构，主要包括3个部分</p>
<ul>
<li>硬件层： 包括CPU、物理内存、主板、磁盘及相关外设；</li>
<li>内核空间： 包括Linux内核的核心部件， arch抽象层、设备管理抽象层、内存管理、进程管理、总线设备、字符设备及系统调用层；</li>
<li>用户空间：主要就是C语言库、应用程序和虚拟机了</li>
</ul>
<p><img src="/images/202406/WechatIMG153.jpg" alt="linuxlayer"></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础复学（3）- 字符设备驱动</title>
    <url>/2024/06/09/2024-20240609-linux3-chardrv/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>截至当前，工作中涉及的驱动基本都是字符设备驱动，内核通过字符设备向用户空间提供API，实现内核与用户态间的交互。</p>
<p>学习字符设备需要了解以下几方面的知识：</p>
<ul>
<li>了解Linux内核字符设备驱动程序的架构</li>
<li>了解Linux内核字符设备驱动相关的API</li>
<li>了解Linux内核内存管理的API</li>
<li>了解Linux内核中断管理的API</li>
<li>了解Linux内核同步和锁相关的API</li>
<li>了解具体芯片的工作原理及操作方式</li>
</ul>
<p>下面围绕几点，概述一下相关知识。</p>
<span id="more"></span>

<h1 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h1><h2 id="字符设备驱动架构"><a href="#字符设备驱动架构" class="headerlink" title="字符设备驱动架构"></a>字符设备驱动架构</h2><p><img src="/images/202406/char_arch.jpg" alt="lscpu"></p>
<p>驱动架构如图所示，最底层是硬件、向上是Linux的核心模块（比如文件管理、内存管理、中断管理等），然后是驱动程序、虚拟文件系统、系统调用，最上层是应用程序。应用程序通过打开字符设备，使用open、read、write以及mmap等系统调用，获取相关资源，进行对应的操作，最后控制硬件的行为。</p>
<h2 id="字符设备驱动的API"><a href="#字符设备驱动的API" class="headerlink" title="字符设备驱动的API"></a>字符设备驱动的API</h2><p>相关接口的功能包括创建一个字符设备、管理相关的文件操作集函数。大概归纳一下有如下接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请一个字符设备号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *, <span class="type">unsigned</span>, <span class="type">unsigned</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 struct class</span></span><br><span class="line">class_create(owner, name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 struct cdev</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">const</span> <span class="keyword">struct</span> file_operations *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建字符设备</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建设备实例</span></span><br><span class="line"><span class="keyword">struct</span> device *</span><br><span class="line"><span class="title function_">device_create</span><span class="params">(<span class="keyword">struct</span> class *cls, <span class="keyword">struct</span> device *parent, <span class="type">dev_t</span> devt,</span></span><br><span class="line"><span class="params">	      <span class="type">void</span> *drvdata, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就在/dev下创建好一个文件了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁设备实例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">device_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls, <span class="type">dev_t</span> devt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注销class</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">class_unregister</span><span class="params">(<span class="keyword">struct</span> class *class)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">class_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除cdev</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放设备号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span>, <span class="type">unsigned</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现基础文件的打开关闭读写操作</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_open</span><span class="params">(<span class="keyword">struct</span> inode *inodep, <span class="keyword">struct</span> file *filep)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Device has been opened\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_release</span><span class="params">(<span class="keyword">struct</span> inode *inodep, <span class="keyword">struct</span> file *filep)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Device successfully closed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(<span class="keyword">struct</span> file *filep, <span class="type">char</span> *buffer, <span class="type">size_t</span> len, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 读取逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">my_write</span><span class="params">(<span class="keyword">struct</span> file *filep, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> len, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 写入逻辑</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">    .open = my_open,</span><br><span class="line">    .release = my_release,</span><br><span class="line">    .read = my_read,</span><br><span class="line">    .write = my_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="内存管理的API"><a href="#内存管理的API" class="headerlink" title="内存管理的API"></a>内存管理的API</h2><p>主要就是分配内存，设备内存映射等接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 分配设备内存，一般用于存放设备上下文的结构， 设备管理的内存分配函数，它会自动处理内存的释放工作</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">devm_kzalloc</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取设备空间并映射到内存，返回内存地址, devm 开头的函数，在设备或者模块被移除时 会自动做反方向的释放工作</span></span><br><span class="line"><span class="type">void</span> __iomem *</span><br><span class="line"><span class="title function_">devm_platform_get_and_ioremap_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> index, <span class="keyword">struct</span> resource **res)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往映射的内存写数据, 根据操作的长度，存在对应writex函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">writel</span><span class="params">(u32 value, <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从映射的内存读数据, 根据操作的长度，存在对应readx函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u32 <span class="title function_">readl</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存分配</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">alloc_pages_node</span><span class="params">(<span class="type">int</span> nid, <span class="type">gfp_t</span> gfp_mask,</span></span><br><span class="line"><span class="params">						<span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dma相关接口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dma_map_single(d, a, s, r) dma_map_single_attrs(d, a, s, r, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dma_unmap_single(d, a, s, r) dma_unmap_single_attrs(d, a, s, r, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dma_map_sg(d, s, n, r) dma_map_sg_attrs(d, s, n, r, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dma_unmap_sg(d, s, n, r) dma_unmap_sg_attrs(d, s, n, r, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dma_map_page(d, p, o, s, r) dma_map_page_attrs(d, p, o, s, r, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dma_unmap_page(d, a, s, r) dma_unmap_page_attrs(d, a, s, r, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma_sync_single_for_cpu</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">dma_addr_t</span> addr, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">		<span class="keyword">enum</span> dma_data_direction dir)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dma_sync_single_for_device</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">dma_addr_t</span> addr,</span></span><br><span class="line"><span class="params">		<span class="type">size_t</span> size, <span class="keyword">enum</span> dma_data_direction dir)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">		<span class="type">dma_addr_t</span> *dma_handle, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dma_free_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">		<span class="type">void</span> *cpu_addr, <span class="type">dma_addr_t</span> dma_handle)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="中断管理的API"><a href="#中断管理的API" class="headerlink" title="中断管理的API"></a>中断管理的API</h2><p>中断一般由设备发起，驱动程序通过注册中断函数处理数据，而不需要驱动程序主动去poll数据是否准备好。当然，根据应用场景，也有禁用中断使用轮询方式的，比如DPDK。</p>
<p>相关API如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">platform_get_irq</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pci_alloc_irq_vectors</span><span class="params">(<span class="keyword">struct</span> pci_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> min_vecs,</span></span><br><span class="line"><span class="params">                          <span class="type">unsigned</span> <span class="type">int</span> max_vecs, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_free_irq_vectors</span><span class="params">(<span class="keyword">struct</span> pci_dev *dev)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pci_irq_vector</span><span class="params">(<span class="keyword">struct</span> pci_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> nr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">devm_request_threaded_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">			  <span class="type">irq_handler_t</span> handler, <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname,</span></span><br><span class="line"><span class="params">			  <span class="type">void</span> *dev_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">devm_request_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span>			  </span><br></pre></td></tr></table></figure>

<h2 id="同步和锁相关的API"><a href="#同步和锁相关的API" class="headerlink" title="同步和锁相关的API"></a>同步和锁相关的API</h2><p>驱动常用的主要是struct mutex 和 struct spinlock，其中mutex会导致线程阻塞挂起，而spinlock则类似while循环一直在忙。API省略。</p>
<h2 id="具体芯片的工作原理及操作方式"><a href="#具体芯片的工作原理及操作方式" class="headerlink" title="具体芯片的工作原理及操作方式"></a>具体芯片的工作原理及操作方式</h2><p>根据具体硬件的手册来操作，了解实现逻辑和寄存器地址与功能。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础复学（2）- 内核模块基础</title>
    <url>/2024/06/05/2024-20240605-linx2-module/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>复习一下内核模块的几个基础部分内容。</p>
<span id="more"></span>

<h1 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h1><h2 id="初始化和退出函数"><a href="#初始化和退出函数" class="headerlink" title="初始化和退出函数"></a>初始化和退出函数</h2><p>分别使用module_init和module_exit设置模块的初始化和退出函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mytest.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*模块信息声明*/</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;TEST&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTINO(<span class="string">&quot;My test module&quot;</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;mytest&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Makefile-编写"><a href="#Makefile-编写" class="headerlink" title="Makefile 编写"></a>Makefile 编写</h2><p>模块都有对应的Makefile来编译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">KERNEL_DIR := /lib/modules/&#x27;uname -r&#x27;/build</span><br><span class="line"></span><br><span class="line">mytest-objs := mytest.o</span><br><span class="line">obj-m := mytest.o</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules;</span></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"><span class="meta prompt_">  $</span><span class="language-bash">(MAKE) -C $(KERNEL_DIR) SUBDIRS=$(PWD) clean;</span></span><br><span class="line">  rm -f *k.o</span><br></pre></td></tr></table></figure>

<h2 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h2><p>可以给模块传递参数，参数类型可以是byte, short, ushort, int, uint, long, ulong, char 和bool类型。</p>
<p>参数可能会在&#x2F;sys&#x2F;module&#x2F;mytest&#x2F;xxx，通过参数定义的perm可以控制该sys文件的访问权限，一般使用8进制定义，如S_IRUGO(0444),如果有写权限，那么root用户可以改写sys内容控制参数对应的全局变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> debug=<span class="number">1</span>;</span><br><span class="line">module_param(debug, <span class="type">int</span>, <span class="number">0644</span>); </span><br><span class="line">MODULE_PARAM_DESC(debug, <span class="string">&quot;enable debug feature.&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>不同的模块如果有依赖， 被依赖的模块可以导出API接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般使用 EXPORT_SYMBOL_GPL(api_function)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内核导出的符号可以在&#x2F;proc&#x2F;kallsyms 中查看。</p>
<h2 id="模块加载和卸载"><a href="#模块加载和卸载" class="headerlink" title="模块加载和卸载"></a>模块加载和卸载</h2><p>使用inmod Module.ko 加载模块，会调用模块初始化函数， 如果返回为0则加载成功，否则加载失败。通过lsmod 可以查看所有加载的模块。</p>
<p>使用rmmod Module卸载模块，会调用模块退出函数。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（57）- 根据CPU类型实现驱动平台适配</title>
    <url>/2024/06/15/2024-20240615-weekly-driver-probe/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本周收到一个客户需求，他们希望在系统里集成我们的驱动，希望驱动能够自动根据硬件来确定是否加载，最好就是只提供一份驱动，在不同机型下能自适应处理。</p>
<p>由于历史原因，我们的这些硬件从设计上就是不兼容的，且分别开发了不同的驱动，并没有一个统一的驱动架构。一般驱动是可以根据设备树或者ACPI表的描述，自动和硬件匹配的。只要硬件的描述不一样，那么加载了驱动后，也只有相应的驱动会匹配生效。</p>
<p>又由于各种原因，有些机型根本就不存在硬件描述，因此在驱动代码里是通过ioremap直接传入固定的地址来获取硬件的寄存器基址。所以平常的设备树和ACPI表机制用不了了。</p>
<span id="more"></span>

<p>鉴于不同平台的CPU类型是不一样的，跟客户讨论了一下，得到了一种方案。系统里同时集成多个驱动，在驱动模块加载时通过CPU类型判断当前机型是否有相关的硬件，没有的话，模块初始化时返回-ENODEV,否则正常初始化。</p>
<p>另外，就是驱动会通过字符文件向用户态提供接口，相应的用户态库打开对应的文件来实现功能。当存在多个驱动及对应用户态lib时，不同的硬件的字符文件需要不同，否则就有导致接口不匹配都不能用了。</p>
<h1 id="CPU-type"><a href="#CPU-type" class="headerlink" title="CPU type"></a>CPU type</h1><p>在ARM架构里，有一个MIDR_EL1的系统寄存器，这个寄存器提供了关于CPU的实现信息，包括CPU的类型和型号。</p>
<p>MIDR_EL1 寄存器包含以下字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Implementer: 表示实现CPU的公司或组织的代码。</span><br><span class="line">Variant: 表示CPU变体的代码。</span><br><span class="line">Architecture: 表示CPU架构的代码。</span><br><span class="line">Part Number: 表示CPU部件编号的代码。</span><br><span class="line">Revision: 表示CPU修订版本的代码。</span><br></pre></td></tr></table></figure>

<p>在ARMv8架构中，MIDR_EL1 的布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bits 31:24 - Revision</span><br><span class="line">Bits 23:20 - Part Number bottom 4 bits</span><br><span class="line">Bits 19:16 - Part Number top 4 bits</span><br><span class="line">Bits 15:12 - Architecture</span><br><span class="line">Bits 11:7 - Variant</span><br><span class="line">Bits 6:0 - Implementer</span><br></pre></td></tr></table></figure>

<p>具体在驱动的module_init函数中，只要根据Implementer和Part Number判断机型，确定是否存在具体的硬件作不同处理就好了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/cputype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (read_cpuid_implementor() == CPU_PRODUCTOR &amp;&amp; read_cpuid_part_number()== CPU_TYPE_X) &#123;</span><br><span class="line">     <span class="comment">// do xxx</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ret = -ENODEV;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>对于不同硬件相互不兼容的情况，今年已经开始进行统一驱动的架构设计的工作了，定义了统一的对外接口，适配了不同的硬件，在一套代码里囊括了多个硬件的驱动。但由于各种紧急任务的插入，只完成了部分硬件的适配，没有形成一个稳定的版本。</p>
<p>究其原因，还是人的问题，团队没有形成战斗力，分配下去的任务没能及时的完成，完成的质量不过关。另外部门管理相对宽松，员工没有紧迫感，对任务没有责任感，进度推进缓慢，遇到问题不去推就阻塞住了。没有学习的氛围，缺乏知识沉淀和学习的主动性。</p>
<p>今年以来，对接的客户也越来越多，好多历史债务暴露出来，没有几个能打的同事，自个儿瞎忙活～，着实有些累。而且做这些活体现不了啥业绩，又没创新，纯粹的工作量，升职加薪无望，哎！只能自个儿业余加强自我提升了，尽量不让自己太落后。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础复学（4）- RCU同步机制</title>
    <url>/2024/06/16/2024-20240616-linux4-rcu/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>复习一下linux内核中的同步管理机制，内核中用于同步管理的几个机制主要有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自旋锁- 同一个时刻只能被一个代码路径持有锁，其他代码路径一直忙等待，不会休眠，适合占用锁比较短的场景，可以用于中断上下文</span><br><span class="line">原子量- 适合临界区只是一个变量的情况，开销比较小</span><br><span class="line">内存屏障-这个主要是为了阻止编译器的优化而进行指令重排，导致实际执行路径不符合预期的场景</span><br><span class="line">信号量-适合生产者消费者模型，等待会进入睡眠状态，不能用于中断上下文，适合情况复杂，加锁时间较长的场景</span><br><span class="line">互斥量-同一个时刻只有一个代码路径持有锁，会进入睡眠状态，不能用于中断上下文，比信号量简单，结构更小</span><br><span class="line">读写锁-允许同时多个读，同时只能一个写，读写互斥</span><br><span class="line">RCU- read-copy-update 目的是减少多CPU间缓存一致性的开销，允许写者在读者访问期间就修改内容，没有读者的时候更新内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h1><p>其他机制都是用了原子操作指令，多CPU争抢变量的时候会导致性能下降，同步开销比较大。RCU通过创建副本，在读者访问时就可以提前修改，没有读者时更新数据。可以在不阻塞读者的情况下更新数据结构。一般用来对一个指针指向的空间进行保护。RCU可以用来替换读写锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// RCU 相关的API</span><br><span class="line"></span><br><span class="line">rcu_read_lock()/rcu_read_unlock(): 读保护</span><br><span class="line">rcu_dereference(): 获取被保护的指针</span><br><span class="line">rcu_assign_pointer(): 写者更新指针</span><br><span class="line">synchronize_rcu()：同步等待读者访问结束后更新,但是不保证所有清理动作结束，会阻塞当前进程</span><br><span class="line">call_rcu()：注册一个毁掉函数，销毁旧数据，不会阻塞直接返回</span><br><span class="line">rcu_barrier()：等待所有回调调用结束，一般在模块卸载时使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写者删除一个rcu时，可以通过synchronize_rcu等待没有读者访问了，再释放数据。在中断上下文中，则使用call_rcu来处理。</p>
<p>在可卸载的模块中，如果要卸载模块需要首先保证不再发送回调了，然后调用rcu_barrier确保前面的回调已经被调用了，最终才能卸载模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  list_del_rcu(p);</span><br><span class="line">  synchronize_rcu();</span><br><span class="line">  kfree(p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_del_rcu(p);</span><br><span class="line">call_rcu(&amp;p-&gt;rcu, p_callback);</span><br><span class="line"></span><br><span class="line">static void p_callback(struct rcu_head *rp)</span><br><span class="line">&#123;</span><br><span class="line">  struct pstruct *p = container_of(rp, struct pstruct, rcu);</span><br><span class="line"></span><br><span class="line">  kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">  // stop post delete callback</span><br><span class="line"></span><br><span class="line">  // call rcu_barrier</span><br><span class="line"></span><br><span class="line">  // return , allow unload module</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：<a href="https://gitee.com/fishmwei/blog_code/blob/master/linux-kernel/rcu/myrcu.c">https://gitee.com/fishmwei/blog_code/blob/master/linux-kernel/rcu/myrcu.c</a></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础复学（5）- 调试手段一</title>
    <url>/2024/06/22/2024-20240622-linux5-dbg1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>复习一下Linux内核开发使用的调试手段，主要包含如下方法：</p>
<ul>
<li>printk及pr_xxx</li>
<li>动态输出</li>
<li>procfs文件系统</li>
<li>sysfs文件系统</li>
<li>debugfs文件系统</li>
</ul>
<span id="more"></span>

<h1 id="printk"><a href="#printk" class="headerlink" title="printk"></a>printk</h1><p>printk是最常用的调试方法，可以在代码中加入一些打印信息，了解内核模块执行的情况。类似于printf,不过printk是区分了打印等级的，可以通过配置让内核打印相应的等级日志。</p>
<p>printk提供8个打印等级，分别为 DEBUG, INFO, NOTICE, WARNING, ERROR, CRITICAL, ALERT, EMERGE，等级越来越高，对应7-0，值越小等级越高。</p>
<p>内核编译配置可以通过CONFIG_MESSAGE_LOGLEVEL_DEFAULT设置默认打印等级，默认是4（WARNING）。</p>
<p>还可以通过系统启动参数配置打印等级 loglevel&#x3D;8, 也可以在启动后动态修改等级，修改 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk的值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-Inspiron-3020-S:/home/keep/code/raw_blog# cat /proc/sys/kernel/printk</span><br><span class="line">4       4       1       7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别对于 控制台等级/默认消息等级/最低打印等级/默认控制台打印等级</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>pr_xxx是对printk的一个包装，printk是基础的接口，而pr_xxx可以通过名称体现出等级。</p>
<p>还有2个常用的打印接口</p>
<ul>
<li>print_hex_dump 打印内存数据</li>
<li>dump_stack 打印调用栈</li>
</ul>
<h1 id="动态输出"><a href="#动态输出" class="headerlink" title="动态输出"></a>动态输出</h1><p>内核配置CONFIG_DYNAMIC_DEBUG配置使能动态输出功能，可以在内核运行时动态配置信息的输出，而printk属于全局的静态配置。</p>
<p>使用动态输出需要在代码中使用pr_debug&#x2F;dev_dbg函数打印信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内核动态输出代码分布情况</span></span><br><span class="line">cat /sys/kernel/debug/dynamic_debug/control </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">filename:lineno [module]<span class="keyword">function</span> flags format</span></span><br><span class="line">init/main.c:1113 [main]initcall_blacklist =p &quot;blacklisting initcall %s\n&quot;</span><br><span class="line">init/main.c:1152 [main]initcall_blacklisted =p &quot;initcall %s blacklisted\n&quot;</span><br><span class="line">init/main.c:1347 [main]run_init_process =p &quot;  with arguments:\n&quot;</span><br><span class="line">init/main.c:1349 [main]run_init_process =p &quot;    %s\n&quot;</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过往contrl文件写入内容，打开对于模块的打印</span></span><br><span class="line"></span><br><span class="line">echo &#x27;file init/main.c +p&#x27; &gt; /sys/kernel/debug/dynamic_debug/control </span><br><span class="line">echo &#x27;module main +p&#x27; &gt; /sys/kernel/debug/dynamic_debug/control </span><br><span class="line">echo &#x27;func run_init_process +p&#x27; &gt; /sys/kernel/debug/dynamic_debug/control </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开包含usb的路径所有文件的打印</span></span><br><span class="line">echo -n &#x27;*usb* +p&#x27; &gt; /sys/kernel/debug/dynamic_debug/control </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开所有动态打印</span></span><br><span class="line">echo -n &#x27;+p&#x27; &gt; /sys/kernel/debug/dynamic_debug/control </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对一些需要在启动时查看的打印可以在启动参数中添加开关， main.dyndbg=+plft</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以在子模块的Makefile 设置ccflags</span></span><br><span class="line"></span><br><span class="line">ccflags += -DDEBUG -DVERBOSE_DEBUG</span><br></pre></td></tr></table></figure>

<h1 id="proc和sys文件系统"><a href="#proc和sys文件系统" class="headerlink" title="proc和sys文件系统"></a>proc和sys文件系统</h1><p>proc系统提供了一种内核和内核模块向用户态发送消息的机制。这个虚拟文件系统主要提供内核内部的数据结构信息，也可以用来查看系统的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统启动的参数</span></span><br><span class="line"></span><br><span class="line">cat /proc/cmdline</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看cpu信息</span></span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内存信息</span></span><br><span class="line">cat /proc/meminfo</span><br><span class="line">cat /proc/slabinfo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看设备io内存占用信息</span></span><br><span class="line">cat /proc/iomem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看对于<span class="built_in">id</span>的进程信息</span></span><br><span class="line">cat /proc/xxx/*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看misc设备模块</span></span><br><span class="line">cat /proc/misc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内核加密算法</span></span><br><span class="line">cat /proc/crypto</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看中断</span></span><br><span class="line">cat /proc/interrupts</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>proc文件系统主要用于显示系统相关的信息，对于一般模块而言，则使用sys文件系统，提供了一套统一的设备驱动模型。<br>现在很多模块都是用sys作为与用户空间的友好接口，比如uio模块。系统默认创建的字符设备等，也会在sys下创建对应的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/dev/kvm有对应的目录</span></span><br><span class="line"><span class="meta prompt_">xxx# </span><span class="language-bash"><span class="built_in">ls</span> /sys/devices/virtual/misc/kvm/</span></span><br><span class="line">dev  power  subsystem  uevent</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="debugfs文件系统"><a href="#debugfs文件系统" class="headerlink" title="debugfs文件系统"></a>debugfs文件系统</h1><p>debugfs则是一个纯粹用来调试内核的文件系统， 而proc和sys则是作为用户接口来使用的，不适合暴露私有的调试信息。最基础的内核调试是打印日志，但是如果涉及到数据修改的，就可以使用debugfs文件系统了，否则只能修改代码重新编译加载。</p>
<p>debugfs 一般挂在到&#x2F;sys&#x2F;kernel&#x2F;debug目录下，比如dma模块就有相关的文件在该目录下。之前看的dma-api使用接口，当开启了CONFIG_DMA_API_DEBUG就会在&#x2F;sys&#x2F;kernel&#x2F;debug目录下创建一个dma-api的目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-Inspiron-3020-S:~# ls /sys/kernel/debug/dma-api/</span><br><span class="line">all_errors  driver_filter  error_count       nr_total_entries  num_free_entries</span><br><span class="line">disabled    dump           min_free_entries  num_errors</span><br><span class="line">root@keep-Inspiron-3020-S:~#</span><br></pre></td></tr></table></figure>

<p>类似proc和sys, debugfs也提供了api来读写文件的接口来实现数据通信，用于调试。</p>
<p>本文相关测试代码： <a href="https://gitee.com/fishmwei/blog_code/blob/master/linux-kernel/dbgm/dbgm.c">https://gitee.com/fishmwei/blog_code/blob/master/linux-kernel/dbgm/dbgm.c</a></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础复学（6）- 调试手段二</title>
    <url>/2024/06/23/2024-20240623-linux6-dbg2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继续了解一些linux开发使用到的调试手段：</p>
<ul>
<li>devmem: 可以在终端直接查看或者修改设备寄存器的值</li>
<li>top: 用于实时运行系统的监控，包括Linux内核管理的进程或者线程的资源占用情况</li>
</ul>
<span id="more"></span>

<h1 id="devmem"><a href="#devmem" class="headerlink" title="devmem"></a>devmem</h1><p>编译内核的时候，需要开启CONFIG_DEVMEM, 可以在终端查看寄存器值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要安装相应的软件包 apt install devmem2</span></span><br><span class="line">man devmem2</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       devmem2 - simple program to read/write from/to any location in memory</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       devmem2 address [type [data]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@keep-Inspiron-3020-S:/home/keep/code/linux-6.6#  devmem2 00100000 w</span><br><span class="line">/dev/mem opened.</span><br><span class="line">Memory mapped at address 0x7293b923b000.</span><br><span class="line">Value at address 0x8000 (0x7293b923b000): 0xBBC0BBC</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>top命令可以查看系统实时进程状态，显示内核管理的所有进程和线程的概要信息。</p>
<p>top命令显示分为3个区域： 概要区域，列表头，任务区域。另外在概要区域和列表头中间还有一个输入行，通过输入相关快捷键会触发该行的输入(比如g:切换任务域2的显示模式)</p>
<p><img src="/images/202406/top_view.png" alt="top_view"></p>
<h2 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h2><p>top命令使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -hv|-bcEeHiOSs1 -d secs -n max -u|U user -p pids -o field -w [cols]</span><br><span class="line"></span><br><span class="line">-h | -v: 帮助或者版本信息</span><br><span class="line"></span><br><span class="line">-b  批量模式，用于将输出存到一个文件，不能交互</span><br><span class="line"></span><br><span class="line">-c 显示完整执行命令路径</span><br><span class="line"></span><br><span class="line">-d 指定更新时间间隔， 可以通过快捷键d/s运行时修改间隔</span><br><span class="line"></span><br><span class="line">-e 指定任务域内存容量单位 k - kB, m-MB, g-GB, t-TB, p-PB, 可以通过快捷键e 调整</span><br><span class="line"></span><br><span class="line">-E 指定概要区域内存容量单位 k - kB, m-MB, g-GB, t-TB, p-PB, 可以通过快捷键E 调整</span><br><span class="line"></span><br><span class="line">-H 用于指示 top 显示每个进程中的各个线程，而不是默认的将同一进程中的所有线程合并显示,可以通过快捷键H调整</span><br><span class="line"></span><br><span class="line">-i 忽略自上次更新以来没有占用CPU的项目</span><br><span class="line"></span><br><span class="line">-n 指定显示的最大行数</span><br><span class="line"></span><br><span class="line">-o 指定排序的字段 -o +%MEM 按内存从高到低排序， -o -%MEM从低到高排序</span><br><span class="line"></span><br><span class="line">-O 输出所有字段名</span><br><span class="line"></span><br><span class="line">-p 只显示指定id的进程</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="区域介绍"><a href="#区域介绍" class="headerlink" title="区域介绍"></a>区域介绍</h2><p>概要区域：</p>
<p>第1行显示uptime, load averates ： 程序名称&#x2F;当前时间&#x2F;启动以来的时长&#x2F;当前登陆系统的用户数&#x2F;过去1,5,15分钟的CPU平均负载</p>
<p>第2行显示总的任务数，以及处于每个状态的任务数</p>
<p>第3行显示自上次更新以来CPU的百分比状态</p>
<ul>
<li>us 没有设置优先级的用户进程，一般默认没有设置</li>
<li>sy 系统内核进程</li>
<li>ni 设置了优先级的用户进程</li>
<li>id 空闲</li>
<li>wa 等待IO</li>
<li>hi 硬件中断</li>
<li>si 软件中断</li>
<li>st 虚拟机占用的时间</li>
</ul>
<p>第4行显示物理内存占用情况<br>第5行显示虚拟内存占用情况</p>
<p>表头区域</p>
<p>可以通过快捷键f&#x2F;F来控制显示的顺序及是否显示。</p>
<ul>
<li>%CPU CPU使用率 自上次更新以来占用的CPU时间百分比，支持SMP时，如果一个进程包含多个线程，那么这个使用率可能超过100%。</li>
<li>%MEM 一个任务当前占用的物理内存的份额</li>
<li>GII 组ID</li>
<li>GROUP 组名</li>
</ul>
<p>还有许多交互命令可以控制top的显示配置。</p>
<p><img src="/images/202406/top_ic.png" alt="top_ic"></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础复学（7）- 性能分析工具perf</title>
    <url>/2024/06/26/2024-20240626-linux7-perf/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>perf是Linux内置的性能分析工具，主要是利用了硬件技术单元比如CPU, PMU和软件的计数，软件计数器及跟踪点。<br>perf的源码在Linux内核源码的tools&#x2F;perf下。</p>
<h1 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h1><p>perf包含许多二级命令，实现不同的功能：</p>
<span id="more"></span>

<p><img src="/images/202406/perf.jpg" alt="perf"></p>
<h2 id="perf-list"><a href="#perf-list" class="headerlink" title="perf list"></a>perf list</h2><p>list显示系统支持的事件类型，主要有hardware, software, tracepoint三类：</p>
<ul>
<li>hardware PMU单元产生的事件</li>
<li>software 内核产生的事件，比如进程切换</li>
<li>tracepoint 内核静态跟踪点触发的事件</li>
</ul>
<h2 id="perf-record"><a href="#perf-record" class="headerlink" title="perf record"></a>perf record</h2><p>record用来采集数据并存储到文件中，然后可以使用report命令分析数据。</p>
<p>record有如下几个选项：</p>
<ul>
<li>e 选择一个事件</li>
<li>a 全系统范围内采集</li>
<li>p 指定一个进程ID</li>
<li>o 指定要输出的文件，默认是perf.data</li>
<li>g 使能函数调用图功能， 分析时 可以查看调用栈</li>
<li>C 只采集某个CPU的数据</li>
</ul>
<p>report常见的几个选项</p>
<ul>
<li>i 输入待分析的数据文件，默认perf.data</li>
<li>g 生产函数调用关系图</li>
<li>sort 分类统计信息，比如pid, comm, cpu等</li>
</ul>
<h2 id="perf-stat"><a href="#perf-stat" class="headerlink" title="perf stat"></a>perf stat</h2><p>stat通过概括，精简的方式对被调试的程序分析展示运行的整体情况，汇总数据，包含如下选项：</p>
<ul>
<li>a 显示所有CPU的统计信息</li>
<li>c 显示指定CPU的统计信息</li>
<li>e 指定要显示的事件</li>
<li>p 指定要显示的进程的ID</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-Inspiron-3020-S:/home/keep# perf stat -p 5353</span><br><span class="line"></span><br><span class="line"> Performance counter stats for process id &#x27;5353&#x27;:</span><br><span class="line"></span><br><span class="line">         24,937.97 msec task-clock                       #    0.996 CPUs utilized   真正占用处理器的时间          </span><br><span class="line">                94      context-switches                 #    3.769 /sec                      </span><br><span class="line">                 1      cpu-migrations                   #    0.040 /sec            程序运行期间处理器迁移的次数</span><br><span class="line">                 0      page-faults                      #    0.000 /sec             发生缺页异常的次数</span><br><span class="line">     &lt;not counted&gt;      cpu_atom/cycles/                                                        (0.00%)</span><br><span class="line">   129,338,465,839      cpu_core/cycles/                 #    5.186 GHz                       </span><br><span class="line">     &lt;not counted&gt;      cpu_atom/instructions/                                                  (0.00%)</span><br><span class="line">   434,900,571,908      cpu_core/instructions/                                                </span><br><span class="line">     &lt;not counted&gt;      cpu_atom/branches/                                                      (0.00%)</span><br><span class="line">    82,583,280,228      cpu_core/branches/               #    3.312 G/sec                     </span><br><span class="line">     &lt;not counted&gt;      cpu_atom/branch-misses/                                                 (0.00%)</span><br><span class="line">            53,783      cpu_core/branch-misses/                                               </span><br><span class="line">             TopdownL1 (cpu_core)                 #     40.7 %  tma_backend_bound      </span><br><span class="line">                                                  #      0.0 %  tma_bad_speculation    </span><br><span class="line">                                                  #      6.0 %  tma_frontend_bound     </span><br><span class="line">                                                  #     53.3 %  tma_retiring           </span><br><span class="line"></span><br><span class="line">      25.025841987 seconds time elapsed</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="perf-top"><a href="#perf-top" class="headerlink" title="perf top"></a>perf top</h2><p>top命令按占比列出CPU使用比较多的进程，包含以下选项：</p>
<ul>
<li>e 指定要分析的事件</li>
<li>p 分析指定进程</li>
<li>k 指定内核映像路径</li>
<li>K 不显示内核或者内核模块的符号</li>
<li>U 不显示用户态程序的符号</li>
<li>g 显示函数调用关系</li>
</ul>
<p><img src="/images/202406/perftop.png" alt="perf"></p>
<h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><p>下载<a href="https://github.com/brendangregg/FlameGraph%E4%BB%93%E5%BA%93%E4%BB%A3%E7%A0%81">https://github.com/brendangregg/FlameGraph仓库代码</a></p>
<ol>
<li>首先使用perf record 采集数据生成 perf.data文件</li>
<li>使用perf script -i perf.data &amp;&gt; perf.unfold 解析</li>
<li>.&#x2F;stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded</li>
<li>.&#x2F;flamegraph.pl perf.folded &gt; perf.svg 生成火焰图</li>
</ol>
<p>y轴代表调用栈，每一层都是一个函数调用，栈越深则火焰越高，调用关系是从下而上的，即下层函数调用了上层函数。<br>x轴代表抽样数，一个函数在x轴占据的宽度越宽，则表示它被抽样到的次数也就越多，也就是说它执行的时间越长。</p>
<h1 id="constructor函数编译成静态库后不生效"><a href="#constructor函数编译成静态库后不生效" class="headerlink" title="constructor函数编译成静态库后不生效"></a>constructor函数编译成静态库后不生效</h1><p>最近在项目中，为了解耦合代码，使用__attribute__((constructor)) 函数将一些信息在程序运行前自动注入全局变量，当库代码编译成动态库时，的确可以正常工作。但是，编译成静态库的时候，就不生效了。</p>
<p>上网查了一下，大概就是编译成静态库时，链接器会把那些没有被调用到的函数优化掉，因此在最终程序中就没有相关函数了，解决办法就是在链接的时候，在静态库前后添加-Wl,–whole-archive和-Wl,–no-whold-archive，亲测有效！</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>perf是一个工具，可以帮助我们定位到程序的瓶颈，修改就要看具体的代码了，不断的尝试优化，以达到更优的性能。</p>
<p>今天软考出成绩了，好伤心，没有通过，挂在案例了，最担心的论文反而通过了。案例也的确是练习的不多，下半年再考一次吧，好好学习还是学到了不少东西，结果很重要，但过程也很精彩！</p>
<p><img src="/images/202406/Jsjrk.png" alt="Jsjrk"></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>CPU性能分析与优化笔记0-概要</title>
    <url>/2024/07/21/2024-20240721-cpu-perf0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着摩尔定律的消失，日益增长的数据交换增长并促进更快的硬件及软件的需求。对整个网络和存储也有了更高的要求。<br>在实际项目中，经常发现应用程序的性能并没有随着CPU数量的增加而提升。在性能为王的时代，如果不能找到产品的性能瓶颈并进行调优，那么产品将会被市场抛弃。</p>
<p>其实，大部分应用程序的性能提升都源于软件栈。下面是一个4096X4096矩阵乘法的性能表现：</p>
<span id="more"></span>
<p><img src="/images/2024/cpu_perf0.jpg.jpg" alt="matrix"></p>
<h1 id="影响软件性能的因素"><a href="#影响软件性能的因素" class="headerlink" title="影响软件性能的因素"></a>影响软件性能的因素</h1><p>系统默认情况下获得最佳性能的一些重要因素有：</p>
<ul>
<li>cpu的限制， cpu不会自动优化指令，而是按程序给定的指令进行运算；</li>
<li>编译器的限制，虽然编译器已经很智能，但是没有办法所有程序都编译成最佳的指令</li>
<li>算法复杂度分析的限制，算法的复杂度并不适合所有的场景，对不同数据规模效果不一致</li>
</ul>
<p>性能升一方面可以优化程序，还可以优化硬件的设计以及提升算法的性能。</p>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>性能分析就是通过测量数据，分析程序的瓶颈。找到问题后，使用合理的方法解决。<br>软件优化同时也需要考虑成本，只有大的收益情况下的优化才有意义。</p>
<h1 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h1><p>笔者的工作是为一些加速器开发对应的软件栈。加速器在硬件设计的时候，产品定好了指标，再根据指标和算法原理，指导硬件进行设计实现。<br>最终，经过全局的均衡，可以根据硬件的时钟频率、算法流程，计算一个理论最大性能。</p>
<p>经过硅前验证，最终实现的软件栈性能与理论性能差距在5%以内。数据越短的，性能差距越大，软件的性能损耗占比越高。<br>有了指标，测出来的数据也符合理论性能，那么就没有优化的必要。针对短数据，根据perf执行的分析，主要是一些数据拷贝组装占比较高，采用一些常用的优化技巧进行调优，最终效果并不明显。<br>为了进行测试，预先构建好命令，只对硬件操作部分进行基准测试，结果符合预期。</p>
<p>但是实际应用时，在短数据下是无法达到理论性能的，软件流程必须是一个完成的过程。作为产品，必须以真实程序的性能为准。</p>
<p>性能还受到环境影响，如果在系统还在运行其他程序，cpu不断地被调度，每次测出来的性能都会有个10%左右的波动，因此性能数据一般需要五组以上的数据取平均。</p>
<p>原厂给出的性能数据基本是基准程序测试法给出的，应用集成后，也会对完整的业务流程测试性能。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（58）- 内核IPSec丢包问题</title>
    <url>/2024/11/26/2024-20241126-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知道什么情况，最近支持的客户越来越多了。前人欠的债，后人帮忙还。</p>
<p>最近有个客户使用了公司的产品，通过strongSwan配置了IPSec通路，使用了内核的xfrm框架实现数据包的加解密。为了提升吞吐量，需要使用到内置密码引擎功能。</p>
<p>然后在使用iperf进行流量测试时，发现存在丢包的问题。反馈到了技术支持，最终落到了我的头上。</p>
<p>这个驱动是历史产物了，也算是公司第一代的产品。一直也没有什么客户在用，也就一直没有收到市场的问题，给人一种产品很好的错觉。领导也经常引以为傲哈。</p>
<p>但实际情况是我已经填了不下10个坑。</p>
<span id="more"></span>

<h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>客户使用strongSwan搭建了IPsec环境，并使用iperf进行带宽测试，收发两端都使用我司产品,加载了密码引擎驱动。配置IPsec策略使用cbc(sm4)加密，hmac(sm3)做认证。现象：<br>1.单向发送iperf流量时，iperf计数正常，几乎不丢包。<br>2.单向发送iper流量，同时反向使用ping包，iperf出现丢包。</p>
<h1 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h1><p>报案了，咱们开始破案吧。首先，还原现场，根据客户描述搭建环境。</p>
<p>问题在于我对业务不熟悉，也就是不知道怎么搭建这个IPSec环境。利用之前的经验，使用ip xfrm命令配置了静态的环境，可就是死活配置不了那个sm4算法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~ # ip xfrm state add src 192.168.0.1 dst 192.168.0.2 proto esp spi 0x00000301 mode tunnel auth sm3 0x96358c90783bbfa3d7b196ceabe0536b enc sm4 0xf6ddb555acfd9d77b03ea3843f2653255afe8eb5573965df</span><br><span class="line">RTNETLINK answers: Invalid argument</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个ip xfrm的提示很明显了，我愣是没看出啥问题，参数太多了。</p>
<p>只能先凑合着用hmac(sm3)+cbc(des3_ede)。主要命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====================sm3 + cbc(des3_ede) ============================</span><br><span class="line">PC1： //192.168.0.1</span><br><span class="line">ip xfrm state add src 192.168.0.1 dst 192.168.0.2 proto esp spi 0x00000301 mode tunnel auth sm3 0x96358c90783bbfa3d7b196ceabe0536b enc sm4 0xf6ddb555acfd9d77b03ea3843f2653255afe8eb5573965df</span><br><span class="line">ip xfrm state add src 192.168.0.2 dst 192.168.0.1 proto esp spi 0x00000302 mode tunnel auth sm3 0x99358c90783bbfa3d7b196ceabe0536b enc des3_ede 0xffddb555acfd9d77b03ea3843f2653255afe8eb5573965df</span><br><span class="line"></span><br><span class="line">ip xfrm policy add src 192.168.0.1 dst 192.168.0.2 dir out ptype main tmpl src 192.168.0.1 dst 192.168.0.2 proto esp mode tunnel</span><br><span class="line">ip xfrm policy add src 192.168.0.2 dst 192.168.0.1 dir in ptype main tmpl src 192.168.0.2 dst 192.168.0.1 proto esp mode tunnel</span><br><span class="line"></span><br><span class="line">PC2：// 192.168.0.2</span><br><span class="line">ip xfrm state add src 192.168.0.1 dst 192.168.0.2 proto esp spi 0x00000301 mode tunnel auth sm3 0x96358c90783bbfa3d7b196ceabe0536b enc des3_ede 0xf6ddb555acfd9d77b03ea3843f2653255afe8eb5573965df</span><br><span class="line">ip xfrm state add src 192.168.0.2 dst 192.168.0.1 proto esp spi 0x00000302 mode tunnel auth sm3 0x99358c90783bbfa3d7b196ceabe0536b enc des3_ede 0xffddb555acfd9d77b03ea3843f2653255afe8eb5573965df</span><br><span class="line"></span><br><span class="line">ip xfrm policy add src 192.168.0.1 dst 192.168.0.2 dir in ptype main tmpl src 192.168.0.1 dst 192.168.0.2 proto esp mode tunnel</span><br><span class="line">ip xfrm policy add src 192.168.0.2 dst 192.168.0.1 dir out ptype main tmpl src 192.168.0.2 dst 192.168.0.1 proto esp mode tunnel</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除xfrm配置的命令</span></span><br><span class="line">ip xfrm state deleteall</span><br><span class="line">ip xfrm policy deleteall  </span><br><span class="line"></span><br><span class="line">iperf3 -c 192.168.0.2 -u -i 10 -t 20 -b 300M -l 1024</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看配置</span></span><br><span class="line">ip xfrm state </span><br><span class="line">ip xfrm policy </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自测时发现是存在少量的丢包，但是也没有客户反馈的那么严重。 </p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><ol>
<li><p>同时客户还反馈使用内核自带的软算法没有问题。基本可以确认就是驱动的问题了。</p>
</li>
<li><p>根据描述的场景，考虑可能存在多线程加解密。所以我就增加了多线程同时进行加解密的操作的测试，每个线程分别进行计算，结果和软算法进行比较，结果都正确，没有发现问题。</p>
</li>
<li><p>继续分析代码，把代码中可能存在脏值的内存都清零了，继续测试，问题现象依然存在。</p>
</li>
<li><p>给力的客户，也同时在分析我们的代码进行测试，通过对sm3算法处理逻辑加锁，发现丢包的数目减少了</p>
</li>
<li><p>大概判断是多线程处理导致的问题，最大的可能就是共用了临界区，但是保护措施还是不到位。</p>
</li>
<li><p>确认现场配置使用的是同一条IPSec策略，在本地配置了sm3+des3的IPSec环境，在sm3的加密函数中添加WARN_ON查看调用栈：</p>
</li>
</ol>
<p><img src="/images/2024/Ipsec_stack.png" alt="perf"></p>
<p>根据调用栈，分析esp_input函数中的加密部分代码，发现使用的aead算法，是由authenc模板组合而来。</p>
<p>联想使用的是同一个xfrm_state，不同报文加解密会使用不同的req，但是算法实例上下文是同一个。</p>
<ol start="7">
<li>考虑到内核加密是一个通过的框架，只需要对比一下和其他驱动差异，基本就确认了原因是由于驱动不支持多个请求共用同一个算法上下文。</li>
</ol>
<h1 id="问题修改"><a href="#问题修改" class="headerlink" title="问题修改"></a>问题修改</h1><p>参照着其他驱动，同步修改一下sm3和sm4的代码，本地验证sm3是没问题了，同步代码给客户验证， 问题完美解决。</p>
<p>哈希使用的是 <code>struct shash_alg</code>同步类型，其中base.cra_ctxsize的大小存放上下文不变的内容，比如key,算法类型等。而对于每个请求相关的buffer,total_len需要放到req中去，对应的就是descsize。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不变的内容获取</span></span><br><span class="line">crypto_shash_ctx(desc-&gt;tfm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求相关的内容获取</span></span><br><span class="line">shash_desc_ctx(desc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的空间框架会申请好</span></span><br></pre></td></tr></table></figure>


<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>得空了，继续看一下为啥sm4无法配置了。最终发现是由于key的长度不是16导致的。命令如下，以供需要的同学。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">=======================sm3 + cbc(sm4) ==========================</span><br><span class="line"></span><br><span class="line">PC1： //192.168.0.1</span><br><span class="line">ip xfrm state add src 192.168.0.1 dst 192.168.0.2 proto esp spi 0x00000301 mode tunnel auth sm3 0x96358c90783bbfa3d7b196ceabe0536b enc sm4 0xf6ddb555acfd9d77b03ea3843f265325</span><br><span class="line">ip xfrm state add src 192.168.0.2 dst 192.168.0.1 proto esp spi 0x00000302 mode tunnel auth sm3 0x99358c90783bbfa3d7b196ceabe0536b enc sm4 0xffddb555acfd9d77b03ea3843f265325</span><br><span class="line"></span><br><span class="line">ip xfrm policy add src 192.168.0.1 dst 192.168.0.2 dir out ptype main tmpl src 192.168.0.1 dst 192.168.0.2 proto esp mode tunnel</span><br><span class="line">ip xfrm policy add src 192.168.0.2 dst 192.168.0.1 dir in ptype main tmpl src 192.168.0.2 dst 192.168.0.1 proto esp mode tunnel</span><br><span class="line"></span><br><span class="line">PC2：// 192.168.0.2</span><br><span class="line">ip xfrm state add src 192.168.0.1 dst 192.168.0.2 proto esp spi 0x00000301 mode tunnel auth sm3 0x96358c90783bbfa3d7b196ceabe0536b enc sm4 0xf6ddb555acfd9d77b03ea3843f265325</span><br><span class="line">ip xfrm state add src 192.168.0.2 dst 192.168.0.1 proto esp spi 0x00000302 mode tunnel auth sm3 0x99358c90783bbfa3d7b196ceabe0536b enc sm4 0xffddb555acfd9d77b03ea3843f265325</span><br><span class="line"></span><br><span class="line">ip xfrm policy add src 192.168.0.1 dst 192.168.0.2 dir in ptype main tmpl src 192.168.0.1 dst 192.168.0.2 proto esp mode tunnel</span><br><span class="line">ip xfrm policy add src 192.168.0.2 dst 192.168.0.1 dir out ptype main tmpl src 192.168.0.2 dst 192.168.0.1 proto esp mode tunnel</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除xfrm配置的命令</span></span><br><span class="line">ip xfrm state deleteall</span><br><span class="line">ip xfrm policy deleteall  </span><br><span class="line"></span><br><span class="line">iperf3 -c 192.168.0.2 -u -i 10 -t 20 -b 300M -l 1024</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根本原因是由于前人对业务场景不熟悉，驱动的实现没有考虑多线程使用同一个算法上下文，驱动测试用例也没有覆盖相关场景，同时内核自检模块也缺少相关的用例。</p>
<p>还有就是开发者没有深入框架，学习其他驱动的实现，最终只是做了一个demo，能用而已。</p>
<p>后面抽空再看看那个strongSwan是怎么配置的，这块需要系统一点的知识了。</p>
<p>这个鬼问题，从报案到结案，断断续续的差不多有一个月了吧。领导让我先搞其他的，这个问题优先级放后，又去忙其他的了。</p>
<p>组里的新生力量又没人搞得了，最后一周技术支持也是急了，再不解决要捅到大领导那去了，让人出差去现场搞了。</p>
<p>领导又赶紧把我拉来扛了，想着有点滑稽。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>快半年没有更新了，一直在忙着准备系分软考，业余时间过得相当的充实，周末也排的满满当当的，当然也学了许多的知识，感觉这次能过，哈哈。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（59）- ini配置文件开源库minIni</title>
    <url>/2024/12/14/2024-20241214-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在写一个通用的测试工具用于认证，针对不同的产品差异不同，通过代码或者编译选项来区分产品太不灵活了。因此，有了使用配置文件来修改的想法。</p>
<p>现写一个当然不如找一个，在AI的时代，使用GPT来辅助编程越来越方便高效了。目前工作中，使用的最多的就是kimi了。大概搜索了一下，找到一个minIni的库。</p>
<p>这是一个小巧且便携的INI文件库，支持读写操作，特别适合嵌入式系统。minIni库是根据Apache许可证2.0版分发的，外加一个例外条款，以明确允许将该库静态链接到商业应用程序，对于我想写的小型的测试程序也很适合。</p>
<span id="more"></span>

<h1 id="minIni"><a href="#minIni" class="headerlink" title="minIni"></a>minIni</h1><p>这个库本身是支持跨平台的，而且只提供了简单的几个C语言文件，连编译脚本都没写。</p>
<p>最新源代码可以在GitHub上访问：<a href="https://github.com/compuphase/minIni%EF%BC%8C%E9%A1%BA%E4%BE%BF%E7%BB%99%E8%BF%99%E4%B8%AA%E5%BA%93%E7%82%B9%E4%BA%86Star%EF%BC%8C%E6%84%9F%E8%B0%A2%E5%BC%80%E5%8F%91%E8%80%85%E3%80%82">https://github.com/compuphase/minIni，顺便给这个库点了Star，感谢开发者。</a></p>
<p>我在gitee上面镜像了一份，添加了编译脚本，直接在ARM平台上编译可用， 路径<a href="https://gitee.com/fishmwei/minIni">https://gitee.com/fishmwei/minIni</a></p>
<h2 id="ini配置语法"><a href="#ini配置语法" class="headerlink" title="ini配置语法"></a>ini配置语法</h2><p>ini文件语法很简单，主要就是Section 和key-value键值对,示例如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Network]</span><br><span class="line">hostname=My Computer</span><br><span class="line">address=dhcp</span><br><span class="line">dns = 192.168.1.1</span><br><span class="line">numa=0</span><br></pre></td></tr></table></figure>

<p>库的接口也很简单，支持读写文件和查询相关的字段。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">int  ini_getbool(const mTCHAR *Section, const mTCHAR *Key, int DefValue, const mTCHAR *Filename);</span><br><span class="line">long ini_getl(const mTCHAR *Section, const mTCHAR *Key, long DefValue, const mTCHAR *Filename);</span><br><span class="line">int  ini_gets(const mTCHAR *Section, const mTCHAR *Key, const mTCHAR *DefValue, mTCHAR *Buffer, int BufferSize, const mTCHAR *Filename);</span><br><span class="line">int  ini_getsection(int idx, mTCHAR *Buffer, int BufferSize, const mTCHAR *Filename);</span><br><span class="line">int  ini_getkey(const mTCHAR *Section, int idx, mTCHAR *Buffer, int BufferSize, const mTCHAR *Filename);</span><br><span class="line"></span><br><span class="line">int  ini_hassection(const mTCHAR *Section, const mTCHAR *Filename);</span><br><span class="line">int  ini_haskey(const mTCHAR *Section, const mTCHAR *Key, const mTCHAR *Filename);</span><br><span class="line"></span><br><span class="line">int  ini_putbool(const mTCHAR *Section, const mTCHAR *Key, int Value, const mTCHAR *Filename);</span><br><span class="line">int  ini_putl(const mTCHAR *Section, const mTCHAR *Key, long Value, const mTCHAR *Filename);</span><br><span class="line">int  ini_puts(const mTCHAR *Section, const mTCHAR *Key, const mTCHAR *Value, const mTCHAR *Filename);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>工程也提供了测试程序，使用起来很方便。</p>
<p><img src="/images/2024/minIni_test.png" alt="minIni_test"></p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><h2 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h2><p>最近花钱入了一个树莓派5，用来学习。家里的电脑都是X86, 一些ARM相关的程序跑不了，虽然可以用qemu虚拟机，但是也不是很方便。</p>
<p>工欲善其事必先利其器，树莓派操作还是很方便的，而且也不是很贵。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>软考高级-系统分析师备考分享</title>
    <url>/2024/12/14/2024-20241214-xf/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>12月11日下半年的软考成绩公布了，我这次三个科目（综合、案例、论文）都及格了，经过一年的备考，继上半年案例挂了之后，这次各科都及格了，终于二次上岸了，为这段学习经历画下了圆满的句号。</p>
<p>分享一下自己的备考的经验和感受吧。</p>
<span id="more"></span>

<p><img src="/images/2024/rkxf.png" alt="rkxf"></p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>就是之前看公司要申报职称，正常评审的话，高级职称的要求挺高的，需要有什么论文、论著or专利或已经投入实际应用取得实效的技术报告等等。对于常年编程的码农来说，材料包装上面还是弱一些，所谓的论文也没有发表过，条件也比较难达到的。</p>
<p>关于专利，在以前的公司还是有写过几个。当前的公司，整体都在忙于救火，暂时还没挖掘出好的idea，今年倒是憋了一个，法务也还没反馈。专利就跟自己做的工作比较相关了，不是什么创新性的工作很难出专利。</p>
<p>说回来，计算机软考本身是一个以考代评的考试，考试通过国家发证书，全国范围内长期有效。而自己多年前就已经考过了中级的软设，也就是工程师的职称。一方面想着冲高级，另一方面也想系统的学习一下系统知识，包括需求获取与分析、系统架构设计、软件开发方法、项目管理等，利用好业余时间，也给上小学的孩子一个学习的家庭氛围。</p>
<p>作为技术开发人员比较适合的就是系统架构师和系统分析师。而有这个想法的时间就是大概23年11月左右，当时这两个科目都是一年一考的，上半年考系分，下半年考架构(24年改了，都是一年考两次了)。架构一年等不了，就先报了系分，反正都是高级。</p>
<p>网上查了大概的考点，及历年考试的通过率，发现难度比较大，为了系统地学习，同时有人督促和咨询，就确定了报班。</p>
<h2 id="备考过程"><a href="#备考过程" class="headerlink" title="备考过程"></a>备考过程</h2><p>备考还是很艰辛的，特别是毕业好久了，很多知识也已经忘了。大的方向就按照培训机构的计划来执行。</p>
<p>主要就是几个方面，预习、学习、复习和做题巩固、背诵知识点。</p>
<p>预习就是看精讲视频，预习讲义的内容，记录问题。精讲视频很多知识点都讲的比较透了，不懂的地方可以反复播放学习几次。</p>
<p>学习就是跟着直播上课，一般都是周二、周四晚上19:30~21:30，一次两个小时。学完后，顺带做一下课后的习题。</p>
<p>复习就是每周末复习当周的课程知识点，还有就是写论文。没写过论文的我，第一篇论文修改了七次才及格，断断续续写了快一个月，用的都是晚上和周末的时间。老师会讲论文的框架及写文章的思路，多写几篇及格，论文基本就没什么问题了。建议准备一下测试的论文，论文4选1，反正每次都有测试相关的。</p>
<p>做题巩固就是在培训机构网站上做题，吃透一个个知识点。了解案例的解答技巧等。有空就去看看错题。</p>
<p>背诵知识点，就根据考纲和辅导材料，一个个知识点背下来吧。上半年的时候，没有意识到背诵的重要性，特别是做案例的时候，憋半天也写不出几个点来，用词也不专业。上半年案例挂了之后，下半年就加强了背诵。</p>
<h2 id="番茄钟的应用"><a href="#番茄钟的应用" class="headerlink" title="番茄钟的应用"></a>番茄钟的应用</h2><p>学习的时候，为了专注，用手机定个番茄钟，番茄钟不结束就不休息。这样可以保证连续的一段时间内专注于学习，也记录了花在软考学习上的时间，不是有一个一万小时定律吗，时间花在哪儿，成就就出在哪儿。</p>
<p>这个方法我也应用到了日常的其他事件中去了，还是蛮有效的。每天都有时间用于学习，而不是去刷短视频看八卦新闻，过的更踏实有意义了。</p>
<p><img src="/images/2024/fqz.png" alt="rkxf"></p>
<p>大概做了578个番茄钟（上半年338个，先半年239.3个），每个30分钟，就是289个小时，合计12天多一些，日均45分钟左右。</p>
<h1 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h1><p>最近工作也比较忙，需要学习的知识也是越来越多，考证的学习就暂时告一段落。后面几个月就聚焦于工作相关的知识了。</p>
<p>经过备考，对软件开发算是有了初步的系统学习了，也掌握了很多工作用的到的知识。</p>
<p>对于学习这个事，我觉得该花钱报班还是得花，投资自己总比炒股亏了好，哈哈！特别是工作的人，大部分人没有毅力按部就班学习，这时候有人带你就可以事半功倍，少走很多弯路。</p>
<p>2025年的话，主要有3个方面要加强，一个是ARM架构的知识，一个是嵌入式软件设计，还有就是信息安全。ARM架构准备找一些视频系统学一下，老是打游击，效果不是很好。嵌入式软件设计和信息安全，可以买软考的教程系统地看一下。</p>
<p>大家有没有想法，可以一起讨论，一起学习进步。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(6)- yang版本升级兼容</title>
    <url>/2022/01/07/2022-20220107-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第六篇, 下面看问题。</p>
<h1 id="yang版本升级兼容"><a href="#yang版本升级兼容" class="headerlink" title="yang版本升级兼容"></a>yang版本升级兼容</h1><p>项目使用yang文件对数据进行管理，在开发阶段，yang文件定义经常变化，许多是不兼容的变化，毕竟在开发阶段许多数据都还没最终确定下来，随着开发的进展需求也渐渐的迭代，免不了出现不兼容的情况。原先使用sysrepo自带的sysrepocfg -U 命令升级yang文件，一旦出现有不兼容的问题，sysrepo就会抛出异常，无法安装新的yang文件，还把那个sysrepo的共享文件给锁死了，无法恢复。</p>
<p>前面开发比较紧张，先提供了一个脚本，在不兼容升级的情况下，调用脚本进行数据清理，然后重新安装yang文件。这样子每次遇到有yang不兼容的情况，都需要进行数据清理。由于yang的不兼容，即使保存了原有的配置，重新导入也是不成功的。</p>
<p>这周项目进入了尾声，手上就留了一两个无法复现的问题，暂时没有思路。抽空先研究一下如何自动升级而又可以保存配置，领导对这个事情也比较重视，亲自盯进度了。</p>
<p>按原先的思路是进行不下去了，一旦有不兼容yang文件升级，libyang库就会报错，看了两天那个libyang的代码还是没有头绪，代码不熟悉，另外代码量也太大了，同时还总会被其他事情打断。只能另想法子了。</p>
<p>先验证了一下把配置拆分，使得可以支持配置按模块导入，但是模块间相互依赖的话，会因为无法通过校验而导入失败，所以还是得整体一块导入。</p>
<p>然后，就是看如何剔除不兼容的配置了。去看了sysrepo的代码，没有找着方法。</p>
<p>正是山重水复疑无路，没想到柳暗花明又一村了。想着这种问题，原厂应该有解决方案才是的。认真研究了一下产商初始的deb的安装包逻辑，找到了一个脚本清理数据的，就是用来剔除不兼容配置的。在每次服务启动的时候，都会调用一下这个脚本，验证了一下，功能还是可用的。这样即使yang不兼容升级，也可以保证兼容部分的配置不会丢失，仅丢失不兼容的那部分配置。</p>
<p>接下来就只需要解决不兼容yang安装报错，导致sysrepo锁死的问题了。时间比较紧，从头梳理sysrepo和libyang的代码逻辑是比较费时的，只能想法子绕过了。既然直接升级会报错，那么就先卸载旧的yang，再安装新的yang。嗯，验证了一下，发现部分被依赖的yang无法卸载，还是会存在部分yang不兼容升级不了的问题。这里，就去更改了sysrepo的源码，让特定的那几个yang即使被依赖也可以正常卸载。因为卸载这个动作，主要就是框架这边会用到，业务正常是不会执行这些动作的。</p>
<p>最后，就是梳理一下完整的启动升级的流程，重构一下整个启动流程的代码，再各种场景验证一下，确保功能都是满足期望的。OK，程序升级改造完成，耗时一周，最终的效果还有个小惊喜，发现改造完之后，升级的速度比之前快了不少。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>有一句话叫做“认知决定思维,思维决定行为,行为决定结果”，工作当中遇到了问题，如何解决问题，解决问题的效果跟我们的知识也是一样的关系。不同的认知，决定不同的处理方式，会达到不同的结果。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>2021小结</title>
    <url>/2022/01/09/2022-20220109-2021/</url>
    <content><![CDATA[<h1 id="2021小结"><a href="#2021小结" class="headerlink" title="2021小结"></a>2021小结</h1><p>2021年过去了，依旧是一个大灾之年，疫情依然笼罩着世界。</p>
<p>对于我而言，也算是一个特别的一年。</p>
<span id="more"></span>

<p>在2021年里，我买了车子，换了工作，换了城市，迁了户口，卖了房子。可以说，对人生有了自己的新的看法，对之后的职业生涯也有了更确定的目标。</p>
<p>2021年于我而言，也是一个充满挑战的一年。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>工作上，换了两公司。</p>
<p>年初到一家电池检测的传统企业作软件开发，接触了新的行业，也做了更为底层的工作。在不到三个月的时间里面，完成了modbus，CABopen协议的学习及协议框架的搭建，在离开的时候受到那位总监不错的评价。过了忙碌的三个月吧，在那边感觉项目管理还是比较混乱的，996的工作节奏，鼓励加班，明说了加薪和晋升与加班挂钩；也做了很多无用功，领导挺喜欢开会的，对细节掌控的太到位了，个人没有发挥的余地。领导是做硬件出生的，对软件管的也很细节，很多不合理的实现，搞得我也无力反驳，太多的扯皮，太多的反软件设计。在那边感觉就是个工具人吧，即使给的工资高一些，行业前景也还不错，但我也觉得是个不合适的工作。工作嘛，就是要找到那种合适的工作，不然就是糟践了自我，对不起自己。工作个几年也不会有什么发展的。及时悬崖勒马，离职了。</p>
<p>第二份工作是之前的老东家了，以前的同事内推，到一个新的部门。2020年的时候也有面试过的，后面因为行业前景、个人发展以及薪资的考量，我选择了前面那家公司。在这家公司，参与了一个新项目的研发，最大的挑战就是这个新字吧，新的语言-python，新的架构平台， 新的领域，新的项目组。跟以往的工作不同的是，缺少了领路人，虽说是用了国外厂商的架构，但是资料也是太少了，况且我去的时候项目已经开始大半年了吧，前期的那些新平台培训通通落下了。这个项目在我的视角里就是很多是空白，需要在工作中学习，边学边用。困难就是项目代码量巨大，开源库多，需要更多的精力学习，扛住更大的工作压力。收获就是学到了挺多之前未涉及，或者没有深入的技能，锻炼了自我学习，应对困难的能力。第一个版本即将结束，也算是熬过来了吧。最近沟通年终绩效，给我打了个B+(部门前百分之三十吧)，感谢领导对我能力的认可。奈何个人生活的原因，明年的时候工作估计又要变动了，感觉挺可惜和遗憾的。</p>
<p>后面在工作上还是期望跟通信、跟协议相关的。编程语言于我而言已经没有那么执着了。然后就是好好的深入一个专业领域，成为该领域的专家。希望能够长久的好好的工作到退休。头衔什么的不是那么重要，工作了十几年，发现自己还是很喜欢编程这个行业的，工作中不断的面对挑战，不断的寻找最优解，头脑一直都在做功的同时，为公司解决问题，实现商业价值，还可以养家糊口。一切都是这么简单直接。没有太多的勾心斗角。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>一切工作都是为了更好的生活。生活的重心是家庭，家庭的重心就是孩子。孩子算是一个大难题，家里没人带小孩，我妈身体不好，丈母娘有孙子要带，只能牺牲老婆在家带娃。相对的经济压力就比较大一些，后面孩子的教育是比较重要的。最后还是决定卖房续力，然后就是找个教育好点的地方，生活成本又可以承受，又可以找到合适的工作的城市。</p>
<p>房子挂出去一个月左右就成交了，略低于市场价成交的，毕竟是端头的户型，小区还不错，价格合适，买家就出手了。然后大概一个多月就完成了解压、过户、放贷、交房。一切都比想象中来的快，卖房就有点儿像卖孩子，内心有点复杂，呵呵，不煽情了。</p>
<p>今年上班的地方离家比较远，都是开车上下班。家和工作地点分别在这个城市的对角，每天花在路上的时间来回的话得一个小时左右，堵车的话就比较慌了。公司那边没有足够的停车位，都是停在露天的空地上，去的晚了就得花个大半小时找车位，有时候停在路边还被交警抄牌罚款，真的很卷。以前没车的时候，骑电动车发现很多人骑电动车，坐公交的时候发现公交也很挤。现在开车了，发现开车的人也是很多。呵呵，这叫什么现象来着，忘了。</p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>新项目需要学习的东西就很多，学习都是为了更好更轻松地工作。由于本身的职位属于支撑类型的，主要服务于业务，需要时常总结文档在内部分享，同时也对知识进行了巩固，收到的咨询多了，逼迫自己更深入的去学习，渐渐的也就成了个半吊子的专家。业余的学习呢，就还是极客时间的专栏了。话说，2021年那个趣谈Linux操作系统终究还是没有刷完一遍，惭愧惭愧。</p>
<h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><p>平常的运动就是带娃在小区里面走几圈，跑步的次数也少了，体重指数上升了，整个脸都圆了，可怕怕。去爬过两三次山吧，其他的运动就没了，整个亚健康的状态。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>2022年开始了，勇往直前吧!</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(7)-文档那些儿事</title>
    <url>/2022/01/16/2022-20220116-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第七篇, 下面看问题。</p>
<h1 id="文档那些儿事"><a href="#文档那些儿事" class="headerlink" title="文档那些儿事"></a>文档那些儿事</h1><p>快要到试点发布了，这周项目上面没有什么新的问题，主要工作就是文档整理，项目试点需要进行文档审计归档，许多指标都要达到可以发布的标准，包括设计文档、集成用例、编码自查、用例自查、BUG闭环率等。</p>
<p>这个项目比较赶，虽然在前期的时候，在项目管理网站上面都已经创建了各种表单。但是人员缺编，开发进度紧，很多表单都没有及时处理，功能开发优先。</p>
<p>我这周的主要工作就是补充或者说是修订这些文档，然后就是走表单了。公司的文档都是有提供模板的，根据模板的说明要求完成文档的编写，再根据设计者的想法观点添加一些重要细节的内容描述，一篇像样的文档就完成了。然后就是上传文件，系统自动通知相关人员评审，最后按照评审意见修改，通过后有专人归档入库。</p>
<p>文档工作完成后，到春节之前几乎就比较空闲了。项目那边开始整理下个阶段的需求，分析需求的方案。都是使用的企业微信的共享文档进行协作，还是挺方便的。</p>
<p>正常这些文档工作在项目各个阶段都是需要闭环掉的。这个也主要是因为公司项目开发遵循CMMI模型，项目比较规范。CMMI就是一个软件项目的方法论吧，算是一些正规的软件公司都遵循的。不同的公司在发展的过程中都有一套自身的软件开发章程，只是流程有所差异。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>工作久了，除了一些业务和技术的积累。主要就是工作中总结了一些自身的方法，经过自身长期使用验证的思路，也就是所谓的经验、方法论。每一个行业都是经过了长久的发展的，都是有对应的前人经验的总结。跟软件行业最相似的就是建筑行业了，建筑行业有各种规范标准，软件行业也有。软件开发有对应的设计原则，流程。掌握了这些工作的原则、方法论，可以很轻松的应对工作中遇到的问题。</p>
<p>这篇文章主要是闲谈, 讲一下这周的工作和自我的观点。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(8)-项目启动优化</title>
    <url>/2022/01/30/2022-20220130-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第八篇。</p>
<h1 id="项目启动优化"><a href="#项目启动优化" class="headerlink" title="项目启动优化"></a>项目启动优化</h1><p>项目版本装机首次启动的时间大概需要耗时8分钟左右，有2分钟是系统启动到调用业务服务的时间，然后有6分钟左右是业务服务启动的耗时。产线那边工人的反馈这个很耗时，需要研发这边尽快优化，领导很重视。项目这边也没人熟悉这块，新人刚到位，还在熟悉代码，作任务交接中，最后还是把任务放给我了，我也做好站好最后一班岗的准备。</p>
<p>首先，分析了启动的流程，发现主要的耗时是一些yang文件的安装及初始配置的导入。yang文件安装耗时大概4分钟，然后还有半分钟是初始配置的导入，最后还有一些是配置下发及业务初始化代码。项目临近发布，修改业务初始化的代码不是很现实。况且占大头的是框架这边的耗时，所以主攻就是yang安装及初始配置导入。</p>
<p>分析yang安装慢，发现主要的因素是由于之前都是使用shell脚本，首先调用命令获取所有已安装的yang，然后过滤对比一个个yang的版本，根据版本决定是update，还是install 样。最终调用命令一个个操作，平均每个命令执行需要耗时8、9秒，大概十几个yang，然后耗时就大概到200s了。我的解法就是尝试使用python代码来进行安装，获取首次安装的实际操作，直接连接sysrepo库，然后按序更新或者安装yang。首先省略了yang获取的命令，然后就是在一个python进程中把需要作的工作一次性搞完，减少多个shell命令的调用。效果比较明显，最终yang的安装耗时缩短到1分钟8秒左右。</p>
<p>然后就是初始配置的导入，同样发现每个模块的初始配置导入命令平均耗时2s左右，然后总共十几个yang模块，耗时也就达到了半分钟。这个思路也比较明确了，同样要把所有的初始配置导入合并到一个命令里面去执行。第一个版本，只是简单的把处理逻辑照搬到python代码中，大概耗时也就缩短了3s左右，耗时依旧需要27s。然后再进一步分析慢的原因，发现主要是由于分文件安装的时候，每个文件也是需要创建独立的连接来处理，连接的建立需要加载已安装的yang及配置，还需要应用上一次计划的变更，耗时比较长。第二个版本，就先对所有的文件配置先合并，然后在一个连接里应用配置，最终优化后的耗时仅需要7s。</p>
<p>最后程序优化后，首次业务启动仅需要2分钟了，外加系统启动的2分钟，时间只剩4分钟，比原先的8分钟少了一半。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>上周得了个感冒，人都快虚脱了。许久不病的人，一旦生病都是比较严重的。因此，就落了一期文章。</p>
<p>临近春节，项目第一个版本也已经开始试点，这个时候，框架基本很少有什么功能性的问题，还是比较稳定。从一月份开始，我主要的任务就是性能优化，然后就是项目交接，文档梳理，带带新人。</p>
<p>上周末部门开了个年会，回顾了这一年来项目开发的一个个里程，到最终的试点发布。经过大半年的加班加点，项目第一个版本终于试点上线。就像是自己养的孩子，突然长大了，就要独立面对生活了，内心有很多难以言表的话语，既期待又担忧。虽然在会上没有得到任何的奖项(毕竟已经提离职走人了)，但是被专门提到并受到感谢，内心还是很感慨激动的。</p>
<p>28号考勤截止，上午很快就把设备啥的归还转移了，然后就在工位上看看linux菜鸟教程。临近下班的时候，被直接上级叫去沟通了年终奖，感谢部门领导的肯定。</p>
<p>说个实话，在这半年多的工作期间，发现了许多优秀的同事，当然也有许多老油条，有些很有潜力的新人，也有迟钝却不主动思考的人。看看年会那些获奖的同事，基本上都是要么加班比较拼的，要么的确有所成就的(这里都是只的研发人员)。但是，并没有发现那些我认为的技术高手，高手都能很快的解决问题，并且没有很多bug。在数据上看，他们的产出并不高，完成的功能，很难被认为具有挑战性，因为他们懂得怎么去做，又不会遇到很大的难题。这种环境下，感觉这些人就是在温水中煮的青蛙，慢慢的，很难出成绩，挺可惜的。</p>
<p>跟老同事聊天，部门缺编严重，但是招人也是很不容易。面试过的一些人，尽管有许多年的工作经验，但是却没有深入技术，很多已然成为工具人，技术水平却没有相应提高，薪资要求还挺高的。招进来的人呢，技术水平也不怎么样，写的代码也是很差，C语言开个临时数组还敢上千K，不怕栈爆掉，也是很无语。俗话说打铁还得自身硬，程序员码农需要一直进行自我修养。这回我也算是裸辞吧，有几个意向的岗位，但最终还没确定好，利用这个假期好好规划梳理一下自己的职业生涯与生活，不能再顾此失彼了，2022年将是职业生涯的重要转折，加油。</p>
<p>过年了，祝大家虎年大吉，虎虎生威! </p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(9)-一台机子的TCP连接上限是多少？</title>
    <url>/2022/02/09/2022-20220209-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第九篇。</p>
<h1 id="一台机子的TCP连接上限是多少？"><a href="#一台机子的TCP连接上限是多少？" class="headerlink" title="一台机子的TCP连接上限是多少？"></a>一台机子的TCP连接上限是多少？</h1><p>刚过完春节，依旧休假状态，没什么工作上的问题。 就是今天看了一篇文章，标题是一台Linux服务器最多支持多少个TCP连接，顺带着在这里小结一下。</p>
<p>理论上，连接的数目上限可以由源目IP、源目端口来决定，具体就是2^32*2^16&#x3D;2^48，是一个很大的数值。具体到实现的时候，每个连接对应一个socket， 每创建一个socket需要消耗一定的资源，包括内存、文件描述符等。如果不加限制的创建连接，会导致系统的资源耗尽而异常。Linux在多个层级限制了可打开文件描述符的个数，包括系统级、用户级、进程级。</p>
<p>除了文件描述符和socket占用的基本内存资源外。如果连接间要发送接收数据的话，还需要预留发送缓冲区、接收缓存区。可以通过<code>sysctl -a | grep tcp</code>查看对应的值。可以通过<code>sysctl -w xxx=value</code>改写。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Keep:~ keep$ sudo sysctl -w net.inet.tcp.sendspace=8192</span><br><span class="line">Password:</span><br><span class="line">net.inet.tcp.sendspace: 131072 -&gt; 8192</span><br><span class="line">Keep:~ keep$</span><br></pre></td></tr></table></figure>

<p>可以通过修改内核的限制参数，设置最大的连接数目。</p>
<p>一台机子可以支持的最大TCP连接数，主要由内核的参数限定。有理论的最大值，但是还受限于系统的各种资源。一般情况下，使用系统默认值就行了，不需要更改。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这个春节假期过得比较宅，天气不是很好，基本上都是阴雨天气，不适宜户外活动。工作了一年，假期好好的放松了一下，在家里睡个懒觉，带带小孩，去超市买些年货、零食，到商场里面儿童游戏场所抓娃娃。年后初三的时候，带孩子回老家三天看下父母，走走亲戚。时间过得还是蛮快的。打工人开始上班了，我也开始准备走向下一站。也祝愿大家新的一年里工作顺利，心想事成。</p>
<p>昨天去打了第三针疫苗，工作日没有很多人排队，还是挺快的。然后，就是顺路到银行去换了一张残币，本来钱也是从ATM里面取出来的，老人家拿去菜市场买菜，大家都不愿意收，ATM也存不进去。先是到建行，那个大堂经理让排队等柜台办理，只开了一个柜台又很多人在排队，果断退出来。再走一段到招商银行，进去之后发现人挺少，保安和经理挺热情的迎上来，感觉态度很好，里面有三四个柜台在受理业务，基本没有排队的人，很快就换好钱了。从这个服务感觉看，招行的满意度可以打满分， 建行只能给不及格了。难怪招行股价蹭蹭的上升了，呵呵。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(10)-数学与算法</title>
    <url>/2022/02/20/2022-20220220-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第十篇。</p>
<h2 id="数学与算法"><a href="#数学与算法" class="headerlink" title="数学与算法"></a>数学与算法</h2><p>最近看了一篇文章，讲的是使用牛顿迭代用O(1)的时间复杂度求解平方根的。文章先是讲了使用二分法不断迭代求解方程的根，具体的就是每次获取到一个中间值之后，就取它的平方与目标值比较，直到获取到符合误差的结果为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">bi_sqrt</span><span class="params">(<span class="type">float</span> x)</span> &#123;</span><br><span class="line">  <span class="type">float</span> l = <span class="number">0.0f</span>, r = x;</span><br><span class="line">  <span class="type">float</span> mid = (l+r)/<span class="number">2.0f</span>;</span><br><span class="line">  <span class="type">float</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">abs</span>(mid - last) &gt; eps) &#123;</span><br><span class="line">    last = mid;</span><br><span class="line">    <span class="keyword">if</span> (mid * mid &gt; x) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = (l+r)/<span class="number">2.0f</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用二分法是可以求得一个近似值的，但是有可能需要迭代次数较多。然后文章就引入了牛顿迭代法。</p>
<p>牛顿迭代法，把求平方根的方程式，映射到对应的函数曲线上，然后使用几何的方法，用导数及切线的方程不断逼近求解。结果就是可以很快的求得一个近似值。呵呵，这边具体数学的知识我已经基本还给老师了。</p>
<p>通过对比牛顿迭代法和二分法，可以明显感觉到大部分情况下牛顿迭代法的运算更快一些。看来数学在求解某些问题的时候，是很有裨益的。前年的时候，看过一本书叫做《数学之美》，里面也涉及了大量使用数学方法解决实际问题的案例，数学真的是一门很美妙的学科。如果当初选择数学作为专业研究，应该很有趣吧。</p>
<p>最近很火的机器学习，人工智能，也是数学在实际问题中的应用，数学专业的人在这个方面有很大的优势，算法其实也就是问题解法的抽象，然后使用代码来实现。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>上周日一个人自驾到了长沙，早上7点多出发，到下午六点多到达。中间在服务区休息了好几次，每次10分钟以上，总计大概一个半小时吧。一个人开车的话，精神清醒是比较重要的，我就买了几罐红牛还有一瓶雀巢咖啡，一路喝过来。没有很困的时候。一路上车不是很多，一直在下着小雨。中午的时候，就吃了几个自带的水煮蛋。开车刚开始还是比较悠哉，福建和江西限速一般都是100，110. 后面到湖南境内，限速都是120了，速度也就提了上来。这是第二次开这么远了，比上一次快了三个多小时，主要是因为没有带小孩，服务区停的少了，时间也更短一些。</p>
<p>到长沙后，住的是民宿。后面的事情主要就是租房子了。</p>
<p>第二天就开始去租房了。用的贝壳找房，上面的房源基本都是真实的。在上面问了几个中介，然后第二天下午去看房子，看了一个下午没有找到心仪的房源。晚上回去之后，总结了一下各个房源的缺点吧。第二天早上梳理了一下自己的租房需求，初步确认一下租房的区域，再到贝壳上面找了几个中介。下午继续去看房了。这次找的中介是贝壳app推荐的，却还是个未毕业的实习生，是很不专业的。我跟他约好了时间地点了，然后我早早的就到了，给他发消息回复总是很慢，在贝壳上面已经给过他电话，他也不舍得给我打个电话(我不知道他号码，不然我就打给他了)，然后他还迟到了半个小时，让我在那边干等了半小时。他给我发了几套房源，我看中了一套，结果他没有那个房源的钥匙，看不了。在带看了一套之后，我就赶紧撤了，不然一个下午就白费了。 再后面，在贝壳上面又约了一个资深的中介，跟他讲了需求，很快就推荐了几套过来，有几套看起来都比较中意。很快的约了时间，马上就安排了带看。晚上回去后，再考虑了一下就确定一套下来了。</p>
<p>看来每一个行业有经验和没经验差别真的很大。新手抓不住用户的需求，做起事情来慢吞吞的，没有一套行之有效的方法。资深人员，一眼就可以确定用户的需求，精准定位，可以很快的响应，做起事情有条理，办成事的概率更大。然后，我作为用户，刚开始需求都是比较模糊的，在被带看了一个下午之后，经过梳理之后才得出了一个比较精确的需求，第二天再去看房，发了条件给中介，中介就可以很快的匹配好房源，而不需要再盲看了。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(三十六) - 网络通信</title>
    <url>/2022/02/21/2022-20220221-linux36/</url>
    <content><![CDATA[<p>这篇文章小结一下使用socket发送和接收网络包的流程。</p>
<span id="more"></span>

<h1 id="发送网络包"><a href="#发送网络包" class="headerlink" title="发送网络包"></a>发送网络包</h1><p>socket在内核中也是一个文件的存在，发送网络包调用的是write系统调用。对文件进行write的操作，最后会调用到对应struct fil e结构的file_operations里的钩子函数。对于socket而言，有对应的file_operations定义。具体的就是调用的sock_write_iter函数。这边就是一层层的函数调用。函数的调用逻辑就不再详细讲了，主要的逻辑流程说一下。</p>
<p>在linux源码，也是有分层这个概念的，发送网络包的函数调用是一层层的往下调。</p>
<ul>
<li>VFS层： write系统调用找到struct file, 然后调用file_operations的write_iter钩子函数。</li>
<li>Socket层： 获取到struct socket，调用ops的sendmsg成员函数。</li>
<li>Sock层： 获取到struct sock, 根据sk_prot值调用对应的发送函数， 比如tcp调用的是tcp_sendmsg.</li>
<li>TCP层： 调用tcp_write_xmit函数， 具体内部实现了tcp的连接的逻辑。这里会封装tcp的头部。</li>
<li>IP层： 调用ip_queue_xmit函数， 这里会封装ip的头部。需要选取路由，确定从哪个网卡发送出去。路由的选取采用的是最长前缀匹配法。最后调用ip_local_out发送。发送的时候，会根据iptables的规则作不同的数据包修改。</li>
<li>MAC层： 获取到MAC地址，然后封装frame头，调用dev_queue_xmit发送二层包，这里是放入到一个队列中。</li>
<li>设备层： 网络包的发送触发一个软中断，调用流程结束。然后就是中断处理函数里面处理队列中的数据，最终将包发送到网络上。</li>
</ul>
<p>这样一个包的发送就完成了。</p>
<h1 id="接收网络包"><a href="#接收网络包" class="headerlink" title="接收网络包"></a>接收网络包</h1><p>网络包的接收跟发送是相反的，是从底层一层层向上传递的。</p>
<ul>
<li>硬件网卡： 接收到网络包之后，把网络包放到环形缓冲区。然后触发中断。</li>
<li>网卡驱动： 调用中断处理函数，把网络包传入到内核协议栈。内核协议栈处理一些二层的逻辑后，传入IP层。网卡接收到第一个包，触发一个中断。然后再中断的处理过程中，还会poll网卡的数据，一直到没有数据了中断结束。等待下一次网络包的到来，进行另一轮中断的处理过程。这样减少中断的次数，免得在中断处理的过程中，又不断的触发中断。</li>
<li>IP层：处理iptables的规则，解析ip头。继续到TCP层</li>
<li>TCP层：根据socket的状态，把数据放到不同的队列中。</li>
</ul>
<p>数据已经放到了TCP层的队列中，然后就是等待上层读取了，这边跟发送又是一样的。</p>
<ul>
<li>VFS层：调用read系统调用读取数据，找到struct file, 然后调用file_operations的read_iter钩子函数。</li>
<li>Socket层： 获取到struct socket，调用ops的recvmsg成员函数。</li>
<li>Sock层： 获取到struct sock, 根据sk_prot值调用对应的发送函数， 比如tcp调用的是tcp_recvmsg.</li>
<li>TCP层： 依次从不同的队列读取网络包。这里包含了TCP的处理逻辑，不深入分析了。</li>
</ul>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>从网络包的发送和接收中，看到了分层系统的应用。所有复杂的逻辑，在软件系统中通过分层都可以来简化。不同协议、设备网卡等，通过分层的框架可以很快的进行适配。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(三十七) - 虚拟化</title>
    <url>/2022/02/23/2022-20220223-linux37/</url>
    <content><![CDATA[<h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p>虚拟化顾名思义就是不是真实的，非实际物理的。而是逻辑上面的一个概念。平常的机器资源大小是固定的，不能灵活改变。而且资源是不能够复用的， 在一台机器上的资源就那么多，系统编号都是按序来的，不能够大家都一样的。怎么说了，其实系统本身也是具有虚拟化的概念，比如进程的虚拟地址，每个进程都有4G的虚拟空间。</p>
<span id="more"></span>

<p>在linux上解决不灵活的问题方法就是创建虚拟机。每个虚拟机都有单独的操作系统，可以指定规格，通过一个命令就可以启动起来。我们平常使用到的VMWare， virtualBox就是虚拟化的具体应用案例。这些软件对于宿主机而言，是一个普通的用户程序，但是在内部运行时，他又好像就是系统程序。</p>
<p>这些软件，充当一个虚拟化的层。大概就是hook了系统的接口，在虚拟机内核调用的都是其提供的接口，虚拟机内核无感知。</p>
<p>虚拟化有三种方式：</p>
<ol>
<li>完全虚拟化，就是模拟假的CPU、内存、网卡、硬盘。凡事都是通过虚拟化软件来转一手执行。</li>
<li>硬件辅助虚拟化，通过设置虚拟机的状态位，让他直接在CPU上执行指令，而不需要虚拟化软件转一手，提高执行的效率。</li>
<li>半虚拟化，不同于前面两种，这中方式内核知道自己是虚拟机，采用特别的接口处理指令。</li>
</ol>
<p>有一种虚拟化软件叫qemu,就是使用的完全虚拟化的方式。现在qemu也结合了硬件辅助虚拟化提高了指令执行的速度，也使用了半虚拟化的方式加快了设备访问的效率。</p>
<p>linux内核提供了一个KVM模块，暴露接口给用户态程序调用，提高指令的执行速度。</p>
<h1 id="虚拟机的创建"><a href="#虚拟机的创建" class="headerlink" title="虚拟机的创建"></a>虚拟机的创建</h1><p>基本的操作跟安装virtualBox虚拟机一样：</p>
<ul>
<li>创建一个虚拟机指定一个名称</li>
<li>设置虚拟内存的大小</li>
<li>创建虚拟的硬盘，指定大小。可以选择固定大小，也可以动态分配的(占用实际的大小)</li>
<li>挂载iOS系统安装盘</li>
<li>选择网络模式，桥接网络的话就是会创建一个虚拟的交换机，把虚拟机网卡和物理网卡连接起来。桥接网络的话虚拟机的ip跟物理机是一个网段的。NAT网络的话，IP不是一个网段的。</li>
</ul>
<p><img src="/images/202202/bridge_net.jpeg" alt="avatar"></p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这里小结了一下虚拟化的原理。具体虚拟化的实现是一个很大的知识面了。以后有需要再深入。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(三十八) - 容器</title>
    <url>/2022/02/24/2022-20220224-linux38/</url>
    <content><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>虚拟化的实现，所有的资源都需要独立模拟出来，实现比较复杂一点。容器是一种隔离的技术，对资源进行了封装，标准化。</p>
<span id="more"></span>

<p>容器实现封闭的环境主要靠两种技术：namespace和cgroup。在不同namespace的应用看到的是不同的IP、用户空间、进程ID等。cgroup的隔离就是使得应用只能使用指定部分的 CPU和内存。运行环境的某个时刻的快照称之为镜像，镜像可以在不同的机器上运行，能够还原当时的运行环境。</p>
<p>目前最为主流的容器实现应用是docker。使用docker，只需要下载开发者制作好的特定系统版本的镜像，我们就可以在docker运行该系统。</p>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>docker的安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker</span><br><span class="line">yun iinstall yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum install docker-ce docker-ce-cli container.io</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>这个是centos安装docker的步骤， 具体系统如何安装docker可以到docker官网上面去看说明。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull &lt;docker-tags&gt;  <span class="comment"># 下载指定tag的镜像</span></span><br><span class="line"></span><br><span class="line">docker images <span class="comment"># 查看已经下载的镜像</span></span><br><span class="line"></span><br><span class="line">docker run -it --entrypoint bash ubuntu:14.04 <span class="comment"># 运行一个docker，执行里面的bash程序</span></span><br><span class="line"></span><br><span class="line">docker -run -d -p 8080:80 nginx <span class="comment"># 运行带有nginx的docker镜像</span></span><br><span class="line"></span><br><span class="line">docker ps <span class="comment"># 查看所有运行的docker</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>镜像的方式可以方便的进行应用的部署，还可以保证应用运行的状况是一样的，相同的镜像在不同的机器上面运行，应该都是一样的效果。<br>docker程序提供了许多参数用于控制容器可以使用的资源，有需要的时候可以深入学习，具体应用一下。容器内部是没有自己的内核的，共用的是宿主机的内核。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>容器的实现使用到了namespace和cgroup技术。记得在上一个项目的时候，有使用到network的namespace，对网络和程序进行隔离。在不同的namespace里面执行命令就在前面加一个ip netns  exec <name>。后面再安排好好看一下这块内容， namespace和cgroup。</p>
<p>至此， 《趣谈linux操作系统》的理论部分终于小结完成。达成一个新目标。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(11)-TCP知识小结(1)</title>
    <url>/2022/02/27/2022-20220227-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，每周都会遇到一些问题，这些问题在大家工作中可能会有许多共性，于我也是一种经验的积累小结。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常工作遇到的问题，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第十一篇。</p>
<h1 id="TCP知识小结"><a href="#TCP知识小结" class="headerlink" title="TCP知识小结"></a>TCP知识小结</h1><p>闲来没事，又逢看了一篇TCP协议的微信文章，讲的很不错的，从头到尾看了一遍，这周的文章就是来用自己的语言重述一下。</p>
<h2 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h2><p>TCP的报文头憨憨端口号、序列号、应答序列号、首部长度、状态标志位、窗口大小、校验和、紧急指针、选项，之后紧跟着数据。</p>
<p>端口号就是用于标识TCP连接的。</p>
<p>序列号就是用于保证网络包时序的，客户端和服务端在建立连接的时候，分别初始化一个序列号，后续序列号递增。</p>
<p>应答序列号表示期望收到的下一个包的序列号。</p>
<p>状态标志位： ACK表示应答序列号有效。除了首个SYN包外，其他包基本上都是置1的。RST 表示需要中断连接。SYN表示希望建立连接，同时序列号字段表示初始包序号。FIN表示结束连接，后续不再有新数据了。</p>
<h2 id="TCP的用途、TCP和UDP区别"><a href="#TCP的用途、TCP和UDP区别" class="headerlink" title="TCP的用途、TCP和UDP区别"></a>TCP的用途、TCP和UDP区别</h2><p>由于IP层是不可靠的，不保证网络包的按序交互及完整性。TCP是一个工作在传输层的可靠的数据传输服务，确保网络包的按序完整接收。TCP是一个面向连接的、可靠的、基于字节流的通信协议。TCP需要维护连接的状态信息，用于保证可靠新和流量控制。</p>
<p>UDP提供无连接的服务，不保证网络包的交付及时序。UDP是以包为单位的。TCP是一对一的连接，UDP支持一对多、一对一、多对多的交互通信。TCP有流量控制，保证数据传输的安全性，UDP则没有，UDP的发送速率不会自适应变化。TCP的首部比较长,可以带有选项，长度&gt;&#x3D;20。UDP的头部长度固定为8个字节。TCP的分片在TCP层处理，UDP的分配在IP层处理。TCP一般用于安全性要求的FTP、HTTPS等应用。UDP用于包总量少的DNS、SNMP，音视频、广播通信。</p>
<p>TCP有首部长度字段，是由于TCP头部可以包含选项，而UDP头部是固定的。UDP含有一个包长度字段，这个字段当然可以从IP长度计算而来，主要还是为了让首部长度为4的倍数。</p>
<h2 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h2><p>连接的建立需要一个三次握手的过程，最开始客户端与服务端都是CLOSED状态，首先服务端先进入LISTEN状态，客户端发送SYN包，自身处于SYN-SENT状态； 然后服务端收到报文后，如果自身是LISTEN状态则发送SYN&#x2F;ACK包，服务端切换到SYN_RECV状态；最后客户端收到了SYN&#x2F;ACk状态，发送一个ACK包(这个包可以有数据内容)，状态切换到ESTABLISHED，服务端收到ACK包后也进入ESTABLISHED。</p>
<p>只有经过三次握手，才可以阻止历史重复连接的初始化，同步双方的序列号、避免资源浪费(不需要4次)。如果在连续发送多个SYN包的时候，服务端在收到旧包的时候，发挥的SYN&#x2F;ACK包中的应答序列号比较小。客户端收到后，判断这是一个旧的连接，发送一个RST给服务端，中断旧的连接。同步序列号需要双方都确定对方知道自己的序列号，至少需要三次报文。</p>
<p>初始序列号是根据一个基于时钟的M值+连接的四元组哈希值。</p>
<p>TCP分片不放在IP层做的主要原因是IP层没有超时重传的机制，不保证包的交付。所以TCP在发送数据超过协商的MSS时，就主动分包了。</p>
<p>SYN攻击就是不断地发送伪装的IP的SYN报文给服务端，导致服务端处理不过来，无法正常服务。解决方案一，可以修改SYN队列的长度、设置SYN_RECV状态连接数，超过连接数后发送RST。解决方案二，就是服务端在SYN队列满的时候，返回SYN_ACK包序列号为一个cookie值，再等收到ACK后校验序列号来确认是否是真的客户端。伪装的客户端是收不到这个SYN_ACK包的，因为他的IP不是伪装的IP，只要真正的客户端才会应答ACK。</p>
<p><img src="/images/202202/tcp_connect.jpeg" alt="avatar"></p>
<h2 id="TCP连接断开"><a href="#TCP连接断开" class="headerlink" title="TCP连接断开"></a>TCP连接断开</h2><p>断开是一个四次挥手的过程。客户端发送一个FIN报文，状态变为FIN_WAIT_1, 服务端收到了FIN报文后，应答ACK，状态变更为CLOSE_WAIT。客户端收到ACK后，状态切换为FIN_WAIT_2。服务端发送一个FIN报文，状态切到LAST_ACK,等待客户端发送ACK。客户端收到FIN报文，应答一个ACK，状态切为TIME_WAIT，等待2MSL后 关闭。服务端收到ACK后切为CLOSE。在Linux中MSL默认为30s，所以TIME_WAIT状态至少是1min。</p>
<p><img src="/images/202202/tcp_disconnect.jpeg" alt="avatar"></p>
<h2 id="TCP保活机制"><a href="#TCP保活机制" class="headerlink" title="TCP保活机制"></a>TCP保活机制</h2><p>如果连接一段时间内没有活动，TCP讲主动发送探测报文，间隔一定时间发送一个，超过几次没有收到回应则认为该连接已经断开，关闭连接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> Keep:~ keep$ sysctl -a | grep keep</span><br><span class="line">net.inet.tcp.keepidle: 7200000</span><br><span class="line">net.inet.tcp.keepintvl: 75000</span><br><span class="line">net.inet.tcp.keepinit: 75000</span><br><span class="line">net.inet.tcp.keepcnt: 8</span><br><span class="line">net.inet.tcp.always_keepalive: 0</span><br><span class="line">net.inet.mptcp.keepalive: 840</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，默认2小时没有活动启动保活机制。间隔75s发送一个探测包，超过8个报文没有应答则断开连接。默认系统最少需要两个小时11分钟才发现连接断开了。</p>
<p>中间如果有收到正常应答，则TCP保活时间重置为两小时。如果收到了RST则连接会被重置。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>回顾了一下TCP的连接与断开、保活机制、TCP和UDP的区别。</p>
<p>这些东西都是协议的定义，了解了这些实现可以在实际工作中借鉴来解决问题。协议都是一些死的东西，但是深入研究一下的话，可以发现其中的奥秘。也可以对相关问题的解决定位提供认知。学习最大的乐趣就是可以学以致用。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
        <category>TCP</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(12)-TCP知识小结(2)</title>
    <url>/2022/03/03/2022-20220303-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常每周都会有一些心得感悟，这些在大家工作中可能会有许多共性。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常学习工作的想法和所得，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第十二篇。</p>
<h1 id="TCP知识小结"><a href="#TCP知识小结" class="headerlink" title="TCP知识小结"></a>TCP知识小结</h1><p>拔掉网线后，TCP状态会发生什么改变？</p>
<p>正常情况下，拔掉网线TCP状态并不会马上改变，状态的改变取决后TCP后续的动作。具体的：</p>
<h2 id="继续发送数据"><a href="#继续发送数据" class="headerlink" title="继续发送数据"></a>继续发送数据</h2><p>如果TCP继续发送数据，而网线保持断开的状态，那么发送方发送的报文不会被接收方收到，发送方也就不会收到应答报文。发送方会启动重传机制，如果在重传了一定次数或者总时间超过了设定的值，那么发送方就会断开连接。之后再插回网线的话，另一方发送的数据被接收后，由于接收方已经断开连接，那么就会回一个RST报文，发送方也断开连接。</p>
<h2 id="不再发送数据"><a href="#不再发送数据" class="headerlink" title="不再发送数据"></a>不再发送数据</h2><p>如果双方都没有开启保活机制，那么状态将一直保持不变。</p>
<p>如果双方都开启了保活机制，那么在网线断开后，TCP的保活机制会开始探测，一直没有插回去的话就会探测到连接断开。在探测过程中，又插回去了，那么连接状态保持不变。</p>
<p>保活机制在上一周的文章里面说过了，这里不继续深究。</p>
<h2 id="杀死进程状态会怎么样"><a href="#杀死进程状态会怎么样" class="headerlink" title="杀死进程状态会怎么样"></a>杀死进程状态会怎么样</h2><p>如果一个进程被杀死了，那么内核会发送FIN报文，进行四次挥手，连接断开。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>没上班的时候，感觉每天过得有点儿没计划。睡觉睡到自然醒，然后临时想着要去哪里就去了。三餐和作息都有一点儿打乱了。这个不是一个健康的状态，大概还要过一周多才去入职，想着开始规划一下作息。不知道大家是怎么做的，我就是决定每天早睡早起， 大概就是22：00-07：00， 早晨起的早天气好的话就去跑个几公里步。然后再想一下今天要做什么，在文本里面用markdown格式记录一下今天的计划。然后就是去按部就班了，过个一段时间再回顾一下，知道自己最近干了啥。</p>
<p>上面是每天的日志。再长一点的计划呢，就是以下几点：</p>
<ul>
<li>好好的把TCP&#x2F;IP的内容回看一下</li>
<li>读完《加密与解密》这本书</li>
<li>今年考个系统架构设计师，应该是下半年了</li>
<li>读完那本吃了好久灰的《Nginx高性能Web服务器详解》了</li>
</ul>
<p>以上是愿景吧，随着工作的需要可能会把更多的精力放在工作相关的内容上面。</p>
<p>最近又开始了跑步，今天在路上跑过了一个高架桥，桥底比较矮吧，悟出一个道理，在人生的道路上，会有许多的困难就像高架桥这样的，如果想要前进就需要低下头来，好好看路，注意脚下，对人生做一下阶段性的回顾总结与计划展望。</p>
<p><img src="/images/202203/aiqiao.jpeg" alt="avatar"></p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
        <category>TCP</category>
      </categories>
  </entry>
  <entry>
    <title>TCP知识小结(3)</title>
    <url>/2022/03/03/2022-20220303-wtcp/</url>
    <content><![CDATA[<p>最近连续看了一个微信公众号<code>小林coding</code>的图解网络的文章，收获挺多。在这里发文小结一下，也方便后续工作中查询。</p>
<span id="more"></span>

<h1 id="如何在不kill进程的情况下关闭TCP连接"><a href="#如何在不kill进程的情况下关闭TCP连接" class="headerlink" title="如何在不kill进程的情况下关闭TCP连接"></a>如何在不kill进程的情况下关闭TCP连接</h1><p>Linux有一个工具killcx， 可以关闭TCP连接。原理就是伪装客户端发送一个SYN报文，一般情况下这个报文的序列号不会是当前滑动窗口中的有效序列号，服务端会回一个ACK报文(称之为Challenge ACK)，带上期待的序列号。收到了ACK报文后，再分别以ACK的序列号和期待的应答序列号发送RST报文给客户端和服务端。客户端和服务端收到了RST报文，都以为是对端发送的，就会关掉连接了。</p>
<p>这个就是黑客干的活，无故切断连接。</p>
<h1 id="序列号为什么每次不一样"><a href="#序列号为什么每次不一样" class="headerlink" title="序列号为什么每次不一样"></a>序列号为什么每次不一样</h1><p>主要是为了避免接收到历史报文后，降低历史报文序列号在有效窗口内的概率。如果不再有效窗口内，报文会被丢弃，而不会对正常流程产生影响。</p>
<h1 id="为什么要有TIME-WAIT状态"><a href="#为什么要有TIME-WAIT状态" class="headerlink" title="为什么要有TIME_WAIT状态"></a>为什么要有TIME_WAIT状态</h1><p>TIME_WAIT状态是主动断开连接方在发送完FIN_ACK后，延迟关闭连接。这个时间足以使两个方向的包在网络中自然消失，而不会留到下一个连接中。同时保证对端可以正常关闭，防止会给对端的FIN_ACK丢失，继续处理对端重传来的FIN报文。</p>
<h1 id="什么情况下SYN报文被丢弃"><a href="#什么情况下SYN报文被丢弃" class="headerlink" title="什么情况下SYN报文被丢弃"></a>什么情况下SYN报文被丢弃</h1><p>在开启了tcp_tw_recycle参数，并且在NAT环境下，造成SYN报文被丢弃。主要是NAT环境下有个PAWS机制，根据IP作防止回绕的，经过NAT后的多个客户端被当成同一个了，无法区分了。</p>
<p>另一种情况就是accept队列慢了，新的syn报文就被丢了。</p>
<h1 id="TCP如何保证按序可靠交付报文"><a href="#TCP如何保证按序可靠交付报文" class="headerlink" title="TCP如何保证按序可靠交付报文"></a>TCP如何保证按序可靠交付报文</h1><p>TCP是一个可靠的传输协议，如何保证可靠呢？传输过程中的数据包破坏、丢包、重复以及分片乱序如何处理的？</p>
<p>TCP通过序列号、确认应答、重传机制、连接管理和窗口控制等机制来保证。</p>
<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>主要有四种重传： 超时重传、快速重传、SACK、D-SACK</p>
<p>超时重传就是发送方在指定时间没有收到接收方应答的ACK。可能是发送包丢失或者ACK包丢失，阻塞了。这个是以时间来衡量是否需要重传的。</p>
<p>快速重传收到多个ACK的下一个报文序列号相同的，触发重传对应的报文或者是之后的报文，具体根据实现来决定。</p>
<p>SACK就是接收方在TCP首部会发送缓存的地图，发送方就可以知道要选择重传那些报文了。</p>
<p>D-SACK 使用SACK告诉发送方哪些数据已经被接收了。发送方就知道哪些包丢了，发送那些包就行了。</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>就是约定一个窗口的大小，在这个范围内不需要等待ACK可以直接发送。提高发送的效率。窗口大小是接收方决定的，就看接收方可以缓存多大的数据包。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>当应用程序来不及取走数据时，可用窗口会渐渐的变成0. 窗口开放后，接收方会发送一个端口开放的ACK。 如果ACK丢了，发送方会超时探测窗口大小，获取到新的窗口后再决定发送数据。</p>
<h2 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h2><p>就是窗口太小了，然后发送方每次只放松很少的数据，占用带宽。可以使用Nagle算法来解决。 只有窗口&gt;&#x3D;MSS 或者数据 &gt;&#x3D;MSS, 并收到了之前的ACK才发送数据。</p>
<p>也可以不让接收方回小窗口的报文。当接收窗口 &lt; MSS&#x2F;2时，直接调整窗口大小为0。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>根据网络拥塞情况，发送方调整发送的数据量，防止过多的报文重传造成网络更加拥塞。 发送方没有再约定时间接收到ACK包，就认为网络拥塞了，然后减小拥塞窗口，相反的 就会加大拥塞窗口。</p>
<p>慢启动<br>拥塞避免<br>拥塞发生<br>快速恢复</p>
<p>后面的具体内容比较详细，不一一记录了。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>TCP是一个复杂的协议，在协议的算法及约定上面也采取了很多巧妙的设定。为了优化协议或者是解决问题，进行了多种考量。同时也提供了许多参数设定。精彩之处，需要多次学习，一点点吃透，有待挖掘更多的知识，先这样了。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
        <category>TCP</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(13) - 系统架构师教程读书笔记(1)</title>
    <url>/2022/03/12/2022-20220312-weekly-SA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常每周都会有一些心得感悟，这些在大家工作中可能会有许多共性。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常学习工作的想法和所得，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第十三篇。</p>
<p>这一周主要就是看了系统架构师教程的前面四章，在专业知识层面上没有其他值得讲的。今天就当作是对本周看书的小结吧。</p>
<h1 id="系统架构设计师教程"><a href="#系统架构设计师教程" class="headerlink" title="系统架构设计师教程"></a>系统架构设计师教程</h1><p><img src="/images/202203/systemdesign.jpeg" alt="avatar"></p>
<p>下面分4个小结简单小结一下。</p>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>系统架构的概念及发展历史。</p>
<p>架构的三要素是构件、模式和规划。</p>
<p>软件系统架构是关于软件系统的结构、行为和属性的高级抽象。描述阶段主要就是描述构成系统的抽象组件、各个构件的连接规则。实现阶段指定软件系统的组织结构和拓扑，显示系统需求和构成组件的对应关系，基本原理。文字看起来比较抽象。</p>
<p>系统架构设计师的定义及职业素养。系统架构师主要着眼于实现和考虑系统的组织协调。要求有对应的技术素质和管理素质。主要配合项目管理师和系统分析师的工作。统筹技术实现及组织协调方面的工作吧。</p>
<h2 id="计算机与网络基础知识"><a href="#计算机与网络基础知识" class="headerlink" title="计算机与网络基础知识"></a>计算机与网络基础知识</h2><p>操作系统的基础知识，操作系统的分类及主要功能。 主要功能：进程管理、文件管理、存储管理、设备管理和作业管理。</p>
<p>数据库系统基础知识，数据库的分类：关系数据库系统、面向对象的数据库系统、对象关系数据库系统。平常用的基本是关系数据库系统多一些。E-R图， 数据库设计步骤等。(需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库应用程序设计)。</p>
<p>计算机网络基础知识：OSI网络体系结构和TCP&#x2F;IP结构。</p>
<p>多媒体技术及应用。</p>
<p>系统性能： 性能指标、性能计算、性能设计、性能评估。不同的部件有不同的性能指标。性能计算的方法有定义法、公式法、程序检测法和仪器检测法。性能设计讲的就是如何进行性能调整，识别约束。阿姆达定律计算系统性能的改进。性能评估，按照一定的步骤，选用一定的度量项目，通过建模和实验，对系统的性能进行各项检测，形成一份结果文档，供性能优化参考。</p>
<p>系统监视， 使用系统命令、查阅系统记录文件、集成命令和文件记录及可视化技术的应用程序。</p>
<h2 id="信息系统基础知识"><a href="#信息系统基础知识" class="headerlink" title="信息系统基础知识"></a>信息系统基础知识</h2><p>信息的定义， 信息是对客观事物变化和特性的反映，是客观事物之间的相互作用和联系的表征，是客观事物经过感知或认识后的再现。看起来是很抽象的。</p>
<p>讲了信息化的定义，内容及对其经济社会的意义。</p>
<p>信息系统工程总体规划， 信息系统工程总体规划的软件架构组成：文件服务器架构、典型的客户&#x2F;服务器两层架构，客户&#x2F;服务器N层架构、基于web的架构。总体架构的实现过程：按规划报告购置和安装计算机系统、建立数据库系统、程序设计、系统转换、试运行。信息化的典型应用有政府信息化的电子政务、企业信息化的电子商务、企业门户等。</p>
<h2 id="系统开发基础知识"><a href="#系统开发基础知识" class="headerlink" title="系统开发基础知识"></a>系统开发基础知识</h2><p>软件开发方法， 软件开发的生命周期：软件定义时期、软件开发时期、软件运行与维护。软件开发过程模型，从某个特定角度提出的软件过程的简单描述：瀑布模型、原型模型、螺旋模型、基于可重用构建的模型、基于面向对象的模型、基于四代技术的模型。敏捷方法，强调以人为本，面向人而非过程，具有适应性和预设性。迭代增量的开发过程。</p>
<p>需求管理，建立软件需求基线，需求规格说明进行版本控制、需求变更控制、需求跟踪。</p>
<p>开发管理，项目的范围、时间、成本控制。配置管理、文档管理、软件开发质量和风险。</p>
<p>设计方法，结构化分析和设计、面向对象的分析设计。</p>
<p>软件的重用。</p>
<p>逆向工程与重构工程。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>以上是大概看的一些知识点。大部分是抽象了一点，需要在正常的工作工程中，相互联系消化。除了操作系统、数据库和计算机基础知识、网络这些知识外，感觉其他的都偏抽象了。考系统架构设计师是一个大工程，万里之行始于足下，一切才刚刚开始呢。。。加油!</p>
<p>这周除了看书，就是到几个景点转了转，橘子洲、烈士公园、西湖。然后就是准备一下入职的材料，去体检，上班踩点。办理了宽带，还入手了一个联想小新Pro16。现在的笔记本都是使用的SSD硬盘，16G内存，使用起来的速度都还不错的，笔记本主要用于带到办公室编码吧，目前感觉那个微软的系统做的也越来越好了。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(14) - DPDK原理</title>
    <url>/2022/03/20/2022-20220320-weekly-dpdk/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常每周都会有一些心得感悟，这些在大家工作中可能会有许多共性。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常学习工作的想法和所得，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第十四篇。</p>
<p>这周开始上班，工作的主要内容就是性能优化相关的。基于硬件加速，编写内核及用户接口，在主流的一些框架上做适配。做的还是服务支持级的内容。</p>
<h1 id="DPDK原理"><a href="#DPDK原理" class="headerlink" title="DPDK原理"></a>DPDK原理</h1><p>DPDK是INTEL公司开发的一款高性能的网络驱动组件，也是工作中需要涉及到的一个框架。DPDK为数据面应用程序提供一个简单方便的，完整的，快速的数据包处理解决方案，主要技术有用户态、轮询取代中断、零拷贝、网卡RSS、访存DirectIO等。</p>
<p>目前很多网络设备底层都是基于DPDK框架，直接从驱动层截取数据包，然后通过用户程序实现功能。</p>
<h2 id="UIO（Linux-Userspace-I-x2F-O）"><a href="#UIO（Linux-Userspace-I-x2F-O）" class="headerlink" title="UIO（Linux Userspace I&#x2F;O）"></a>UIO（Linux Userspace I&#x2F;O）</h2><p>提供应用空间下驱动程序的支持，也就是说网卡驱动是运行在用户空间的，减下了报文在用户空间和应用空间的多次拷贝。DPDK就绕过了Linux内核的网络驱动模块，直接从硬件层面获取数据包到用户态程序，减少了频繁的系统调用和内存拷贝。显著的提高了数据的采集效率。</p>
<p>UIO技术将设备驱动分为用户空间驱动和内核空间驱动两部分，内核空间驱动主要负责设备资源分配、UIO设备注册以及小部分中断响应函数，驱动的大部分工作在用户空间的驱动程序下完成。</p>
<p><img src="/images/202203/dpdk.png" alt="avatar"></p>
<h2 id="用户空间轮询模式（PMD）"><a href="#用户空间轮询模式（PMD）" class="headerlink" title="用户空间轮询模式（PMD）"></a>用户空间轮询模式（PMD）</h2><p><em>传统中断模式</em>： 传统Linux系统中，当网络设备检测到数据帧过来的时候，会使用DMA（直接内存访问）将帧发送到预先分配好的内核缓冲区里面，然后更新相应的接收描述符环，之后产生中断通知有数据帧过来。Linux系统会进行相应的响应，然后更新相应的描述符环，再将接收到的数据帧交给内核中的网络堆栈进行处理，网络堆栈处理完之后会将相应的数据拷贝到相应的套接字，从而数据就被复制到了用户空间，应用程序就可以使用这些数据了；</p>
<p>在发送的时候，一旦用户程序处理完了数据，会通过一个系统调用将数据写入到套接字，将数据从用户空间拷贝到内核空间的缓冲区，交由网络堆栈进行处理，网络堆栈根据需要对数据进行封装并调用网卡设备的驱动程序，网卡设备驱动程序会更新传输描述符环，然后向网卡设备告知有数据帧需要传输。网卡设备会将数据帧从内核中的缓冲区拷贝到自己的缓冲区中并发送到网络链路上，传送到链路上之后，网卡设备会通过一个中断告知成功发送，然后内核会释放相应的缓冲区。 </p>
<p>由于linux系统是通过中断的方式告知CPU有数据包过来的，当网络的流量越来越大，linux系统会浪费越来越多的时间去处理中断，当流量速率达到10G的时候，linux系统可能会被中断淹没，浪费很多CPU资源。</p>
<p><em>DPDK用户空间的轮询模式驱动</em>：用户空间驱动使得应用程序不需要经过linux内核就可以访问网络设备卡。网卡设备可以通过DMA方式将数据包传输到事先分配好的缓冲区，这个缓冲区位于用户空间，应用程序通过不断轮询的方式可以读取数据包并在原地址上直接处理，不需要中断，而且也省去了内核到应用层的数据包拷贝过程。</p>
<p>因此相对于linux系统传统中断方式，Intel DPDK避免了中断处理、上下文切换、系统调用、数据复制带来的性能上的消耗，大大提升了数据包的处理性能。同时由于Intel DPDK在用户空间就可以开发驱动，与传统的在内核中开发驱动相比，安全系数大大降低。因为内核层权限比较高，操作相对比较危险，可能因为小的代码bug就会导致系统崩溃，需要仔细的开发和广泛的测试。而在应用层则相反，比较安全，且在应用层调试代码要方便的多。 </p>
<h2 id="大页内存"><a href="#大页内存" class="headerlink" title="大页内存"></a>大页内存</h2><p>Linux操作系统通过查找TLB来实现快速的虚拟地址到物理地址的转化。由于TLB是一块高速缓冲cache，容量比较小，容易发生没有命中。当没有命中的时候，会触发一个中断，然后会访问内存来刷新页表，这样会造成比较大的时延，降低性能。Linux操作系统的页大小只有4K，所以当应用程序占用的内存比较大的时候，会需要较多的页表，开销比较大，而且容易造成未命中。相比于linux系统的4KB页，Intel DPDK缓冲区管理库提供了Hugepage大页内存，大小有2MB和1GB页面两种，可以得到明显性能的提升，因为采用大页内存的话，可以需要更少的页，从而需要更少的TLB，这样就减少了虚拟页地址到物理页地址的转换时间。 </p>
<p>简单的说，DPDK一次分配大段内存，然后自行管理这块内存。减少了内存缺页引起的中断处理，提高性能。</p>
<h2 id="CPU亲和性"><a href="#CPU亲和性" class="headerlink" title="CPU亲和性"></a>CPU亲和性</h2><p>CPU的亲和性（CPU affinity），它是多核CPU发展的结果。随着核心的数量越来越多，为了提高程序工作的效率必须使用多线程。但是随着CPU的核心的数目的增长，Linux的核心间的调度和共享内存争用会严重影响性能。利用Intel DPDK的CPU affinity可以将各个线程绑定到不同的cpu，可以省去来回反复调度带来的性能上的消耗。 特别的，可以一定程度上减少临界资源的所操作，特定的业务只在指定CPU上执行的话，不会存在资源竞争的情况。</p>
<p>另外，多核机器上面，每个CPU核心本身都存在自己的缓存，缓冲区里存放着线程使用的信息。如果线程没有绑定CPU核，那么线程可能被Linux系统调度到其他的CPU上，这样的话，CPU的cache命中率就降低了。利用CPU的affinity技术，一旦线程绑定到某个CPU后，线程就会一直在指定的CPU上运行，操作系统不会将其调度到其他的CPU上，节省了调度的性能消耗，从而提升了程序执行的效率。 </p>
<h2 id="内存池和无锁环形缓存管理"><a href="#内存池和无锁环形缓存管理" class="headerlink" title="内存池和无锁环形缓存管理"></a>内存池和无锁环形缓存管理</h2><p>此外Intel DPDK将库和API优化成了无锁，比如无锁队列，可以防止多线程程序发生死锁。然后对缓冲区等数据结构进行了cache对齐。如果没有cache对齐，则可能在内存访问的时候多读写一次内存和cache。</p>
<p>内存池缓存区的申请和释放采用的是生产者-消费者模式无锁缓存队列进行管理，避免队列中锁的开销，在缓存区的使用过程中提高了缓冲区申请释放的效率。</p>
<p>主要也是减少了临界资源的锁操作，提升性能。</p>
<h2 id="网络存储优化"><a href="#网络存储优化" class="headerlink" title="网络存储优化"></a>网络存储优化</h2><p>具体的没有深入了解。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这周在新公司开始了新的工作，刚来嘛 就是先看看文档和代码。文档相对比较少，就一两个，稍微浏览了一遍，然后就开始干代码了。</p>
<p>用sourcecounter计算了一下，代码总共近5万行。 </p>
<p>还是用老办法，也是笨办法，快速按文件扫一下代码，5万行需要花个四五天的时间，中间把跟业务无关的机制类的代码详细看看，做做笔记吧。业务相关的就扫描一下，记住一些关键的函数名，等扫描完一遍代码，再找几个入口函数串一下大的流程。这样很快就可以对软件整体架构有了具体的认识，最后就是把软件的整个框架稍微整理一下。接下去就是深入业务细节了，细节这个东西就会遇到比较多的问题了，可以先上网络搜一下，实在搞不清楚的都记录下来，找时间问问老员工。这样子后面就可以比较轻松的增删需求。从中也可以找找优化点啊。</p>
<p>在没有文档的情况下，一头栽进代码里，不求甚解，混个脸熟也好。只有这样才能快速成长，也比较容易对代码流程具象化。这个时间还是需要花的，代码也得认真看。这个就是刻意练习加一万小时定律，不要急躁，沉下心来，看到心里去。</p>
<p>上周末看了一个电视剧《大舜》，不论是虞舜还是大禹，他们治水也是这么个过程。都是走遍了大河的上下游，才能真正了解洪水，了解之后才能找到更好的破解之法。随着华夏的统一，对整个水系网络看的也更全面了，后面就自然而然的找到更好的解法。</p>
<p>从中看出，其实做事情的道理都是相同的。先有了足够的认知，才能有更好的解决办法。开头是比较难的，但是坚持下来结果还是不会辜负这份辛苦的。</p>
<p>在看代码的过程中，也可以看到很多设计模式的影子和原则，万事皆相通。做代码笔记的时候，很容易使用到类图来勾画各个结构体之间的关系，使用面向对象的思想读代码也很受益。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
        <category>DPDK</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(15) - Linux IO</title>
    <url>/2022/03/26/2022-20220326-weekly-io/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常每周都会有一些心得感悟，这些在大家工作中可能会有许多共性。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常学习工作的想法和所得，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第十五篇。</p>
<h1 id="Linux-IO"><a href="#Linux-IO" class="headerlink" title="Linux IO"></a>Linux IO</h1><p>Linux IO机制中，操作系统讲IO数据缓存在文件系统的页缓存中，数据先拷贝到内核空间内，然后再从内核空间拷贝到用户空间使用。比如常用的网络socket的实现，数据从网卡接收到之后，保存到内核空间对应的缓存中，然后通过中断机制通知用户态程序，用户态程序使用read操作把数据拷贝到用户空间，这个就是所谓的缓存IO。 实现分为两步，第一显示等待数据准备，第二讲数据从内核拷贝到进程中。</p>
<p>Linux系统有五种网络模式方案：</p>
<ul>
<li>阻塞IO</li>
<li>非阻塞IO</li>
<li>IO多路复用</li>
<li>信号驱动IO</li>
<li>异步IO</li>
</ul>
<h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>默认情况下，socket都是阻塞的。调用recvfrom的时候应用程序阻塞住，等待内核准备好数据之后，拷贝内核数据到用户缓冲区之后才继续执行。 阻塞IO的特点就是用户程序会block。</p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>通过设置socket使其变为non-blocking的。当进程调用read的时候，如何内核中没有数据，用户程序并不会阻塞住，而是直接返回一个错误。通过判断错误，用户程序知道没有获取到数据，然后可以继续下一次read。一旦内核中有数据，在下一个调用read的时候就会返回数据了。非阻塞IO的特点就是用户程序不会block。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用就是平时遇到的select、poll、epoll等接口。一个进程同时可以监听多个socket，当任意一个socket有数据时，函数就会返回，然后就可以读取socket的数据然后处理。基本原理就是这些函数会不断的轮询所有负责的socket，然后返回数据给用户程序。</p>
<p>这个流程分为两步，首先要等待某个socket有数据，然后获取到具体的socket描述符，然后再通过read函数读取数据。这里需要两个系统调用，select和read。优势就是在同一个流程里面，实现了对多个socket的监听。一般用户程序是被select阻塞住，会设置socket为non-blocking。</p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>用户程序发起异步读的操作之后，就继续其他的处理了。等内核有数据到达后，会将数据拷贝到用户缓冲，然后通过信号的方式通知用户程序，用户程序在信号回调中处理数据。</p>
<h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p>这个用户程序就是完全被动的接收数据。当内核中有数据之后，调用对应的回调函数读取数据处理。</p>
<h2 id="select、poll和epoll"><a href="#select、poll和epoll" class="headerlink" title="select、poll和epoll"></a>select、poll和epoll</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span> <span class="params">(<span class="type">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>
<p>select 函数可以监听三个类型的文件描述符， readfs, writefs, exceptfds。在调用select时程序阻塞住，一直到有描述符有事件产生或者select超时，select函数返回后遍历fds，查找就绪的描述符。select的一个确定就是监听的最大描述符数目有限定为1024， 当然也是可以设置的。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="type">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>poll使用pollfd的结构来描述等待的信息。pollfd并没有最大数量限制，和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>；<span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>；</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>int epoll_create(int size);<br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看&#x2F;proc&#x2F;进程id&#x2F;fd&#x2F;，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
</li>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；<br>函数是对指定描述符fd执行op操作。</p>
</li>
</ol>
<ul>
<li>epfd：是epoll_create()的返回值。</li>
<li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li>
<li>fd：是需要监听的fd（文件描述符）</li>
<li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="type">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);<br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li>
</ol>
<p>今天花时间分别实现了以上三种方式的socket监听，可以参考代码:</p>
<p><a href="https://gitee.com/fishmwei/blog_code/blob/master/socket/iomode.c">https://gitee.com/fishmwei/blog_code/blob/master/socket/iomode.c</a></p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这周比较忙，在不断的输入新的概念和知识，也有一些旧的知识在眼前浮现。Linux的IO模型在编码的时候都会遇到，今天重新复习一下，并一一实现，进一步巩固一下知识点。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>


]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(16) - Linux 内核编译，终于实践了</title>
    <url>/2022/04/02/2022-20220402-kernel/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常每周都会有一些心得感悟，这些在大家工作中可能会有许多共性。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常学习工作的想法和所得，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第十六篇。</p>
<h1 id="Linux内核编译"><a href="#Linux内核编译" class="headerlink" title="Linux内核编译"></a>Linux内核编译</h1><p>最近工作刚开始，领了一台新的机器，然后开机进去后发现找不到那个网卡，没法上网。问了组内的同事，是由于缺少该网卡驱动导致的。然后他就用U盘拷贝了一份内核源码目录到机器上面，更新了一下Linux内核版本，重启之后就可以找到网卡了。他U盘里面的目录是之前编译过的内核源码，然后执行了一下内核安装的命令，更换了内核就好了。</p>
<p>那晚下班后，就琢磨着我学习了Linux操作系统专栏那么久了，还没迈出内核编译的那一步，干就得了。</p>
<p>上网搜了一下怎么进行内核编译，然后就下载了最新版本的内核，在虚拟机里面把那个内核编出来了，并升级了一下虚拟机系统的内核，一步步来也不是那么的复杂，就是开始的时候那个虚拟机编译很慢，后面在网上找啊找，看到有个命令 <code>make -j &lt;n&gt;</code>, 说是可以加快编译速度。我试了一下的确如此，然后我就修改了一下虚拟机的配置，把<code>cpu</code>核和内存都给他加到更大，再编译就更快了，大概过了一个多小时编译完成。下面是具体的操作，还有几个遇到的问题，在博客中记录一下。</p>
<h2 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h2><p>先说一下，我的虚拟机系统是ubuntu。</p>
<p>第一步是下载源码包，使用wget命令就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.17.1.tar.xz</span><br></pre></td></tr></table></figure>

<p>然后就是解压缩编译了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xvf linux-5.17.1.tar.xz</span><br><span class="line">cd linux-5.17.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译的时候发现缺了一些库，这里统一先安装一下</span></span><br><span class="line">apt install libncurses-dev</span><br><span class="line">apt install flex</span><br><span class="line">apt install bison</span><br><span class="line">apt install libssl-dev</span><br><span class="line">apt install libelf-dev</span><br><span class="line">apt install zstd</span><br><span class="line">apt install dwarves</span><br><span class="line">apt install texinfo </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置内核，这个跟buildroot一样， 进去什么也不改，保持默认</span></span><br><span class="line">make menuconfig  </span><br><span class="line"></span><br><span class="line">make -j 12</span><br><span class="line">make bzImage</span><br><span class="line">make modules_install</span><br><span class="line">cp .config /boot/config</span><br><span class="line">make install </span><br><span class="line">reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启之后，执行 <span class="built_in">uname</span> -r 就可以看到内核版本已经变了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote>
<ol>
<li>虚拟机里面编译的时候会有报错</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make[1]: *** 没有规则可制作目标“debian/canonical-certs.pem”，由“certs/x509_certificate_list” 需求。 停止。</span><br><span class="line">make: *** [Makefile:1846：certs] 错误 2</span><br></pre></td></tr></table></figure>

<p>需要修改一下.config文件， 替换debian&#x2F;canonical-certs.pem为空。</p>
<blockquote>
<ol start="2">
<li>failed to load symbols from &#x2F;lib&#x2F;modules&#x2F;5.17.1&#x2F;misc&#x2F;vboxguest.ko: Invalid argument</li>
</ol>
</blockquote>
<p>由于是虚拟机 需要安装工具  设备-&gt;安装增强功能  -&gt; 安装。 安装报错的话，进去虚拟机弹出光盘，然后再试一次， 就可以了。</p>
<p>解决问题之后， 继续<code>make -j 12</code>，直到编译完成。 大概要几个小时，真正的是一个大工程啊。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>很多事情开始了，你会发现没有什么神秘的。</p>
<p>这一周主要的工作还是看代码文档，不过不是linux内核代码，而是DPDK源码，同时也编译了DPDK，运行了对应的test和example。从中发现，这些个开源代码的文档还是挺完全的，面面俱到，根据文档一步步来，耐心看下来，很容易打通一个个流程。学习了一周的DPDK的源码，看到了许多思想，其实也是以往工作中都用到过的技术，不过是应用到了DPDK的场景中了，当然也有新的东西啦。 DPDK的编译运行就在另一篇文章讲，后面慢慢地写出一系列的DPDK源码学习相关的笔记文档，吃透它，嚼碎它，消化它，让他也成为我的一部分，哈哈。</p>
<p>下面是今晚组长请客吃日本料理，第一次正经吃日料，还是蛮新鲜的，全部吃完了。</p>
<p><img src="/images/202204/dinner.jpeg" alt="avatar"></p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
        <category>内核</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(17) - DPDK编译运行</title>
    <url>/2022/04/04/2022-20220404-dpdk-compile/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常每周都会有一些心得感悟，这些在大家工作中可能会有许多共性。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常学习工作的想法和所得，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第十七篇。</p>
<h1 id="DPDK编译"><a href="#DPDK编译" class="headerlink" title="DPDK编译"></a>DPDK编译</h1><p>上周在Ubuntu上面编译安装DPDK这个开源库，配置运行了一下简单的几个application。记录一下。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://fast.dpdk.org/rel/dpdk-21.11.tar.xz</span><br><span class="line">tar dpdk-21.11.tar.xz</span><br><span class="line">cd dpdk-21.11</span><br><span class="line">meson build </span><br><span class="line">cd build</span><br><span class="line">ninja</span><br><span class="line">ninja install</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>

<p>编译的步骤比较简单，具体的DPDK最新的版本使用了meson+ninja的编译工具。需要安装meson, ninja。还对其他库有依赖，主要如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">项目	版本	安装命令</span><br><span class="line">GCC	9.2.1	</span><br><span class="line">pkg-config	&gt;0.27	apt install build-essential</span><br><span class="line">python	&gt;3.5	               apt install python3.6   </span><br><span class="line">meson 	&gt;0.49.2	pip3 install meson</span><br><span class="line">ninja	1.9.0	pip3 install  ninja</span><br><span class="line">pyelftools	&gt; 0.22	pip3 install pyelftools</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这些是基础的依赖，对应到不同的component，还有其他的依赖，可以查看官方文档或者根据编译错误自行安装对应的包。</p>
<p>编译安装完成之后，很多二进制执行文件都会被拷贝到bin目录，在终端下面直接敲dpdk然后tab键可以看到相关的命令。</p>
<h2 id="大页配置"><a href="#大页配置" class="headerlink" title="大页配置"></a>大页配置</h2><p>运行之前必须做的一个是大页内存的配置。</p>
<p>可以通过命令dpdk-hugepages.py -s查看配置的情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:~# dpdk-hugepages.py -s</span><br><span class="line">Node Pages Size Total</span><br><span class="line">0    4     2Mb    8Mb</span><br><span class="line"></span><br><span class="line">Hugepages mounted on /dev/hugepages</span><br><span class="line">root@keep-VirtualBox:~#</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有对应的Pages就是正常的， 上面这个说明系统已经配置了2MB大小的大页，最多支持4个页。否则需要先配置。</p>
<p>可以通过往配置文件写入pages数目，或者使用dpdk-hugepages.py脚本配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 4 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</span><br><span class="line"></span><br><span class="line">dpdk-hugepages.py --setup 8M</span><br></pre></td></tr></table></figure>
<p>这种方式只在当次配置后生效，系统重启后就重置了。</p>
<p>还可以通过内核启动参数配置，就是要写入grub，保证系统启动的时候就分配hugepage内存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano /etc/default/grub</span><br><span class="line"># 在GRUB_CMDLINE_LINUX后添加hugepage=4</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splashi hugepages=4 iommu=pt intel_iommu=on&quot;</span><br><span class="line"></span><br><span class="line">update-grub</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>


<p>系统并不是支持任意大小的pagesz,针对intel的cpu可以通过查看cpu flags来确定，如果有pse则表示支持2MB大小，有pdpe1gb 则支持1GB的大小。IBM power架构支持16MB和16GB。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:/# cat /proc/cpuinfo | grep flags</span><br><span class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid tsc_known_freq pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm cmp_legacy svm cr8_legacy abm sse4a misalignsse 3dnowprefetch vmmcall fsgsbase avx2 invpcid rdseed clflushopt arat nrip_save flushbyasid decodeassists</span><br><span class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid tsc_known_freq pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm cmp_legacy svm cr8_legacy abm sse4a misalignsse 3dnowprefetch vmmcall fsgsbase avx2 invpcid rdseed clflushopt arat nrip_save flushbyasid decodeassists</span><br><span class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid tsc_known_freq pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm cmp_legacy svm cr8_legacy abm sse4a misalignsse 3dnowprefetch vmmcall fsgsbase avx2 invpcid rdseed clflushopt arat nrip_save flushbyasid decodeassists</span><br><span class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid tsc_known_freq pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm cmp_legacy svm cr8_legacy abm sse4a misalignsse 3dnowprefetch vmmcall fsgsbase avx2 invpcid rdseed clflushopt arat nrip_save flushbyasid decodeassists</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到我的虚拟机平台 cpu flags只有pse的。只支持2MB大小的pagesz。</p>
<h2 id="helloworld运行"><a href="#helloworld运行" class="headerlink" title="helloworld运行"></a>helloworld运行</h2><p>直接进入example目录编译运行即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:/# cd /root/dpdk/examples/helloworld/</span><br><span class="line">root@keep-VirtualBox:~/dpdk/examples/helloworld# make</span><br><span class="line">ln -sf helloworld-shared build/helloworld</span><br><span class="line">root@keep-VirtualBox:~/dpdk/examples/helloworld#</span><br><span class="line">root@keep-VirtualBox:~/dpdk/examples/helloworld#</span><br><span class="line">root@keep-VirtualBox:~/dpdk/examples/helloworld#</span><br><span class="line">root@keep-VirtualBox:~/dpdk/examples/helloworld# ./build/helloworld</span><br><span class="line">EAL: Detected CPU lcores: 4</span><br><span class="line">EAL: Detected NUMA nodes: 1</span><br><span class="line">EAL: Detected shared linkage of DPDK</span><br><span class="line">EAL: Multi-process socket /var/run/dpdk/rte/mp_socket</span><br><span class="line">EAL: Selected IOVA mode &#x27;PA&#x27;</span><br><span class="line">EAL: VFIO support initialized</span><br><span class="line">TELEMETRY: No legacy callbacks, legacy socket not created</span><br><span class="line">hello from core 1</span><br><span class="line">hello from core 2</span><br><span class="line">hello from core 3</span><br><span class="line">hello from core 0</span><br><span class="line">root@keep-VirtualBox:~/dpdk/examples/helloworld#</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>今天小结了一下DPDK的源码编译安装、大页配置及helloworld的运行。</p>
<p>清明节放假，宅家里好好学习，天天向上！活到老，学到老了。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>DPDK</category>
      </categories>
  </entry>
  <entry>
    <title>TailQ的使用及ssh配置等skills</title>
    <url>/2022/04/05/2022-20220405-tailq/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近看代码的时候看到了许多地方使用TailQ这个数据结构来组织数据，在过往的项目中一般都是直接使用的list这个链表的。稍微看了 一下代码的实现， 其实就是一个双向链表的实现，抽象出链表头保存头尾元素，然后链表的关系结构存放在具体节点的field域，提供一些常用宏的封装而已。链表成员关系主要如图所示：</p>
<span id="more"></span>

<p><img src="/images/202204/tailq.png" alt="avatar"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>稍微写了一个demo示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TAILQ_ENTRY(node) link;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct &#123;</span></span><br><span class="line"><span class="comment">        struct node **prev;</span></span><br><span class="line"><span class="comment">        struct node *next;</span></span><br><span class="line"><span class="comment">    &#125; link;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TAILQ_HEAD(heads, node); <span class="comment">// define a struct for tailq list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heads</span> &#123;</span>								 </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">tqh_first</span>;</span>	<span class="comment">/* first element */</span>			 </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">tqh_last</span>;</span>	<span class="comment">/* addr of last next element */</span>		 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heads</span> <span class="title">my_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">https://gcc.gnu.org/onlinedocs/gcc-6.2.0/gcc/Common-Function-Attributes.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">__attribute__((constructor(<span class="number">101</span>))) <span class="type">void</span> <span class="title function_">init101</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call %s\r\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor(<span class="number">102</span>))) <span class="type">void</span> <span class="title function_">init102</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call %s, init tailq my_list\r\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    TAILQ_INIT(&amp;my_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="type">void</span> <span class="title function_">dealloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call dealloc free tail my_list\r\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">ele</span> =</span> TAILQ_FIRST(&amp;my_list);</span><br><span class="line">    <span class="keyword">while</span> (ele) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prev</span> =</span> ele;</span><br><span class="line">        ele = TAILQ_NEXT(ele, link);</span><br><span class="line">        TAILQ_REMOVE(&amp;my_list, prev, link);</span><br><span class="line">        <span class="built_in">free</span>(prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After dealloc , list empty %d\r\n&quot;</span>, TAILQ_EMPTY(&amp;my_list)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">ele</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter %d elememt:\r\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;value);</span><br><span class="line"></span><br><span class="line">        ele = (<span class="keyword">struct</span> node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        ele-&gt;value = value;</span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;my_list, ele, link);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TailQ content:\r\n&quot;</span>);</span><br><span class="line">    TAILQ_FOREACH(ele, &amp;my_list, link) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \r\n&quot;</span>, ele-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After main , list empty %d\r\n&quot;</span>, TAILQ_EMPTY(&amp;my_list)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc tailq.c -o q</span></span><br><span class="line"><span class="comment">./q</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>执行效果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">call init101</span><br><span class="line">call init102, init tailq my_list</span><br><span class="line">enter 0 elememt:</span><br><span class="line">3</span><br><span class="line">enter 1 elememt:</span><br><span class="line">4</span><br><span class="line">enter 2 elememt:</span><br><span class="line">5</span><br><span class="line">enter 3 elememt:</span><br><span class="line">2</span><br><span class="line">enter 4 elememt:</span><br><span class="line">3</span><br><span class="line">TailQ content:</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">After main , list empty 0</span><br><span class="line">dealloc free tail my_list</span><br><span class="line">After dealloc , list empty 1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>学习一个数据结构或者新的API接口，最好的方法就是搞懂其原理后，动手写个小demo，化抽象为具体，真切的体验一下。代码中还掺杂了对__attribute的使用。</p>
<h1 id="更多2"><a href="#更多2" class="headerlink" title="更多2"></a>更多2</h1><p>刚入职的时候配置那个gitlab之后，ssh死活连不上去， 原来是为了安全，gitlab的ssh端口号改了，不是默认的22。按照默认的配置是连接不上去的， 这个时候可以在~&#x2F;.ssh&#x2F;config里面指定配置端口号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:~/.ssh# cat config</span><br><span class="line">Host gitlab.xxx.com.cn</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">User keep</span><br><span class="line">Port 88088</span><br><span class="line"></span><br><span class="line">Host gitee.com</span><br><span class="line">IdentityFile ~/.ssh/id_ed25519_qq</span><br><span class="line">User fishmwei</span><br></pre></td></tr></table></figure>
<p>可以配置不同的证书、端口号以及对应的用户名，真的很方便，又学了一招。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a><br>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（52）- 《CPU通识课》读后小结</title>
    <url>/2024/03/16/2024-20240316-know-cpu/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天把前一段时间从图书馆借的《CPU通识课》这本书看了一遍，这是一本科普类书籍，还是蛮适合IT人员阅览的。作者在讲解的过程中会结合自身的实践，感受不会很空洞。<br>内容还是挺多的，包含CPU的概览、术语、架构原理、生产制造的流程、相关企业及软件生态。</p>
<span id="more"></span>

<p>个人在阅读的过程中也稍微记了一些笔记，下面小结一下。</p>
<h2 id="CPU性能"><a href="#CPU性能" class="headerlink" title="CPU性能"></a>CPU性能</h2><p>从最早的MIPS和MFLOPS方法(指令功能不同，不同指令测出来的结果不一)，到通用的标准SPEC CPU测试。<br>从只对CPU进行性能测试，到考虑CPU与外设、内存数据交换的因素考量， 如stream可以用于测试CPU访问内存的性能。<br>从硬件测试到软件的测试，不同厂商还会优化编译器，如intel的icc，为了测试而测试，当然能体现其技术能力，但不一定适用于通用场景。</p>
<p>还提到过时的UnixBench测试，项目老旧、测试原理不能体现最新架构的性能。</p>
<h2 id="CPU制作"><a href="#CPU制作" class="headerlink" title="CPU制作"></a>CPU制作</h2><p>制作计算机 &#x3D; 制作CPU +  制作操作系统，相较于CPU，操作系统难度更大。</p>
<p>CPU企业制作CPU的几种方式：1）自主研发指令集；2）获取指令集授权，研发兼容CPU；3）单纯的SOC拼装，完全用他人的CPU。</p>
<p>做CPU更难的还是在于生态的建立，有人用才卖的好。</p>
<h2 id="CPU指令集"><a href="#CPU指令集" class="headerlink" title="CPU指令集"></a>CPU指令集</h2><p>RISC和CISC指令集，X86代表CISC， ARM、MIPS、RISC-V等代表RISC；RISC精简指令集指令格式固定,个数少，寄存器要多，指令库庞大。CISC指令变长，执行周期不一。</p>
<p>intel对外提供CISC，内部先预译码，再转RISC。</p>
<p>指令5级流水线：指令预取、指令译码1、指令译码2、指令执行、结果回写。</p>
<h2 id="CPU术语"><a href="#CPU术语" class="headerlink" title="CPU术语"></a>CPU术语</h2><p>IP核： 一个设计好的电路模块，实现了预定义的功能，模块化，可以在不同的芯片中复用。</p>
<p>SOC：片上系统，在一个芯片中集成了多个电路模块，组合而成的电路系统。</p>
<p>功耗： 电子设备在单位时间内所消耗的电能。降功耗的方法有三种：1）使用更先进的工艺；2）操作系统做电源管理；3）根据运行负载自动调整主频； 还可以使用大小核的设计。</p>
<p>摩尔定律：集成电路的晶体管每一两年会翻一倍。目前已经达到极限了，5nm级已经只有几个原子大小了，没法继续操控了，会导致不可靠。</p>
<p>intel Tick-Tock策略： 每两年更新换代一下。 先制造工艺提升，再继续微结构设计优化。</p>
<p>异构计算：一个是专人专事，不同计算单元组合完成一个任务，另外就是把软件的功能交给硬件做，提高特定功能的性能。比如国密的专用指令，其他专用处理器。</p>
<p>向量： 一条指令可用同时计算两组以上的操作数。</p>
<p>标量：一条指令只可以计算一组操作数。</p>
<p>多核： 在一个芯片中集成多个独立的CPU单元。</p>
<p>多路： 一个主板上安装多个CPU芯片。</p>
<p>超线程：硬件多线程，通过CPU增加执行单元实现。</p>
<h2 id="CPU设计"><a href="#CPU设计" class="headerlink" title="CPU设计"></a>CPU设计</h2><p>硬件设计比软件设计更难：1）软件语言更方便使用；2）电路系统比软件系统更负责，不易分层；3）电路存在大量有状态模块，复杂度高于软件的无状态模块。</p>
<p>EDA（电子设计自动化）工具，可用简化设计工作，还可以用于验证（仿真），对设计代码进行自动化检查。</p>
<p>国内EDA厂商产品远落后于国外先进厂商，占有率也很低。存在开源的EDA软件，可用进行简单芯片的制作。</p>
<p>CPU设计语言Verilog，Verilog对于CPU设计师而言，就先C语言对于软件设计师一样。</p>
<p>Verilog语言(RTL)描述了抽象的电路结构，需要使用工具将其转换为门单元，得到网表。以网表为分界点，CPU设计的前后端阶段。网表经过布局布线，确定晶体管位置，得到版图。版图交给流片厂商。</p>
<p><img src="/images/202403/cpu_rtl.png" alt="cpu_rtl"></p>
<p>可以用FPGA验证CPU功能， 也可以使用模拟器实现。由于主频的限制，运行的都比较慢。</p>
<h2 id="计算机系统相关"><a href="#计算机系统相关" class="headerlink" title="计算机系统相关"></a>计算机系统相关</h2><p>并行内存结构：a)SMP，所有CPU访问相同的内存，CPU和内存通过高速互联总线进行数据传递；b)NUMA，每个CPU都安装内存条，CPU之间通过互联网络连接。</p>
<p><img src="/images/202403/cpu_arch.png" alt="cpu_arch"></p>
<p>Cache一致性： a)强一致性,必须所有cpu更新后才处理后续的指令；b)弱一致性，不需要等待，不同cpu可能存在cache不一致的问题，需要软件使用内存同步指令，大部分并行CPU都是弱一致性的。</p>
<h2 id="CPU生态"><a href="#CPU生态" class="headerlink" title="CPU生态"></a>CPU生态</h2><p>一流的企业做标准，二流的企业做品牌，三流的企业做产品。我国企业大部分是二三流芯片企业。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这是2024年以来的第一篇blog，只能说自己懒惰了吧，但也的确比较忙了，时间比较紧张了。</p>
<p>去年底定的计划，2024上半年考那个系统分析师，跟着报了个班，系统地学习了相关的体系知识，每周都有2次课，课前要预习，课后要做题。</p>
<p>周末大部分时间都在看学习资料，刷题目，复习视频背概念，准备写论文等等。而且不下雨的话，都要去跑个十公里，锻炼一下身体。</p>
<p>工作上面也是忙，研发任务还是比较紧的，也承担了更多的事情，驱动相关的知识也还在补漏。</p>
<p>每周都过得很饱满，刷刷地就过去了。</p>
<p>总之，IT这行就得不停的学习，才能让自己更充实，不被淘汰吧。</p>
<p>当然，时间还是得挤一挤的，对自己再狠一些。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(18)-测试框架的学习小结</title>
    <url>/2022/04/14/2022-20220414-weekly-test-framework/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常每周都会有一些心得感悟，这些在大家工作中可能会有许多共性。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常学习工作的想法和所得，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第十八篇。</p>
<h1 id="DPDK测试框架"><a href="#DPDK测试框架" class="headerlink" title="DPDK测试框架"></a>DPDK测试框架</h1><p>这一周看了DPDK的测试框架，主要是在app&#x2F;test*这些目录下实现的application。</p>
<p>DPDK的测试框架的模型是基于XUnit模型实现的， 跟其他大多数的测试框架一样，分为测试套(test suite)和测试用例(test case)两个层级的概念。测试套下面可以包含多个测试套和多个测试用例，典型的树状结构，跟文件系统的目录结构是一样的。</p>
<p>测试套的执行流程是 suite-&gt;setup … unit_test_suite_runner … suite-&gt;teardown。setup和teardown分别是suite对应的资源的申请初始化和释放。unit_test_suite_runner就是嵌套的执行其下的测试套和测试用例。</p>
<p>测试用例的执行流程 case-&gt;setup … case-&gt;testcase&#x2F;case-&gt;testwithdata … case-&gt;teardown。setup和teardown分别是case对应的资源的申请初始化和释放。testcase、testwithdata分别对应没有数据和有传入数据的用例执行。具体的就是业务函数的执行，然后对比输出结果和期望结果。返回值有三种， TEST_SKIP, TEST_SUCCESS, TEST_FAIL，分别表示不支持该测试功能，支持并且执行成功，支持但是执行失败。</p>
<p>最后，会输出用例的执行情况。</p>
<p>dpdk-test这个application 还支持命令行，通过绑定命令行和一个测试功能集的入口函数，可以很方便的执行指定的功能集测试用例。效果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@keep-VirtualBox:~/dpdk/build# dpdk-test -c 7 --vdev crypto_openssl --log-level 7 cryptodev_openssl_asym_autotest</span><br><span class="line">EAL: Detected CPU lcores: 12</span><br><span class="line">EAL: Detected NUMA nodes: 1</span><br><span class="line">EAL: Detected static linkage of DPDK</span><br><span class="line">EAL: Multi-process socket /var/run/dpdk/rte/mp_socket</span><br><span class="line">EAL: Selected IOVA mode &#x27;PA&#x27;</span><br><span class="line">EAL: VFIO support initialized</span><br><span class="line">CRYPTODEV: Creating cryptodev crypto_openssl</span><br><span class="line"></span><br><span class="line">CRYPTODEV: Initialisation parameters - name: crypto_openssl,socket id: 0, max queue pairs: 8</span><br><span class="line">TELEMETRY: No legacy callbacks, legacy socket not created</span><br><span class="line">APP: HPET is not enabled, using TSC as default timer</span><br><span class="line"><span class="meta prompt_">RTE&gt;</span><span class="language-bash">&gt;cryptodev_openssl_asym_autotest</span></span><br><span class="line"> + ------------------------------------------------------- +</span><br><span class="line"> + Test Suite : Crypto Device OPENSSL ASYM Unit Test Suite</span><br><span class="line"> + ------------------------------------------------------- +</span><br><span class="line"></span><br><span class="line">xform type: rsa</span><br><span class="line">===================</span><br><span class="line">operation supported - encrypt decrypt sign verify modlen: min 30 max 0 increment 1</span><br><span class="line"></span><br><span class="line">xform type: modexp</span><br><span class="line">===================</span><br><span class="line">operation supported - modlen: min 0 max 0 increment 1</span><br><span class="line"></span><br><span class="line">xform type: modinv</span><br><span class="line">===================</span><br><span class="line">operation supported - modlen: min 0 max 0 increment 1</span><br><span class="line"></span><br><span class="line">xform type: dh</span><br><span class="line">===================</span><br><span class="line">operation supported - priv_key_generate pub_key_generate sharedsecret_compute modlen: min 0 max 0 increment 1</span><br><span class="line"></span><br><span class="line">xform type: dsa</span><br><span class="line">===================</span><br><span class="line">operation supported - sign verify modlen: min 0 max 0 increment 1</span><br><span class="line"> + TestCase [ 0] : test_capability succeeded</span><br><span class="line"> + TestCase [ 1] : test_dsa succeeded</span><br><span class="line">USER1: Test Public and Private key pair generation</span><br><span class="line">USER1: Test Public Key Generation using pre-defined priv key</span><br><span class="line">USER1: Test Private Key Generation only</span><br><span class="line">USER1: Test shared secret compute</span><br><span class="line"> + TestCase [ 2] : test_dh_keygenration succeeded</span><br><span class="line"> + TestCase [ 3] : test_rsa_enc_dec succeeded</span><br><span class="line"> + TestCase [ 4] : test_rsa_sign_verify succeeded</span><br><span class="line"> + TestCase [ 5] : test_rsa_enc_dec_crt succeeded</span><br><span class="line"> + TestCase [ 6] : test_rsa_sign_verify_crt succeeded</span><br><span class="line"> + TestCase [ 7] : test_mod_inv succeeded</span><br><span class="line"> + TestCase [ 8] : test_mod_exp succeeded</span><br><span class="line">  0) TestCase Modular Exponentiation (mod=128, base=20, exp=3, res=128) PASS</span><br><span class="line">  1) TestCase Modular Exponentiation (mod=60, base=50, exp=40, res=60) PASS</span><br><span class="line">  2) TestCase Modular Exponentiation (mod=8, base=65, exp=17, res=8) PASS</span><br><span class="line">  3) TestCase Modular Exponentiation (mod=100, base=150, exp=192, res=100) PASS</span><br><span class="line">  4) TestCase Modular Exponentiation (mod=255, base=20, exp=10, res=255) PASS</span><br><span class="line">  5) TestCase Modular Exponentiation (mod=112, base=257, exp=43, res=112) PASS</span><br><span class="line">  6) TestCase Modular Exponentiation (mod=299, base=240, exp=321, res=299) PASS</span><br><span class="line">  7) TestCase Modular Exponentiation (mod=448, base=50, exp=40, res=448) PASS</span><br><span class="line">  8) TestCase Modular Exponentiation (mod=19, base=500, exp=35, res=19) PASS</span><br><span class="line">  9) TestCase Modular Inverse (mod=128, base=20, exp=3, inv=128) PASS</span><br><span class="line">  10) TestCase RSA Encryption Decryption (n=128, pt=20, e=3) EXP, QT PASS</span><br><span class="line"> + TestCase [ 9] : test_one_by_one succeeded</span><br><span class="line"> + ------------------------------------------------------- +</span><br><span class="line"> + Test Suite Summary : Crypto Device OPENSSL ASYM Unit Test Suite</span><br><span class="line"> + ------------------------------------------------------- +</span><br><span class="line"> + Tests Total :       10</span><br><span class="line"> + Tests Skipped :      0</span><br><span class="line"> + Tests Executed :    10</span><br><span class="line"> + Tests Unsupported:   0</span><br><span class="line"> + Tests Passed :      10</span><br><span class="line"> + Tests Failed :       0</span><br><span class="line"> + ------------------------------------------------------- +</span><br><span class="line">Test OK</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DPDK的测试用例里面的数据都是在代码中写死了的，数据比较单一，场景有可能覆盖不全。</p>
<h1 id="libkcapi测试框架"><a href="#libkcapi测试框架" class="headerlink" title="libkcapi测试框架"></a>libkcapi测试框架</h1><p>libkcapi是对内核加密框架的封装，提供给用户态程序调用的库。这个库的测试用例采用了对比测试的方式。通过从&#x2F;dev&#x2F;urandom设备读取随机数据，然后分别使用libkcapi的程序和openssl程序对数据进行加密、解密，对比两个程序输出的结果是否一致来判断libkcapi的用例是否成功。</p>
<p>libkcapi的测试逻辑使用的shell脚本编写的，可以很方便进行调试。执行用例的时候，生成随机数据保存到临时文件中，然后通过命令行参数传递到程序中执行，输出结果到另一个临时文件，最后通过计算临时文件的sha1sum值来对比内容是否相同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成随机数据到指定的文件</span></span><br><span class="line">gen_orig()</span><br><span class="line">&#123;</span><br><span class="line">	local size=$1</span><br><span class="line">	touch $ORIGPT</span><br><span class="line">	dd if=/dev/urandom of=$ORIGPT bs=$size count=1 2&gt;/dev/null</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对比文件的<span class="built_in">sha256sum</span>摘要值</span></span><br><span class="line">diff_file()</span><br><span class="line">&#123;</span><br><span class="line">	local orighash=$(sha256sum $1 | cut -d &quot; &quot; -f1)</span><br><span class="line">	local genhash=$(sha256sum $2 | cut -d &quot; &quot; -f1)</span><br><span class="line">	shift</span><br><span class="line">	shift</span><br><span class="line"></span><br><span class="line">	if [ x&quot;$orighash&quot; = x&quot;$genhash&quot; ]</span><br><span class="line">	then</span><br><span class="line">		echo_pass_local &quot;$@&quot;</span><br><span class="line">	else</span><br><span class="line">		echo_fail_local &quot;$@: original file ($orighash) and generated file ($genhash)&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时文件的清理 用到了<span class="built_in">trap</span>命令</span></span><br><span class="line">init_setup()</span><br><span class="line">&#123;</span><br><span class="line">	trap &quot;rm -f $TSTPREFIX*; exit&quot; 0 1 2 3 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">CR is also character</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Hex key string: 3031323334353637383961626364650a</span></span><br><span class="line">	echo -n &quot;0123456789abcdef&quot; &gt; $KEYFILE_128</span><br><span class="line">	OPENSSLKEY128=&quot;0123456789abcdef&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Hex key string: 303132333435363738396162636465663031323334353637383961626364650a</span></span><br><span class="line">	echo -n &quot;0123456789abcdef0123456789abcdef&quot; &gt; $KEYFILE_256</span><br><span class="line">	OPENSSLKEY256=&quot;0123456789abcdef0123456789abcdef&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相比DPDK的测试框架， libkcapi采用随机数据，然后跟openssl的运算结果对比，相对比较灵活，覆盖场景比较全。不过，需要增加对openssl这个额外的库的学习成本，也是一种成长吧。</p>
<p>感受一下libkcapi的测试效果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:~/code/libkcapi/test# ./hasher-test.sh</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Failure on empty checker file for md5sum</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Failure on empty line checker file for md5sum</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Parsing checker file with asterisk with md5sum</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Checker file &#x27;-&#x27; interpretation with md5sum</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Input file &#x27;-&#x27; interpretation with md5sum</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Failure on empty checker file for sha1sum</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Failure on empty line checker file for sha1sum</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Parsing checker file with asterisk with sha1sum</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Checker file &#x27;-&#x27; interpretation with sha1sum</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Input file &#x27;-&#x27; interpretation with sha1sum</span><br><span class="line">[PASSED: 64-bit - 5.17.1] Failure on empty checker file for sha256sum</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个就是简单的输出每个用例的执行结果，没有统计功能。不过看起来还比较清晰明了。</p>
<p>这两个框架每次都是批量的执行用例，没办法单独执行特定的用例。感觉用shell脚本的话，还是比较方便的。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>开源库基本上都是有对应的测试用例。通过剖析其实现的原理，我们也可以借鉴来为自研的代码库搞一个测试用例。实现测试驱动开发的目的，还可以在更改代码后，进行回归测试，裨益多多。</p>
<p>各种语言也有各自流行的测试框架，基本上也都是基于XUnit模型。 基于setup, test_case_fn，teardown的执行流程。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>DPDK</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(19)-docker基础</title>
    <url>/2022/04/24/2022-20220424-weekly-docker/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常每周都会有一些心得感悟，这些在大家工作中可能会有许多共性。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常学习工作的想法和所得，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第十九篇。</p>
<p>最近有几次把虚拟机给搞死了，浪费了时间又重新安装了虚拟机。就是我在编译GmSSL这个库的时候，按默认的编译成动态库的话，他会替换系统自带的openssl.so，然后重启的时候，系统就嗝屁了。好像是找不到正确的版本依赖了。GmSSL内部自己依赖了一个openssl的版本，直接把系统的so替换了，应该是版本不兼容导致启动失败的。</p>
<p>嗯，然后就想着搞个docker容器来作实验，花了点时间看了一下docker。</p>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>docker和虚拟机都是虚拟化的产物。但是虚拟机本身自带了操作系统，操作系统会额外消耗资源。虚拟机完全虚拟化了一套虚拟的资源出来使用。而docker的容器更加轻量级，启动也更快。docker容器共用宿主机的操作系统，不需要额外的消耗。在同样的资源下，容器更加方便、轻量，能够运行更多的实例。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>docker是一个虚拟化的平台，通过docker可以管理镜像，然后通过镜像可以创建容器。镜像就相当于类模板，而容器就是模板的一个实例，基于同一个镜像可以创建多个容器。不同的容器有特定的ID后者名称来定位区分。当然，镜像也有镜像的ID和名称、标签来区分。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | sh</span><br><span class="line">usermod -aG docker keep </span><br></pre></td></tr></table></figure>

<p>直接运行就可以安装了。</p>
<h2 id="pull镜像"><a href="#pull镜像" class="headerlink" title="pull镜像"></a>pull镜像</h2><p>安装之后，需要从仓库pull镜像，镜像由不同的组织上传，提供不同的应用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:/etc/docker# docker pull ubuntu</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">8527c5f86ecc: Pull complete</span><br><span class="line">Digest: sha256:2a7dffab37165e8b4f206f61cfd984f8bb279843b070217f6ad310c9c31c9c7c</span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br><span class="line">docker.io/library/ubuntu:latest</span><br><span class="line">root@keep-VirtualBox:/etc/docker#</span><br><span class="line">root@keep-VirtualBox:/etc/docker# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">ubuntu       latest    3f4714ee068a   28 hours ago   77.8MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@keep-VirtualBox:/etc/docker# docker container run -it ubuntu /bin/bash</span><br><span class="line">root@438ebf3447a6:/#</span><br><span class="line">root@438ebf3447a6:/#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ctrl + PQ 退出容器， 容器依旧在运行</span></span><br><span class="line"></span><br><span class="line">root@438ebf3447a6:/# root@keep-VirtualBox:/etc/docker#</span><br><span class="line">root@keep-VirtualBox:/etc/docker#</span><br><span class="line">root@keep-VirtualBox:/etc/docker# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">438ebf3447a6   ubuntu    &quot;/bin/bash&quot;   2 minutes ago   Up 2 minutes             naughty_thompson</span><br><span class="line">root@keep-VirtualBox:/etc/docker#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接回容器</span></span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:/etc/docker# docker exec -it 438ebf3447a6 bash</span><br><span class="line">root@438ebf3447a6:/#</span><br><span class="line">root@438ebf3447a6:/#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">root@keep-VirtualBox:/etc/docker# docker stop naughty_thompson</span><br><span class="line"></span><br><span class="line">naughty_thompson</span><br><span class="line">root@keep-VirtualBox:/etc/docker#</span><br><span class="line">root@keep-VirtualBox:/etc/docker# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">root@keep-VirtualBox:/etc/docker# docker ps -a   // -a 列出所有容器 包括停止的容器</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                        PORTS     NAMES</span><br><span class="line">438ebf3447a6   ubuntu    &quot;/bin/bash&quot;   6 minutes ago   Exited (137) 17 seconds ago             naughty_thompson</span><br><span class="line">root@keep-VirtualBox:/etc/docker#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器</span></span><br><span class="line">root@keep-VirtualBox:/etc/docker# docker rm naughty_thompson</span><br><span class="line">naughty_thompson</span><br><span class="line">root@keep-VirtualBox:/etc/docker# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">root@keep-VirtualBox:/etc/docker#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一直运行 退出自动重启</span></span><br><span class="line">root@keep-VirtualBox:/etc/docker# docker container run --name auto-restart -it --restart always ubuntu sleep 10</span><br></pre></td></tr></table></figure>


<h2 id="容器文件存储"><a href="#容器文件存储" class="headerlink" title="容器文件存储"></a>容器文件存储</h2><p>多个容器要共享数据的话，可以创建一个卷， 然后运行时分别挂载这个卷，这样大家都可以访问数据了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# docker container run -dit --name voltainer --mount source=myvol,target=/vol ubuntu</span><br><span class="line">root@keep-VirtualBox:~# docker exec -it voltainer bash</span><br><span class="line">root@c04fd0703202:/#</span><br><span class="line">root@c04fd0703202:/# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">overlay          98G   53G   41G  57% /</span><br><span class="line">tmpfs            64M     0   64M   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">shm              64M     0   64M   0% /dev/shm</span><br><span class="line">/dev/sda5        98G   53G   41G  57% /vol</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /proc/asound</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /proc/acpi</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /proc/scsi</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/firmware</span><br><span class="line">root@c04fd0703202:/# cd /vol/</span><br><span class="line">root@c04fd0703202:/vol# ls</span><br><span class="line">root@c04fd0703202:/vol#</span><br><span class="line">root@c04fd0703202:/vol# touch test.file</span><br><span class="line">root@c04fd0703202:/vol# vi test.file</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建的卷默认路径在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;下面，我们进去在_data下就可以看到创建的文件test.file了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:/# cd /var/lib/docker/volumes/</span><br><span class="line">root@keep-VirtualBox:/var/lib/docker/volumes#</span><br><span class="line">root@keep-VirtualBox:/var/lib/docker/volumes# ls</span><br><span class="line">backingFsBlockDev  metadata.db  myvol</span><br><span class="line">root@keep-VirtualBox:/var/lib/docker/volumes# cd myvol/_data/</span><br><span class="line">root@keep-VirtualBox:/var/lib/docker/volumes/myvol/_data# ls</span><br><span class="line">test.file</span><br><span class="line">root@keep-VirtualBox:/var/lib/docker/volumes/myvol/_data#</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>容器运行的基础操作就这些， 后面还有更高级的功能待学习。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="下载image超时"><a href="#下载image超时" class="headerlink" title="下载image超时"></a>下载image超时</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:~/docker_repo# docker pull ubuntu:latest</span><br><span class="line"></span><br><span class="line">Error response from daemon: Head &quot;https://registry-1.docker.io/v2/library/ubuntu/manifests/lastest&quot;: net/http: TLS handshake timeout</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker默认的源为国外官方源，下载速度较慢，需修改docker镜像源为国内</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 /etc/docker/daemon.json  不存在则创建文件，并增加内容：</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        &quot;registry-mirrors&quot;:[&quot;https://pee6w651.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a><br>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>get新技能 - cmake基础使用</title>
    <url>/2022/04/17/2022-20220417-cmake/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近准备从零创建一个工程库，于是就准备专门学习这一块的知识,最主要的就是编译系统搭建了。之前很少进行这方面的系统学习，都是基于已有的工程上面修改，一般就是加个文件或者选项，都是比较简单的，主要工作还是在代码逻辑的编写。鉴于是一个新的C语言的工程，那就选择cmake来作工程编译工具了。周末两天花了些时间，在掘金上面看了一个系列的博客，然后再对比的官网的使用文档学习一下cmake。</p>
<span id="more"></span>

<p>成功地跟着博客文章走了一轮下来，掌握了一些基本的使用，嗯，这就来稍微整理一下：</p>
<h1 id="CMake的使用"><a href="#CMake的使用" class="headerlink" title="CMake的使用"></a>CMake的使用</h1><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>CMake最主要的就是CMakeLists.txt及相关的*.cmake的文件编写了。CMakeLists.txt是有层级的概念了， 可以通过include(dir)的方式把相关的CMakeLists.txt文件嵌套包含起来。这个方式跟shell脚本的引用类似。不过不同的CMakeLists.txt的工作目录在其所在的目录及build对应的目录下， 可以输出 CMAKE_CURRENT_SOURCE_DIR, CMAKE_CURRENT_BINARY_DIR变量查看。</p>
<p>第一步就是创建一个新目录，然后创建一个CMakeLists.txt文件。</p>
<p>根目录下的CMakeLists.txt必须填写工程名和cmake版本依赖, 还有可执行文件的创建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cmake_minimum_required (VERSION 3.16)</span><br><span class="line">project (hello </span><br><span class="line">		VERSION 0.0.2</span><br><span class="line">		DESCRIPTION &quot;project hello to learn cmake usage.&quot;</span><br><span class="line">		LANGUAGES C)</span><br><span class="line"></span><br><span class="line">add_executable(hello hello.c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构建程序"><a href="#构建程序" class="headerlink" title="构建程序"></a>构建程序</h2><p>创建一个hello.c的文件，里面简单输出个hello world。然后就是构建一个程序了。 构建的时候cmake自动生成一些文件，一般创建一个build目录，然后再在build目录下构建。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make </span><br><span class="line"></span><br><span class="line">./hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h2><p>构建之后创建的文件都在build目录下了，我们想要把hello文件拷贝到系统bin目录下，便于终端直接执行，需要用到install命令。在CMakeLists.txt下添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">install (TARGETS hello DESTINATION bin) # 默认会安装到 /usr/local/bin中</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新执行命令</span></span><br><span class="line"></span><br><span class="line">cmake ..</span><br><span class="line">make </span><br><span class="line">make install </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后就可以直接执行了</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h2 id="特定函数检测"><a href="#特定函数检测" class="headerlink" title="特定函数检测"></a>特定函数检测</h2><p>很多时候有些平台没有一些库，就不会提供部分函数功能。可以通过这个特性检测函数是否存在，设置到一个变量中，然后生成源程序文件中定义某个宏。我们在代码中根据这个宏来决定调用系统函数还是自定义函数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">include (CheckFunctionExists)</span><br><span class="line">check_function_exists (log HAVE_LOG) # 如果有log函数 则HAVE_LOG有值，否则没有值</span><br><span class="line"></span><br><span class="line">configure_file (</span><br><span class="line">  &quot;$&#123;PROJECT_SOURCE_DIR&#125;/xxx.h.in&quot;</span><br><span class="line">  &quot;$&#123;PROJECT_BINARY_DIR&#125;/xxx.h&quot;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">include_directories(&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在xxx.h.in 文件中添加内容</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmakedefine HAVE_LOG  // 如果HAVE_LOG有值  这个会自动生成  <span class="comment">#define HAVE_LOG  否则 会生成注释/* undef HAVE_LOG */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文件生成"><a href="#文件生成" class="headerlink" title="文件生成"></a>文件生成</h2><p>一种方式是使用configure_file命令， 根据input文件及当前的变量生成output文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMakeLists.txt包含如下内容</span></span><br><span class="line"></span><br><span class="line">configure_file(</span><br><span class="line">	&quot;config.h.in&quot;</span><br><span class="line">	&quot;config.h&quot;</span><br><span class="line">	)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">config.h.in 内容为</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmakedefine USE_MYMATH</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmakedefine HAVE_LOG</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmakedefine HAVE_MALLOC</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmakedefine NOT_EXIST</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define V_MAJOR @VERSION_MAJOR@</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define V_MINOR @VERSION_MINOR@</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define V_PATCH @VERSION_PATCH@</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外一种方式就是使用add_custom_command来通过执行命令生成文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建自定义的版本信息， 可以使用shell脚本来达成目标</span></span><br><span class="line">add_custom_command (</span><br><span class="line">	OUTPUT $&#123;PROJECT_BINARY_DIR&#125;/version.h</span><br><span class="line">	COMMAND $&#123;PROJECT_SOURCE_DIR&#125;/genversion.sh &gt; $&#123;PROJECT_BINARY_DIR&#125;/version.h</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要指明依赖上述的OUTPUT，否则不会执行 COMMAND 的</span></span><br><span class="line">add_executable(hello hello.c $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/version.h)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装包生成"><a href="#安装包生成" class="headerlink" title="安装包生成"></a>安装包生成</h2><p>通过使用cpack生成安装包</p>
<p>在CMakeLists.txt里面添加下面内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">build a CPack driven installer package</span></span><br><span class="line">include (InstallRequiredSystemLibraries)</span><br><span class="line">set (CPACK_RESOURCE_FILE_LICENSE  </span><br><span class="line">     &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;)</span><br><span class="line">set (CPACK_PACKAGE_VERSION_MAJOR &quot;$&#123;Tutorial_VERSION_MAJOR&#125;&quot;)</span><br><span class="line">set (CPACK_PACKAGE_VERSION_MINOR &quot;$&#123;Tutorial_VERSION_MINOR&#125;&quot;)</span><br><span class="line">include (CPack)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行过cmake后， 可以直接运行 make package &#x2F; package_source命令 生成压缩包。还有一个sh脚本用于执行安装。</p>
<p>还学习了一些cmake的语法，创建库等操作。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>通过一溜子的操作，掌握了最基本的使用。后面在实际的应用中再找官方文档看看， 应该足够满足应用了。</p>
<p>又get了一个新技能!</p>
<p>官网： <a href="https://cmake.org/">https://cmake.org/</a></p>
<p>示例代码： <a href="https://gitee.com/fishmwei/blog_code/tree/master/cmake_learn">https://gitee.com/fishmwei/blog_code/tree/master/cmake_learn</a></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a><br>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(20)-信息安全技术</title>
    <url>/2022/04/30/2022-20220430-weekly-security/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常每周都会有一些心得感悟，这些在大家工作中可能会有许多共性。我觉得花一些时间整理一下，跟粉丝读者们分享一下日常学习工作的想法和所得，这是一个很好的互动和文章分享的痛点。</p>
<span id="more"></span>

<p>这是第二十篇。</p>
<h1 id="信息安全技术"><a href="#信息安全技术" class="headerlink" title="信息安全技术"></a>信息安全技术</h1><p>简单来说，信息安全技术就是对数据进行保护的技术，避免数据被窃取或者破坏。对电子数据的攻击方式有2种：被动攻击就是在传输过程中被截取信息、或者通过载体上窃取赋值数据；主动攻击就是对传输或者存储的数据进行恶意删除、篡改。</p>
<h2 id="密码技术"><a href="#密码技术" class="headerlink" title="密码技术"></a>密码技术</h2><p>密码技术是解决问题的一种有效的方法。发送者(信源)通过对数据(明文)使用特定的算法及秘钥进行加密后得到新的数据(密文)传输，接收者(信宿)对接收到的数据再根据算法和秘钥进行解密得到原始数据。对于加密和解密使用相同的秘钥的算法称作对称密码体制，不同的就称作非对称密码体制。</p>
<p>对称的密码体制有DES, 3DES, IDEA, AES、SM4等算法。<br>非对称密码体制有RSA, DSA, ECC, SM2等算法。</p>
<p>对称算法一般是块加密算法，加密解密过程使用同一个秘钥，适合大量数据的操作。算法公开、计算量小、加密速度快、加密效率高。由于实现需要知道密钥，导致秘钥维护大。应用场景主要就是数据加解密。</p>
<p>非对称算法加密解密过程使用不同的秘钥，运算相对慢一点，适合数据量小的数据的操作，安全性比较高。公钥加密+私钥解密的时候，适用于加密传输。私钥加密+公钥解密，适合用于签名验证。</p>
<h2 id="摘要与数字签名"><a href="#摘要与数字签名" class="headerlink" title="摘要与数字签名"></a>摘要与数字签名</h2><p>密码技术主要用于数据的加密，对于数据完整性的校验则使用散列函数和数字签名来解决。</p>
<p>散列算法通过对不同数据进行计算得到一个固定长度的结果数据。原始数据长度没有限定，而且不同的原始数据进行运算得到的结果一般是不一样的。散列算法是不可逆的，无法通过结果得到原始的数据。 一般在传输数据的时候，同时传递原始数据和结果数据。接收者对收到的原始数据部分进行计算得到一个结果，然后跟接收到的结果部分对比，确认数据没有被改变。</p>
<p>数字签名就是发送方使用自身的私钥加密数据，然后接收方使用发送方的公钥解密数据。如果能够得到正确的结果，那么就可以确认这个消息是发送方发送的，因为只有发送方才能使用私钥加密。这个就是不可抵赖性。</p>
<p>但是非对称算法加密慢，总不能把所有数据都是用数字签名的方式吧。一般我们都是对计算出的散列值做数字签名就可以了。大概流程如下：</p>
<p><img src="/images/202204/sign.jpg" alt="avatar"></p>
<ul>
<li>A对消息M使用散列算法得到摘要MD1</li>
<li>A对摘要使用私钥加密得到签名DS</li>
<li>A把消息M和签名DS发送给B</li>
<li>B收到消息M和签名DS， 对消息M使用散列算法得到摘要MD2</li>
<li>B使用A的公钥解密签名DS得到签名的MD3(A的公钥能解开的必须是A私钥加密的)</li>
<li>B对比MD3和MD2，如果一致就确认消息是A发送的了，这里MD1, MD2, MD3都是一样的</li>
</ul>
<p>这里我们假设B确定知道了A的公钥，但是实际应用中，我们需要有一个机制来保证，B获取的公钥就是A的公钥。否则，就有可能受到中间人攻击，被骗了，其实消息来自于第三者C。</p>
<h2 id="公钥交换"><a href="#公钥交换" class="headerlink" title="公钥交换"></a>公钥交换</h2><p>公钥的公布使用的是PKI技术，公钥存在与一个数字证书中，然后这个证书需要有一个可信任的证书机构(CA)来签发。数字证书包含公钥、主体、签发日期、有效日期、序号、签发者等信息。</p>
<p>证书的生成流程：</p>
<ul>
<li>主体通过特殊程序创建公钥和私钥，然后保存好私钥，把公钥和其他信息发送给注册机构</li>
<li>注册机构收到信息，生成证书签名请求</li>
<li>注册机构验证材料、确定主体拥有对应的私钥</li>
<li>完成上述步骤后，注册机构把所有资料上传给证书机构，证书机构对用户生成数字证书。可能是X.509标准格式的证书。发送证书给主体，并且保存证书记录</li>
<li>主体获取证书</li>
</ul>
<p>怎么确认证书是可信任的呢， 那就是证书机构对这个证书使用私钥作了签名，使用者可以使用证书机构的公钥验证，确定这个证书是证书机构颁发的，并且里面的信息是可以信任的。这里又陷入了一个问题，怎么知道证书机构的公钥是可信任的呢。这里有个证书机构的层次，下级的公钥需要上一级的证书机构认证，直到最顶级的证书机构，最顶级的证书用的是一个自签名证书公布他的公钥，就是证书发布者和主体是一样的，默认最顶级的自签名证书是可以信任的。这样一级级认证，最后确认证书机构的公钥是可以信任的，用来验证他签发的证书也是可以信任的。</p>
<p>对于不同PKI域的证书，顶级CA交叉认证。</p>
<h2 id="证书的应用"><a href="#证书的应用" class="headerlink" title="证书的应用"></a>证书的应用</h2><p>之前做iOS APP开发的时候，如果要发布app还需要申请对应的证书。证书就是用来对app包进行加密， 然后苹果通过对app包校验，来保证安装的应用的确是你发布的，没有被篡改过。 同时，苹果还在中间添加了一些小伎俩， 通过证书里面的配置文件，控制不同类型证书的用途及适用的设备，从而通过此来收取开发者费用。比如，个人证书只能添加一台设备默认安装(不需要经过appstore下载)，企业证书却可以添加几百台默认安装。</p>
<p>下面是苹果证书申请的流程：</p>
<p>0、交钱申请一个开发者账户，开通权限。 这里个人用户比较简单，企业用户还需要提供一个邓白氏码，表示你是真正存在的一个企业。</p>
<p>1、开发者本地生成certSigningRequest文件，在这个过程中，苹果会生成一对公钥与私钥， 在certSigningRequest中会包含公钥，私钥保存在本地机器中， 可以通过keychain看到</p>
<p>2、开发者到苹果开发者网站申请证书, .cer证书(分为开发和分发等类型) </p>
<p>3、安装这个证书后，然后安装对应的私钥后 本地相当于登录了这个账号，可以进行对应的操作</p>
<p>4、创建AppId， 主要是用于后面创建对应的mobileProfile<br>配置Provisioning Profiles文件， 选择对应的AppId， 还有类型。 如果是开发证书，还可以选择设备列表<br>开发者下载Provisioning Profiles文件， 打包的时候就可以选择对应的证书了。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>今天是五一长假第一天，疫情原因也没有出去浪，宅在家里好好学习一下。个人计划清单越来越长了，得花时间好好地消灭一下了，难得这么完整安静的假期，且行且珍惜！</p>
<p>信息安全相关的算法了解有待深入，前段时间买了一本书《密码学与网络安全》，加油搞定之。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a><br>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>openssl基础命令的使用</title>
    <url>/2022/05/03/2022-20220503-openssl/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>来了解一下openssl这个工具的基础命令的使用。</p>
<p>主要部分是根据<code>https://wiki.openssl.org/index.php/Command_Line_Utilities</code>这个文档来描述的。</p>
<span id="more"></span>

<h1 id="openssl命令"><a href="#openssl命令" class="headerlink" title="openssl命令"></a>openssl命令</h1><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">openssl command [ command_options ] [ command_arguments ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="素数生成"><a href="#素数生成" class="headerlink" title="素数生成"></a>素数生成</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 生成24位的一个素数</span><br><span class="line">openssl prime -generate -bits 24</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">openssl help</span><br><span class="line"></span><br><span class="line">openssl command -help</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">openssl genpkey -help</span><br><span class="line">Usage: genpkey [options]</span><br><span class="line">Valid options are:</span><br><span class="line"> -help              Display this summary</span><br><span class="line"> -out outfile       Output file</span><br><span class="line"> -outform PEM|DER   output format (DER or PEM)</span><br><span class="line"> -pass val          Output file pass phrase source</span><br><span class="line"> -paramfile infile  Parameters file</span><br><span class="line"> -algorithm val     The public key algorithm</span><br><span class="line"> -pkeyopt val       Set the public key algorithm option as opt:value</span><br><span class="line"> -genparam          Generate parameters, not key</span><br><span class="line"> -text              Print the in text</span><br><span class="line"> -*                 Cipher to use to encrypt the key</span><br><span class="line"> -engine val        Use engine, possibly a hardware device</span><br><span class="line">Order of options may be important!  See the documentation.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@keep-VirtualBox:/usr/local/lib# openssl version</span><br><span class="line">GmSSL 2.5.4 - OpenSSL 1.1.0d  19 Jun 2019   # 这里显示GmSSL是因为机子上面安装了GmSSL， 默认会替换openssl程序。 GmSSL是openssl的超集，额外实现了国密算法</span><br><span class="line">root@keep-VirtualBox:/usr/local/lib#</span><br><span class="line">root@keep-VirtualBox:/usr/local/lib# openssl version -help</span><br><span class="line">Usage: version [options]</span><br><span class="line">Valid options are:</span><br><span class="line"> -help  Display this summary</span><br><span class="line"> -a     Show all data</span><br><span class="line"> -b     Show build date</span><br><span class="line"> -d     Show configuration directory</span><br><span class="line"> -e     Show engines directory</span><br><span class="line"> -f     Show compiler flags used</span><br><span class="line"> -o     Show some internal datatype options</span><br><span class="line"> -p     Show target build platform</span><br><span class="line"> -v     Show library version</span><br><span class="line">root@keep-VirtualBox:/usr/local/lib#</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="生成RSA-私钥"><a href="#生成RSA-私钥" class="headerlink" title="生成RSA 私钥"></a>生成RSA 私钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成私钥并且使用aes256加密</span></span><br><span class="line"></span><br><span class="line">openssl genpkey -aes256 -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out private-key.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出可用于加密的算法</span></span><br><span class="line">openssl list -cipher-algorithms </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取私钥并且以文本形式显示</span></span><br><span class="line">openssl pkey -in private-key.pem -text</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定对称密钥 -pass pass:123456， 就可以不会手动输入了</span></span><br><span class="line"></span><br><span class="line">openssl genpkey -aes256 -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out private-key.pem -pass pass:123456</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据私钥生成公钥</span></span><br><span class="line"></span><br><span class="line">openssl pkey -in private-key.pem -out public-key.pem -pubout</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取公钥并且以文本形式显示</span></span><br><span class="line"></span><br><span class="line">openssl pkey -in public-key.pem -pubin -text</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="基于椭圆曲线生成key"><a href="#基于椭圆曲线生成key" class="headerlink" title="基于椭圆曲线生成key"></a>基于椭圆曲线生成key</h2><p>分为两步：<br>1、生成参数<br>2、使用参数生成key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取支持的椭圆曲线列表</span></span><br><span class="line">openssl ecparam -list_curves</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成椭圆曲线参数输出到文件中</span></span><br><span class="line">openssl ecparam -name prime256v1 -out prime256v1.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取参数文件并以文本显示</span></span><br><span class="line">openssl ecparam -in prime256v1.pem -noout -text</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取参数文件并以C语言格式显示</span></span><br><span class="line">openssl ecparam -in prime256v1.pem -noout -C</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据参数文件生成私钥文件</span></span><br><span class="line">openssl genpkey -aes256 -paramfile prime256v1.pem -out private-key.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用genpkey基于EC直接生成私钥， 效果同上</span></span><br><span class="line">openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-256</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用genpkey直接生成私钥 并使用aes256加密</span></span><br><span class="line">openssl genpkey -aes256 -algorithm EC -pkeyopt ec_paramgen_curve:P-256 -out private-key.pem</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Base64编码字符串"><a href="#Base64编码字符串" class="headerlink" title="Base64编码字符串"></a>Base64编码字符串</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编码</span></span><br><span class="line">openssl base64 -e &lt;&lt;&lt; &#x27;Welcome to openssl wiki&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解码</span></span><br><span class="line">openssl base64 -d &lt;&lt;&lt; &#x27;V2VsY29tZSB0byBvcGVuc3NsIHdpa2kK&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="生成文件摘要"><a href="#生成文件摘要" class="headerlink" title="生成文件摘要"></a>生成文件摘要</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl dgst -md5 primes.dat</span></span><br><span class="line">MD5(primes.dat)= 7710839bb87d2c4c15a86c2b2c805664</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl dgst -sha1 primes.dat</span></span><br><span class="line">SHA1(primes.dat)= 5dfab70ce825591689f4a3f65910870a9022cd32</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl dgst -sha384 primes.dat</span></span><br><span class="line">SHA384(primes.dat)= 41399bdffe6850f5a44852d967f3db415654f20dc2eb6cd231772f6ea411876d85d44091ebbc6b1f4ce8673e64617271</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列举支持的摘要算法</span></span><br><span class="line">openssl list -digest-algorithms</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列举支持的摘要命令</span></span><br><span class="line">openssl list -digest-commands</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl md5 primes.dat</span></span><br><span class="line">MD5(primes.dat)= 7710839bb87d2c4c15a86c2b2c805664</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl sha1 primes.dat</span></span><br><span class="line">SHA1(primes.dat)= 5dfab70ce825591689f4a3f65910870a9022cd32</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl sha384 primes.dat</span></span><br><span class="line">SHA384(primes.dat)= 41399bdffe6850f5a44852d967f3db415654f20dc2eb6cd231772f6ea411876d85d44091ebbc6b1f4ce8673e64617271</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文件加解密"><a href="#文件加解密" class="headerlink" title="文件加解密"></a>文件加解密</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取支持加解密的算法  命令1</span></span><br><span class="line">openssl enc -ciphers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取支持加解密的算法  命令2</span></span><br><span class="line">openssl list -cipher-algorithms</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>选项 -e, -d 分别表示加密和解密<br>选项 -iter 表示密钥派生的轮数，越大算法强度就越强 -pbkdf2 一起用。-salt随机生成因子作用于派生函数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用aes-256-cbc 加密文件，密码 123456</span></span><br><span class="line"></span><br><span class="line">openssl enc -aes-256-cbc -e -iter 1000 -salt -in primes.dat -out primes.enc -k 123456</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解密</span></span><br><span class="line">openssl enc -aes-256-cbc -d -iter 1000 -in primes.enc -out primes.dec</span><br><span class="line"></span><br><span class="line">openssl enc -aes128 -pass pass:123456 -iter 10 -d  -in aes128.enc -out aes128.dec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Des3算法：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">加密：</span></span><br><span class="line">openssl enc -e -des3 -a -salt -in fstab -out fstab.des3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解密：</span></span><br><span class="line">openssl enc -d -des3 -a -salt -in fstab.des3 -out fstab</span><br></pre></td></tr></table></figure>

<h2 id="摘要、签名与验证"><a href="#摘要、签名与验证" class="headerlink" title="摘要、签名与验证"></a>摘要、签名与验证</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">openssl dgst -md5 -hex file.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用rsa生成的私钥加密后 再计算签名</span></span><br><span class="line">openssl dgst -sha256 -sign privatekey.pem -out signature.sign file.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">验证签名</span></span><br><span class="line">openssl dgst -sha256 -verify publickey.pem  -signature signature.sign  file.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p>使用openssl help 可以看到分组列出的命令。</p>
<p>也可以使用man openssl 查看帮助。</p>
<h1 id="GmSSL的编译"><a href="#GmSSL的编译" class="headerlink" title="GmSSL的编译"></a>GmSSL的编译</h1><p>需要一些国密算法的学习，必须要用到GmSSL库了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/guanzhi/openssl.git</span><br><span class="line"></span><br><span class="line">cd openssl</span><br><span class="line">./config no-shared no-asm # 使用静态编译，避免openssl与系统原有的openssl相覆盖</span><br><span class="line">make -j 12</span><br><span class="line">make install </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">no-asm 解决 EC_GFp_sm2z256_method undefined的问题</span></span><br></pre></td></tr></table></figure>


<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>今年新工作刚开始学习信息安全技术，一堆的术语算法，刚上来就整懵了我。每天花了一些时间，循序渐进地学习，慢慢的上道了，活到老学到老，不然要被淘汰掉了。一万小时定律不是吹的，功夫花在哪里，成就就在哪里。</p>
<p>这个文章简要整理了一些openssl常用的基础命令，后面便于翻查。</p>
<p>五一的时候新入手了一个27寸的dell显示屏，屏幕大看起来就是爽哈！工欲善其事必先利其器， done!</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a><br>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>openssl</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(21)-浅谈RSA算法</title>
    <url>/2022/05/16/2022-20220516-weekly-rsa/</url>
    <content><![CDATA[<h1 id="RSA算法概述"><a href="#RSA算法概述" class="headerlink" title="RSA算法概述"></a>RSA算法概述</h1><p>RSA算法是常用的非对称算法，应用广泛。比如常见的ssh连接，使用过gitlab的开发者都接触过，通过rsa算法可以生成一对证书，通过把公钥设置到gitlab上面，本地才可以通过ssh的方式下载代码。</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# ssh-keygen -t rsa -b 2048 -C &quot;auth@xxx.com&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): /root/.ssh/id_rsa_auth</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa_auth</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa_auth.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:jSLQwYvLcHx+ya2VkeOVy+jbuFqj4CcIuRVwvBqkRtQ auth@xxx.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|.o...            |</span><br><span class="line">|.ooE..           |</span><br><span class="line">|++.o..   . .     |</span><br><span class="line">|+.*.o   +oo      |</span><br><span class="line">|.B =...+SB..     |</span><br><span class="line">|+ + ..+.* o      |</span><br><span class="line">| + ... +o        |</span><br><span class="line">|. ....oo.+       |</span><br><span class="line">|    .oo.+o.      |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# ls -la ~/.ssh/</span><br><span class="line">总用量 48</span><br><span class="line">drwx------  2 root root 4096 5月  16 17:48 .</span><br><span class="line">drwx------ 18 root root 4096 5月  16 11:07 ..</span><br><span class="line">-rw-------  1 root root 1876 5月  16 17:48 id_rsa_auth</span><br><span class="line">-rw-r--r--  1 root root  394 5月  16 17:48 id_rsa_auth.pub</span><br><span class="line">-rw-r--r--  1 root root 1332 3月  25 15:01 known_hosts</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后把id_rsa_auth.pub的内容设置到gitlab就ok了。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密秘钥。</p>
<p>密钥生成过程： </p>
<ul>
<li>生成两个大的质数 p, q。 如：p&#x3D;7, q&#x3D;19</li>
<li>得到n&#x3D;p<em>q, m &#x3D; (p-1)</em>(q-1)。如n&#x3D;133, m&#x3D;108</li>
<li>选取e使得e和m互质。如e&#x3D;5</li>
<li>生成d， 使得d*e mod m &#x3D; 1。如d&#x3D;65</li>
<li>最后丢弃p,q,m。公钥就是e, n; 私钥就是d, n。 公钥(5, 133)， 私钥(65, 133)</li>
</ul>
<p>加密过程：</p>
<p>输入明文x通过计算得到y</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">y = x^e mod n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x = 6, 则 y = 6^5 mod 133 = 62</span></span><br></pre></td></tr></table></figure>

<p>解密过程：<br>输入密文通过计算得到x</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x = y^d mod n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x = 62^65 mod 133 = 6</span></span><br></pre></td></tr></table></figure>

<p>RSA算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。</p>
<p>RSA涉及到了一些数学的概念。 </p>
<ul>
<li>质数 一个大于1的自然数，除了1和它本身外，不能被其他自然数整除（除0以外）的数称之为质数（素数）；否则称为合数。</li>
<li>互质 若N个整数的最大公因子是1，则称这N个整数互质。</li>
<li>指数运算 指数运算又称乘方计算，计算结果称为幂。</li>
<li>模运算 让m去被n整除，只取所得的余数作为结果，就叫做模运算。</li>
</ul>
<p>这些也就是RSA的基础。还有更深层次的欧拉定理就不讲了，感觉有些费脑了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>前面使用ssh-keygen生成rsa的公钥密钥的时候，需要输入一个密码。其实这个密码本身跟RSA是没有关系的，只是为了密钥的安全，使用了对称算法对密钥进行了加密。只有知道这个密码的人才能使用这对密钥。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a><br>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(23)-撸了一个轻量级的C语言命令行库</title>
    <url>/2022/06/04/2022-20220604-weekly-ccmd/</url>
    <content><![CDATA[<p>今天把前段时间在项目中写的一个命令框架整理一下，剥离出来独立成一个动态库。</p>
<span id="more"></span>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>基于getopt实现了一个简易的命令行库，目前只支持长选项的功能。编译使用的cmake工具。</p>
<p>主要的功能：<br>1、支持自定义选项、自定义解析函数<br>2、支持显示内部流程日志<br>3、封装成动态库 编译调用</p>
<p>没有很深奥难懂的知识点。主要还是为了方便使用吧。下面讲一下实现。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="选项配置"><a href="#选项配置" class="headerlink" title="选项配置"></a>选项配置</h2><p>每一个选项的配置对应一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 命令选项信息及回调函数 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *help;</span><br><span class="line">    cmd_opt_help_printer help_fn;</span><br><span class="line">    cmd_opt_parser parser_fn;</span><br><span class="line">&#125; cmd_opt_cfg;</span><br></pre></td></tr></table></figure>

<p>对应帮助信息、选项名称还有就是解析函数。当help为NULL时，帮助信息可以让开发者自己输出，主要是考虑有些帮助信息是动态生成的，跟环境相关，不是固定的。</p>
<p>所有的命令选项配置，最终会被存放到内部的全局变量中,对应结构如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *prog_name;</span><br><span class="line">    <span class="comment">/* 所有选项的配置信息 */</span></span><br><span class="line">    cmd_opt_cfg *opt_cfgs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用于getopt_long的选项配置，最后一个需要是NULL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> *<span class="title">long_opts</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> opt_cnt; <span class="comment">/* 选项个数 */</span></span><br><span class="line">    <span class="type">uint32_t</span> max_opt_num;</span><br><span class="line">&#125; cmd_opt_configs;</span><br></pre></td></tr></table></figure>

<h2 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h2><p>封装了一个函数usage，输出帮助信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Usage\n&quot;</span></span><br><span class="line">         <span class="string">&quot; %s [options] ...\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Options:\r\n&quot;</span>,</span><br><span class="line">        g_cmd_opt_configs-&gt;prog_name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; g_cmd_opt_configs-&gt;opt_cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( g_cmd_opt_configs-&gt;opt_cfgs[i].help) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, g_cmd_opt_configs-&gt;opt_cfgs[i].help);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( g_cmd_opt_configs-&gt;opt_cfgs[i].help_fn)</span><br><span class="line">        &#123;</span><br><span class="line">            g_cmd_opt_configs-&gt;opt_cfgs[i].help_fn( g_cmd_opt_configs-&gt;opt_cfgs[i].name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><p>命令解析是最核心的内容，调用getopt_long来解析参数，如果返回为0表示匹配了选项，然后根据返回的opt_idx索引到具体的选项，最后调用对应的选项解析函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmd_parse</span><span class="params">(<span class="type">void</span> *results, <span class="type">const</span> <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> opt, retval, opt_idx;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    g_cmd_opt_configs-&gt;prog_name = argv[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt_long(argc, (<span class="type">char</span> * <span class="type">const</span>*)argv, <span class="string">&quot;&quot;</span>, g_cmd_opt_configs-&gt;long_opts, &amp;opt_idx)) != EOF) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                retval = cmd_parse_opt_with_idx(opt_idx, results);</span><br><span class="line">                <span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    usage();</span><br><span class="line">                    <span class="keyword">return</span> retval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// hit unknown option</span></span><br><span class="line">                <span class="keyword">if</span> (!__command_unknown_option_bypass())</span><br><span class="line">                &#123;</span><br><span class="line">                    usage();</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码已经上传到gitee中，感兴趣可以去看看，欢迎交流，提提意见。</p>
<p><code>https://gitee.com/fishmwei/ccmd</code></p>
<p>在源码中带有一个example， 运行效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:/media/sf_VM_SHARE/ccmd/example/build# ./ccmd_test --help</span><br><span class="line">Usage</span><br><span class="line"> ./ccmd_test [options] ...</span><br><span class="line">Options:</span><br><span class="line"> --help: prints this help</span><br><span class="line"> --name: specify student name</span><br><span class="line"> --address: specify student home address</span><br><span class="line"> --age: specify student age</span><br><span class="line"> --fresh: is fresh graduate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:/media/sf_VM_SHARE/ccmd/example/build# ./ccmd_test --name xiaoming --address Fuzhou,Fujian --age 18 --fresh</span><br><span class="line">get student info:</span><br><span class="line"> name   : xiaoming</span><br><span class="line"> address: Fuzhou,Fujian</span><br><span class="line"> age    : 18</span><br><span class="line"> fresh  : true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>端午节废了一天，今天赶紧振作起来，搞点事情。</p>
<p>这段时间，工作上也算是有点儿忙吧，家里也出了些烦心事，又落下了一周文章。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(22)-openssl speed性能测试详解</title>
    <url>/2022/05/21/2022-20220521-weekly-openssl-speed/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>openssl的性能测试主要就是测试在固定时间内、不同长度数据进行算法操作的次数。最后统计每1000秒钟处理的数据量或是每秒钟进行运算的次数，可以通过执行md5&#x2F;rsa512&#x2F;aes-128-cbc算法的性能测试看一下输出的结果：</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# /usr/bin/openssl speed md5</span><br><span class="line">Doing md5 for 3s on 16 size blocks: 23848303 md5&#x27;s in 2.56s</span><br><span class="line">Doing md5 for 3s on 64 size blocks: 13073221 md5&#x27;s in 2.50s</span><br><span class="line">Doing md5 for 3s on 256 size blocks: 5745354 md5&#x27;s in 3.00s</span><br><span class="line">Doing md5 for 3s on 1024 size blocks: 1927877 md5&#x27;s in 3.01s</span><br><span class="line">Doing md5 for 3s on 8192 size blocks: 259000 md5&#x27;s in 3.01s</span><br><span class="line">Doing md5 for 3s on 16384 size blocks: 171425 md5&#x27;s in 3.98s</span><br><span class="line">OpenSSL 1.1.1f  31 Mar 2020</span><br><span class="line">built on: Tue May  3 17:49:36 2022 UTC</span><br><span class="line">options:bn(64,64) rc4(8x,int) des(int) aes(partial) blowfish(ptr)</span><br><span class="line">compiler: gcc -fPIC -pthread -m64 -Wa,--noexecstack -Wall -Wa,--noexecstack -g -O2 -fdebug-prefix-map=/build/openssl-7zx7z2/openssl-1.1.1f=. -fstack-protector-strong -Wformat -Werror=format-security -DOPENSSL_TLS_SECURITY_LEVEL=2 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DAESNI_ASM -DVPAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPOLY1305_ASM -DNDEBUG -Wdate-time -D_FORTIFY_SOURCE=2</span><br><span class="line">The &#x27;numbers&#x27; are in 1000s of bytes per second processed.</span><br><span class="line">type             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes  16384 bytes</span><br><span class="line">md5             149051.89k   334674.46k   490270.21k   655862.47k   704893.02k   705685.23k</span><br><span class="line">root@keep-VirtualBox:~#</span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# /usr/bin/openssl speed aes-128-cbc</span><br><span class="line">Doing aes-128 cbc for 3s on 16 size blocks: 32626951 aes-128 cbc&#x27;s in 3.00s</span><br><span class="line">Doing aes-128 cbc for 3s on 64 size blocks: 8663154 aes-128 cbc&#x27;s in 3.00s</span><br><span class="line">Doing aes-128 cbc for 3s on 256 size blocks: 2921912 aes-128 cbc&#x27;s in 3.01s</span><br><span class="line">Doing aes-128 cbc for 3s on 1024 size blocks: 727405 aes-128 cbc&#x27;s in 3.00s</span><br><span class="line">Doing aes-128 cbc for 3s on 8192 size blocks: 91505 aes-128 cbc&#x27;s in 3.00s</span><br><span class="line">Doing aes-128 cbc for 3s on 16384 size blocks: 46708 aes-128 cbc&#x27;s in 3.00s</span><br><span class="line">OpenSSL 1.1.1f  31 Mar 2020</span><br><span class="line">built on: Tue May  3 17:49:36 2022 UTC</span><br><span class="line">options:bn(64,64) rc4(8x,int) des(int) aes(partial) blowfish(ptr)</span><br><span class="line">compiler: gcc -fPIC -pthread -m64 -Wa,--noexecstack -Wall -Wa,--noexecstack -g -O2 -fdebug-prefix-map=/build/openssl-7zx7z2/openssl-1.1.1f=. -fstack-protector-strong -Wformat -Werror=format-security -DOPENSSL_TLS_SECURITY_LEVEL=2 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DAESNI_ASM -DVPAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPOLY1305_ASM -DNDEBUG -Wdate-time -D_FORTIFY_SOURCE=2</span><br><span class="line">The &#x27;numbers&#x27; are in 1000s of bytes per second processed.</span><br><span class="line">type             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes  16384 bytes</span><br><span class="line">aes-128 cbc     174010.41k   184813.95k   248508.13k   248287.57k   249869.65k   255087.96k</span><br><span class="line">root@keep-VirtualBox:~#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:~# /usr/bin/openssl speed rsa512</span><br><span class="line">Doing 512 bits private rsa&#x27;s for 10s: 196101 512 bits private RSA&#x27;s in 9.99s</span><br><span class="line">Doing 512 bits public rsa&#x27;s for 10s: 3471653 512 bits public RSA&#x27;s in 10.00s</span><br><span class="line">OpenSSL 1.1.1f  31 Mar 2020</span><br><span class="line">built on: Tue May  3 17:49:36 2022 UTC</span><br><span class="line">options:bn(64,64) rc4(8x,int) des(int) aes(partial) blowfish(ptr)</span><br><span class="line">compiler: gcc -fPIC -pthread -m64 -Wa,--noexecstack -Wall -Wa,--noexecstack -g -O2 -fdebug-prefix-map=/build/openssl-7zx7z2/openssl-1.1.1f=. -fstack-protector-strong -Wformat -Werror=format-security -DOPENSSL_TLS_SECURITY_LEVEL=2 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DAESNI_ASM -DVPAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPOLY1305_ASM -DNDEBUG -Wdate-time -D_FORTIFY_SOURCE=2</span><br><span class="line">                  sign    verify    sign/s verify/s</span><br><span class="line">rsa  512 bits 0.000051s 0.000003s  19629.7 347165.3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到对于对称算法和摘要算法，主要关心的是每秒钟处理数据的量，对于非对称算法，主要关心的是每秒钟执行操作的次数。</p>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>性能测试的入口函数是speed_main。</p>
<p>首先，初始化了所有算法用到的不同长度的key，原始的明文数据，还有一些相关的参数（如类型， 模式等）。</p>
<p>然后，就是解析命令行参数，设定不同的参数。比如：运行测试的时长， 并发运行数、是加密还是解密等， 最后解析要测试的算法类型。</p>
<p>如果是设置了并发运行数，那么就会fork多个子进程，父进程与子进程间使用管道获取数据。子进程执行完之后会把结果通过管道传递给父进程， 父进程读取所有结果再平均计算最终结果。这里每个子进程都执行一样的测试逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_FORK</span></span><br><span class="line">    <span class="keyword">if</span> (multi &amp;&amp; do_multi(multi, size_num))</span><br><span class="line">        <span class="keyword">goto</span> show_res;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_multi</span><span class="params">(<span class="type">int</span> multi, <span class="type">int</span> size_num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> *fds;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> sep[] = <span class="string">&quot;:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fds = app_malloc(<span class="keyword">sizeof</span>(*fds) * multi, <span class="string">&quot;fd buffer for do_multi&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; multi; ++n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">            BIO_printf(bio_err, <span class="string">&quot;pipe failure\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        (<span class="type">void</span>)BIO_flush(bio_err);</span><br><span class="line">        <span class="keyword">if</span> (fork()) &#123;</span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">            fds[n] = fd[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            close(<span class="number">1</span>); <span class="meta"># then lowest-numbered unused file des is 1</span></span><br><span class="line">            <span class="keyword">if</span> (dup(fd[<span class="number">1</span>]) == <span class="number">-1</span>) &#123; <span class="meta"># use 1 for new des</span></span><br><span class="line">                BIO_printf(bio_err, <span class="string">&quot;dup failed\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">            mr = <span class="number">1</span>;</span><br><span class="line">            usertime = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">free</span>(fds);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Forked child %d\n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 父进程 读取管道内容。</span></span><br><span class="line">    <span class="comment">/* for now, assume the pipe is long enough to take all the output */</span></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; multi; ++n) &#123;</span><br><span class="line">        FILE *f;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">        f = fdopen(fds[n], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), f)) &#123;</span><br><span class="line">            ... </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>接着后面就是循环执行算法了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if (doit[D_MD5]) &#123;</span><br><span class="line">       for (testnum = 0; testnum &lt; size_num; testnum++) &#123;</span><br><span class="line">           print_message(names[D_MD5], c[D_MD5][testnum], lengths[testnum],</span><br><span class="line">                         seconds.sym);</span><br><span class="line">           Time_F(START);</span><br><span class="line">           count = run_benchmark(async_jobs, MD5_loop, loopargs);</span><br><span class="line">           d = Time_F(STOP);</span><br><span class="line">           print_result(D_MD5, testnum, count, d);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>doit数组保存的是该算法是否是要测试的，size_num表示多少种块大小的数据。在print_message中，会开启一个设置一个固定时长的信号，在一定时长之后会出发一个alarm信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_message</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">long</span> num, <span class="type">int</span> length, <span class="type">int</span> tm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SIGALRM</span></span><br><span class="line">    BIO_printf(bio_err,</span><br><span class="line">               mr ? <span class="string">&quot;+DT:%s:%d:%d\n&quot;</span></span><br><span class="line">               : <span class="string">&quot;Doing %s for %ds on %d size blocks: &quot;</span>, s, tm, length);</span><br><span class="line">    (<span class="type">void</span>)BIO_flush(bio_err);</span><br><span class="line">    alarm(tm);			<span class="comment">// tm秒后 发送alarm信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    BIO_printf(bio_err,</span><br><span class="line">               mr ? <span class="string">&quot;+DN:%s:%ld:%d\n&quot;</span></span><br><span class="line">               : <span class="string">&quot;Doing %s %ld times on %d size blocks: &quot;</span>, s, num, length);</span><br><span class="line">    (<span class="type">void</span>)BIO_flush(bio_err);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在之前注册了信号处理函数，设置了一个全局变量run为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">signal(SIGALRM, alarmed);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alarmed</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGALRM, alarmed);</span><br><span class="line">    run = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再之后调用Time_F(START); 记录当前时间， 紧接着就开始了run_benchmark，传入md5算法操作函数MD5_loop。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">run_benchmark</span><span class="params">(<span class="type">int</span> async_jobs,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> (*loop_function) (<span class="type">void</span> *), <span class="type">loopargs_t</span> * loopargs)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	run = <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在run_benchmark里面设置run&#x3D;1， 然后开始调用md5的算法操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">MD5_loop</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">loopargs_t</span> *tempargs = *(<span class="type">loopargs_t</span> **) args;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buf = tempargs-&gt;buf;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> md5[MD5_DIGEST_LENGTH];</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; COND(c[D_MD5][testnum]); count++)</span><br><span class="line">        MD5(buf, lengths[testnum], md5);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> COND(unused_cond) (run &amp;&amp; count&lt;0x7fffffff)</span></span><br></pre></td></tr></table></figure>

<p>MD5_loop里面就是一个循环一直执行同样的动作。直到run&#x3D;0 或者count达到0x7fffffff</p>
<p>然后调用Time_F(STOP)，获取执行的时长。</p>
<p>最后再汇总输出结果，这里要注意的是，如果设置了multi，那么结果是多个进程处理数据的总和，而不是平均值。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>openssl这个性能测试的输入数据都是固定的，然后通过在一定时长内运行算法操作，统计出运行的次数，综合对应的数据长度，计算出每秒钟运行的次数或者处理的数据量。这个测试适合不同机器间横向的对比，没有做单机纵向的对比，缺少随机数据的比较。</p>
<p>了解这个openssl的性能测试逻辑，主要就是为了借鉴到项目中来做性能测试。当然，后面性能也要跟openssl进行对比。所以在数据层面上，也是需要跟openssl一样的。所有的执行逻辑和最终结果的展示，最好跟openssl相差不大，可以方便的进行对比。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>openssl</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(24)-Linux内置的异步AIO使用</title>
    <url>/2022/06/09/2022-20220609-weekly-libaio/</url>
    <content><![CDATA[<p>今天在看libkcapi源码的时候，看到了一个struct iocb的结构。注释说这个是什么AIO相关的数据结构。上网查了一下，这是Linux内置的异步I&#x2F;O机制的一个概念。</p>
<span id="more"></span>

<p>三月份的时候，写了一篇关于Linux IO的select、poll、epoll接口的使用。异步IO也比较容易理解了，就是为了使程序不阻塞而实现的一种机制。</p>
<p>AIO的实现也就是提交一个IO请求，然后流程继续处理，过一段时间来查询一下提交IO的状态，确定IO操作是否完成。</p>
<h1 id="实现及接口"><a href="#实现及接口" class="headerlink" title="实现及接口"></a>实现及接口</h1><p>AIO相关的系统调用实现在内核fs&#x2F;aio.c文件中，头文件是&lt;linux&#x2F;aio_abi.h&gt;。AIO提供了5个API：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/aio_abi.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">io_setup</span><span class="params">(<span class="type">unsigned</span> nr_events, <span class="type">aio_context_t</span> *ctxp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">io_destroy</span><span class="params">(<span class="type">aio_context_t</span> ctx)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">io_submit</span><span class="params">(<span class="type">aio_context_t</span> ctx, <span class="type">long</span> nr, <span class="keyword">struct</span> iocb **iocbpp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">io_cancel</span><span class="params">(<span class="type">aio_context_t</span> ctx, <span class="keyword">struct</span> iocb *, <span class="keyword">struct</span> io_event *result)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">io_getevents</span><span class="params">(<span class="type">aio_context_t</span> ctx, <span class="type">long</span> min_nr, <span class="type">long</span> nr,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> io_event *events, <span class="keyword">struct</span> timespec *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>每个IO请求(对应结构体struct iocb)都被提交到一个AIO的上下文(对应aio_context_t ，其实是一个数字)中，上下文通过 io_setup创建， io_destroy销毁。</p>
<p>io_submit函数一次可以提交多个IO请求到指定的上下文中。</p>
<p>在提交IO请求之后，可以去处理其它的事情。过段时间，通过io_getevents来获取一下IO请求状态。需要指定前面的上下文， 然后就是一个iocb的缓存区，等待完成IO的最少、最大数目。如果没有达到最少的IO数，则会阻塞直到满足条件。当然，也可以设置超时时间。</p>
<p>具体的结构定义这边就不详解了。</p>
<p>要使用Linux AIO的机制有几种方法：</p>
<ul>
<li>使用内核的系统调用</li>
<li>使用用户空间上的libaio库</li>
<li>自己在用户态模拟假的AIO，不需要内核支持。 目前有一个实现 librt</li>
</ul>
<p>也就是说，我们在用户态不能直接使用上面的那些接口，而是使用libaio这个库提供的接口来实现，或者使用系统调用。</p>
<p>下面是一个简单的例子，自己封装个同名的接口，内部使用系统调用，通过AIO机制往文件写入一段字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/aio_abi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">io_setup</span><span class="params">(<span class="type">unsigned</span> nr, <span class="type">aio_context_t</span> *ctxp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_io_setup, nr, ctxp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">io_destroy</span><span class="params">(<span class="type">aio_context_t</span> ctx)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_io_destroy, ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">io_submit</span><span class="params">(<span class="type">aio_context_t</span> ctx, <span class="type">long</span> nr, <span class="keyword">struct</span> iocb **iocbpp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_io_submit, ctx, nr, iocbpp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">io_getevents</span><span class="params">(<span class="type">aio_context_t</span> ctx, <span class="type">long</span> min_nr, <span class="type">long</span> max_nr,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> io_event *events, <span class="keyword">struct</span> timespec *timeout)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_io_getevents, ctx, min_nr, max_nr, events, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_IO_NUM (10)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">const</span> <span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;param less 3\r\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *data = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *file_name = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get data %s file_name %s\r\n&quot;</span>, data, file_name);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">aio_context_t</span> ctx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> <span class="title">io</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> *<span class="title">pio</span>[1] =</span> &#123;&amp;io&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> <span class="title">e</span>[1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(ctx));</span><br><span class="line">    <span class="keyword">if</span> (io_setup(MAX_IO_NUM, &amp;ctx))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;io setup error\r\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(file_name, O_CREAT|O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        io_destroy(ctx);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;io, <span class="number">0</span>, <span class="keyword">sizeof</span>(io));</span><br><span class="line">	io.aio_fildes = fd;</span><br><span class="line">	io.aio_lio_opcode = IOCB_CMD_PWRITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	io.aio_reqprio = 0;</span></span><br><span class="line">	io.aio_buf = (<span class="type">uint64_t</span>)data;</span><br><span class="line">	io.aio_nbytes = <span class="built_in">strlen</span>(data);</span><br><span class="line">	io.aio_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// io.aio_data = data;</span></span><br><span class="line">    <span class="keyword">if</span> (io_submit(ctx, <span class="number">1</span>, pio) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        io_destroy(ctx);</span><br><span class="line">        perror(<span class="string">&quot;io submit error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeout.tv_sec = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start get events %d times\r\n&quot;</span>, count++);</span><br><span class="line">        <span class="keyword">if</span> (io_getevents(ctx, <span class="number">1</span>, <span class="number">1</span>, e, &amp;timeout) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get it\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_destroy(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>效果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:/media/sf_VM_SHARE/code/blog_code/linux-kernel# ./aio 222222222222222222222222222 /tmp/2.txt</span><br><span class="line">get data 222222222222222222222222222 file_name /tmp/2.txt</span><br><span class="line">start get events 1 times</span><br><span class="line">get it</span><br><span class="line">root@keep-VirtualBox:/media/sf_VM_SHARE/code/blog_code/linux-kernel# more /tmp/2.txt</span><br><span class="line">222222222222222222222222222</span><br><span class="line">root@keep-VirtualBox:/media/sf_VM_SHARE/code/blog_code/linux-kernel#</span><br><span class="line">root@keep-VirtualBox:/media/sf_VM_SHARE/code/blog_code/linux-kernel#</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到在程序执行完之后， 文件有内容了。</p>
<p>好了，又Get 一个新知识。 </p>
<p>参考链接： <a href="https://oxnz.github.io/2016/10/13/linux-aio">https://oxnz.github.io/2016/10/13/linux-aio</a></p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>前段时间写的一个测试框架代码初版基本完成了，这两周一直在写文档， 不断的修改演化，画那个架构图画的有点儿晕了。正常的话，下周也要转正了吧，还得写个ppt，写文档真的也是一个能力啊，好好加油!</p>
<p>晚上回来出去跑了个步，然后再回来洗个澡。就把手机丢一边，专心搞了这篇文章，时间贼快啊， 23：30了，晚安!</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(25)-初识驱动开发</title>
    <url>/2022/06/19/2022-20220619-driver/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作需要，开始接触驱动开发了。</p>
<p>驱动作为硬件和软件的中间层，驱动就是驱使硬件设备行动的简述。驱动与底层的硬件打交道，根据硬件的工作方式，读写寄存器，完成设备的控制。驱动向上提供统一的API，使得软件可以使用通用的接口，通过不同的驱动来控制不同的设备。</p>
<span id="more"></span>

<h1 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h1><p>驱动根据是否有操作系统，分为无操作系统的驱动和有操作系统的驱动。在无操作系统的情况下，驱动的接口由驱动工程师自定义，暴露自定义的接口。在有操作系统的情况下，驱动的结构由操作系统定义，驱动工程师需要根据架构设计驱动，把驱动整合到操作系统的内核中。</p>
<p>操作系统为一类设备定义一套接口，相同类别的设备使用相同的方式编写驱动。可以看出，在有操作系统的情况下，驱动编写比较复杂，需要符合操作系统的架构。但是，通过操作系统的控制，我们可以享受到操作系统提供的一系列功能支持，比如多任务多并发、内存管理机制。而且，在操作系统的控制下，上层应用可以更方便的控制设备。</p>
<h2 id="驱动分类"><a href="#驱动分类" class="headerlink" title="驱动分类"></a>驱动分类</h2><p>根据设备类型分为字符设备、块设备和网络设备。</p>
<ul>
<li>字符设备：指那些必须以串行顺序依次进行访问的设备，如触摸屏、磁带驱动器、鼠标等</li>
<li>块设备： 备可以按任意顺序进行访问，以块为单位进行操作，如硬盘、eMMC 等</li>
<li>网络设备： 面向数据包的接收和发送而设计，它并不倾向于对应于文件系统的节点。</li>
</ul>
<p>网络设备是基于套接字API控制，字符设备和块设备基于文件系统来控制。</p>
<p><img src="/images/202206/driver01.png" alt="avatar"></p>
<h2 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h2><p>一般情况下，在Linux系统下，驱动作为内核的子模块，可以静态编译到内核中，也可以动态加载&#x2F;卸载。具体实现时，只需要在Makefile定义目标文件时区分一下就可以了。</p>
<ul>
<li>obj-y 表示对应的文件要编译链接到内核中。</li>
<li>obj-m 表示文件要作为模块编译。</li>
<li>obj-n 表示目标文件不会被编译。</li>
</ul>
<p>通过内核编译的配置，会生成不同的makefile，然后编译的时候会根据上述规则进行编译。</p>
<p>除了具有 obj- 形式的目标以外，还有 lib-y library 库、hostprogs-y 主机程序等目标，但是这两类基本都应用在特定的目录和场合下。</p>
<p>模块编译采用模块名加 -y 或 -objs 后缀的形式来定义模块的组成文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Makef ile for the linux ext2-f ilesystem routines.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">obj-$(CONF iG_EXT2_FS) += ext2.o</span></span><br><span class="line">ext2-y := balloc.o dir.o f ile.o fsync.o ialloc.o inode.o \</span><br><span class="line"> ioctl.o namei.o super.o symlink.o</span><br><span class="line"><span class="meta prompt_">ext2-$</span><span class="language-bash">(CONF iG_EXT2_FS_XATTR) += xattr.o xattr_user.o xattr_trusted.o</span></span><br><span class="line"><span class="meta prompt_">ext2-$</span><span class="language-bash">(CONF iG_EXT2_FS_POSIX_ACL) += acl.o</span></span><br><span class="line"><span class="meta prompt_">ext2-$</span><span class="language-bash">(CONF iG_EXT2_FS_SECURITY) += xattr_security.o</span></span><br><span class="line"><span class="meta prompt_">ext2-$</span><span class="language-bash">(CONF iG_EXT2_FS_XIP) += xip.o</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模块的名字为 ext2，由 balloc.o、dir.o、file.o 等多个目标文件最终链接生成 ext2.o 直至<br>ext2.ko 文件，并且是否包括 xattr.o、acl.o 等则取决于内核配置文件的配置情况，例如，如果<br>CONFIG_ EXT2_FS_POSIX_ACL 被选择，则编译 acl.c 得到 acl.o 并最终链接进 ext2。</p>
<h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><p>模块本身不会被编译进内核，可以控制内核的大小。模块一旦被加载，它就和其他部分是一样的。下面是一个最简单的模块编码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *who= <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> times = <span class="number">1</span>;</span><br><span class="line">module_param(times,<span class="type">int</span>,S_IRUSR);</span><br><span class="line">module_param(who,charp,<span class="number">0644</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;times;i++)</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;(%d) hello, %s!\n&quot;</span>,i,who);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello_api</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Call, %s from module hello!\n&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(hello_api);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Goodbye, %s!\n&quot;</span>,who);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Module named hello.&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Makefile</span></span><br><span class="line">KERN_DIR=/lib/modules/$(shell uname -r)/build</span><br><span class="line"></span><br><span class="line">EXTRA_CFLAGS=</span><br><span class="line">all:</span><br><span class="line">        make -C $(KERN_DIR) M=`pwd` modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        make -C $(KERN_DIR) M=`pwd` modules clean</span><br><span class="line">        rm -rf modules.order</span><br><span class="line"></span><br><span class="line">obj-m    += hello.o</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内核模块包括几个部分：</p>
<ul>
<li>加载函数， 使用insmod或者modprobe命令时，会执行加载函数，完成模块的初始化</li>
<li>卸载函数，使用rmmod命令时，会执行卸载函数，完成模块的卸载工作</li>
<li>模块许可证， 定义模块的许可证权限， 基本上使用GPL许可与</li>
<li>模块参数， 可以通过模块参数控制模块内部的全局变量的值， 可选</li>
<li>模块导出符号，导出的符号可以被其他模块使用，可选， 可以在&#x2F;proc&#x2F;kallsyms文件里看到符号</li>
<li>模块作者等信息</li>
</ul>
<p>这是一个最简单的模块，两个文件放到同一个目录下，然后make就可以生成目标文件hello.ko。<br>内核模块的安装卸载命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsmod # 查看内核模块信息</span><br><span class="line">insmod hello.ko # 加载hello模块</span><br><span class="line">rmmod hello # 删除hello模块</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看导出的符号</span></span><br><span class="line">root@keep-VirtualBox:/home/keep/code/code/test/616# cat /proc/kallsyms | grep hello_api</span><br><span class="line">ffffffffc0549010 r __kstrtab_hello_api  [hello]</span><br><span class="line">ffffffffc054901a r __kstrtabns_hello_api        [hello]</span><br><span class="line">ffffffffc0549000 r __ksymtab_hello_api  [hello]</span><br><span class="line">ffffffffc054801d t hello_api    [hello]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>printk输出的信息，可以使用dmesg命令查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[17139.388328] (0) hello, world!</span><br><span class="line">[17261.008559] Goodbye, world!</span><br><span class="line">[17265.353372] (0) hello, world!</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>开始学习驱动开发了，其实没什么困难的，驱动发展到现在，和其他所有领域一样，都有了一套完整的体系。剩下的就是花时间去学习了。</p>
<p>本周五的时候，小组开了一个会议，主要就是对我之前开发的一个程序进行设计评审吧，也算是一个找茬的会议。做软件的都是这样，当你完成一个功能之后，然后再给客户看的时候，他们就会产生各种新的想法。即使前面已经再三确认了需求，但是在功能完成之后，他们肯定会提出新的要求，甚至否认之前已经达成的共识。这个跟项目管理的关系是比较大的，任务没有跟踪，需求没有文档化。到最后，领导说什么就是什么了，呵呵。</p>
<p>软件开发就是一个不断迭代的过程，需求不断的变化，功能也需要不断地完善。这个都是无可厚非的。</p>
<p>但是，在这个小组内，就有一个比较奇怪的现象。就是希望一切都能够一步到位，在软件设计的阶段就希望把很多东西做的完美。希望一切都可以抽象化， 过程通用化，统一化。比较难接收的就是要求一次实现之后不能改动了。在这个方面，一时之间还是有点儿难以适应，不敢苟同。在过往做过的这么多项目中，项目都是迭代演进的，需求也是按紧急程度分批实现的。罗马不是一天就建成的。软件开发，也是尽量往简单, 易扩展性来开发，毕竟软件开发不是一锤子买卖，是需要长久发展演化，不断进行完善的。老是抱着古老的瀑布开发模式来管理项目，的确是有点儿不与时俱进的,关键也没按瀑布模式产生任务文档啊。</p>
<p>既来之，则安之，适应之，改变之。</p>
<p>加油！</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
        <category>驱动</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(27)-内核tcrypt加密算法测试模块代码解读</title>
    <url>/2022/07/02/2022-20220702-weekly-tcrypt/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux内核里有一个密码学框架Linux kernel crypto。框架内部提供了常用的标准算法，比如：AES， DES， MD5， SHA1， RSA，DSA等。框架也是支持开发者自定义算法的，通过框架可以注册我们自己的算法，比如国标的SM2, SM3, SM4等， 或者某个公司内部的私有算法。当然了， 也支持对已有的算法重新注册，可以通过优先级设置让用户调用到我们注册的算法。框架代码在内核源码下的crypto目录。</p>
<span id="more"></span>

<p>框架提供了一个算法的自检的实现，也就是tcrypt。在我们注册算法的时候，框架会自动使用我们提供的数据执行用例。</p>
<h1 id="tcrypt"><a href="#tcrypt" class="headerlink" title="tcrypt"></a>tcrypt</h1><p>tcrypt其实分为两个部分，一个是编译进内核的testmgr.c， 另外一个就是编译成模块的tcrypt.c。</p>
<h2 id="testmgr"><a href="#testmgr" class="headerlink" title="testmgr"></a>testmgr</h2><p>在我们往框架注册算法的时候，框架默认就会调用testmgr.c里的alg_test函数，查找对应的测试用例函数，找到之后就会执行用例，检测算法实现是否符合预期。如果没有对应的用例或者用例执行成功的话，则算法直接注册成功，否则注册失败。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 注册算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">crypto_register_alg</span><span class="params">(<span class="keyword">struct</span> crypto_alg *alg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crypto_larval</span> *<span class="title">larval</span>;</span></span><br><span class="line">	<span class="type">bool</span> test_started;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	alg-&gt;cra_flags &amp;= ~CRYPTO_ALG_DEAD;</span><br><span class="line">	err = crypto_check_alg(alg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;crypto_alg_sem);</span><br><span class="line">	larval = __crypto_register_alg(alg);</span><br><span class="line">	test_started = static_key_enabled(&amp;crypto_boot_test_finished);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR_OR_NULL(larval))</span><br><span class="line">		larval-&gt;test_started = test_started;</span><br><span class="line">	up_write(&amp;crypto_alg_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR_OR_NULL(larval))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(larval);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_started)</span><br><span class="line">		crypto_wait_for_test(larval);  <span class="comment">// 执行测试</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">crypto_wait_for_test</span><span class="params">(<span class="keyword">struct</span> crypto_larval *larval)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = crypto_probing_notify(CRYPTO_MSG_ALG_REGISTER, larval-&gt;adult);</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(err != NOTIFY_STOP))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	err = wait_for_completion_killable(&amp;larval-&gt;completion);</span><br><span class="line">	WARN_ON(err);</span><br><span class="line">	<span class="keyword">if</span> (!err)</span><br><span class="line">		crypto_notify(CRYPTO_MSG_ALG_LOADED, larval);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	crypto_larval_kill(&amp;larval-&gt;alg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调用到这边</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cryptomgr_test</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crypto_test_param</span> *<span class="title">param</span> =</span> data;</span><br><span class="line">	u32 type = param-&gt;type;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CRYPTO_MANAGER_DISABLE_TESTS</span></span><br><span class="line">	<span class="keyword">goto</span> skiptest;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type &amp; CRYPTO_ALG_TESTED)</span><br><span class="line">		<span class="keyword">goto</span> skiptest;</span><br><span class="line"></span><br><span class="line">	err = alg_test(param-&gt;driver, param-&gt;alg, type, CRYPTO_ALG_TESTED);</span><br><span class="line"></span><br><span class="line">skiptest:</span><br><span class="line">	crypto_alg_tested(param-&gt;driver, err);</span><br><span class="line"></span><br><span class="line">	kfree(param);</span><br><span class="line">	module_put_and_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们需要在testmgr.h里面定义测试的几组数据。如下 MD5算法的测试数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MD5 test vectors from RFC1321</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_testvec</span> <span class="title">md5_tv_template</span>[] =</span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.digest	= <span class="string">&quot;\xd4\x1d\x8c\xd9\x8f\x00\xb2\x04&quot;</span></span><br><span class="line">			  <span class="string">&quot;\xe9\x80\x09\x98\xec\xf8\x42\x7e&quot;</span>,</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		.plaintext = <span class="string">&quot;a&quot;</span>,</span><br><span class="line">		.psize	= <span class="number">1</span>,</span><br><span class="line">		.digest	= <span class="string">&quot;\x0c\xc1\x75\xb9\xc0\xf1\xb6\xa8&quot;</span></span><br><span class="line">			  <span class="string">&quot;\x31\xc3\x99\xe2\x69\x77\x26\x61&quot;</span>,</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		.plaintext = <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">		.psize	= <span class="number">3</span>,</span><br><span class="line">		.digest	= <span class="string">&quot;\x90\x01\x50\x98\x3c\xd2\x4f\xb0&quot;</span></span><br><span class="line">			  <span class="string">&quot;\xd6\x96\x3f\x7d\x28\xe1\x7f\x72&quot;</span>,</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		.plaintext = <span class="string">&quot;message digest&quot;</span>,</span><br><span class="line">		.psize	= <span class="number">14</span>,</span><br><span class="line">		.digest	= <span class="string">&quot;\xf9\x6b\x69\x7d\x7c\xb7\x93\x8d&quot;</span></span><br><span class="line">			  <span class="string">&quot;\x52\x5a\x2f\x31\xaa\xf1\x61\xd0&quot;</span>,</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		.plaintext = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>,</span><br><span class="line">		.psize	= <span class="number">26</span>,</span><br><span class="line">		.digest	= <span class="string">&quot;\xc3\xfc\xd3\xd7\x61\x92\xe4\x00&quot;</span></span><br><span class="line">			  <span class="string">&quot;\x7d\xfb\x49\x6c\xca\x67\xe1\x3b&quot;</span>,</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		.plaintext = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>,</span><br><span class="line">		.psize	= <span class="number">62</span>,</span><br><span class="line">		.digest	= <span class="string">&quot;\xd1\x74\xab\x98\xd2\x77\xd9\xf5&quot;</span></span><br><span class="line">			  <span class="string">&quot;\xa5\x61\x1c\x2c\x9f\x41\x9d\x9f&quot;</span>,</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		.plaintext = <span class="string">&quot;12345678901234567890123456789012345678901234567890123456789012&quot;</span></span><br><span class="line">			   <span class="string">&quot;345678901234567890&quot;</span>,</span><br><span class="line">		.psize	= <span class="number">80</span>,</span><br><span class="line">		.digest	= <span class="string">&quot;\x57\xed\xf4\xa2\x2b\xe3\xc9\x55&quot;</span></span><br><span class="line">			  <span class="string">&quot;\xac\x49\xda\x2e\x21\x07\xb6\x7a&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再在alg_test_descs里面添加映射关系， 注意这里有个巧妙的实现， 映射关系需要按照算法名升序加入。 因为在查找算法用例的时候，它其实是一个二分查找的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">		.alg = <span class="string">&quot;md4&quot;</span>,</span><br><span class="line">		.test = alg_test_hash,</span><br><span class="line">		.suite = &#123;</span><br><span class="line">			.hash = __VECS(md4_tv_template)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		.alg = <span class="string">&quot;md5&quot;</span>,</span><br><span class="line">		.test = alg_test_hash,</span><br><span class="line">		.suite = &#123;</span><br><span class="line">			.hash = __VECS(md5_tv_template)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		.alg = <span class="string">&quot;michael_mic&quot;</span>,</span><br><span class="line">		.test = alg_test_hash,</span><br><span class="line">		.suite = &#123;</span><br><span class="line">			.hash = __VECS(michael_mic_tv_template)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分法查找算法用例</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> alg_find_test(<span class="type">const</span> <span class="type">char</span> *alg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> end = ARRAY_SIZE(alg_test_descs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">		<span class="type">int</span> i = (start + end) / <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> diff = <span class="built_in">strcmp</span>(alg_test_descs[i].alg, alg);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			end = i;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (diff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			start = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>alg_test_hash是内核提供的一个测试hash算法的用例模板，里面的流程就是调用Linux kernel crypto框架提供的接口来运行算法，然后拿结果跟提供的数据作对比。关于这个接口的使用，在后面出文章讲一下。<br>不同的算法类型都有对应的测试函数，没有的话， 得研究一下怎么自己加一下。</p>
<h2 id="tcrypt模块"><a href="#tcrypt模块" class="headerlink" title="tcrypt模块"></a>tcrypt模块</h2><p>tcrypt.c则编译成一个内核模块，允许我们通过insmod&#x2F;modprobe 动态加载来测试不同的算法。它提供了好几个模块参数，加载模块的时候传递不同参数来控制调用不同的算法用例。</p>
<p>在我们编译完内核之后， 可以在&#x2F;lib&#x2F;modules&#x2F;5.17.1&#x2F;kernel&#x2F;crypto (5.17.1 是内核版本号)找到tcrypt.ko</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@keep-VirtualBox:/lib/modules/5.17.1/kernel/crypto# ls</span><br><span class="line">842.ko             authencesn.ko        chacha20poly1305.ko    ecdsa_generic.ko   ofb.ko               twofish_common.ko</span><br><span class="line">adiantum.ko        authenc.ko           chacha_generic.ko      echainiv.ko        pcbc.ko              twofish_generic.ko</span><br><span class="line">aegis128.ko        blake2b_generic.ko   cmac.ko                ecrdsa_generic.ko  pcrypt.ko            vmac.ko</span><br><span class="line">aes_ti.ko          blake2s_generic.ko   crc32_generic.ko       essiv.ko           poly1305_generic.ko  wp512.ko</span><br><span class="line">af_alg.ko          blowfish_common.ko   cryptd.ko              fcrypt.ko          rmd160.ko            xcbc.ko</span><br><span class="line">algif_aead.ko      blowfish_generic.ko  crypto_engine.ko       keywrap.ko         serpent_generic.ko   xor.ko</span><br><span class="line">algif_hash.ko      camellia_generic.ko  crypto_simd.ko         lrw.ko             sha3_generic.ko      xxhash_generic.ko</span><br><span class="line">algif_rng.ko       cast5_generic.ko     crypto_user.ko         lz4hc.ko           sm2_generic.ko       zstd.ko</span><br><span class="line">algif_skcipher.ko  cast6_generic.ko     curve25519-generic.ko  lz4.ko             sm3_generic.ko</span><br><span class="line">ansi_cprng.ko      cast_common.ko       des_generic.ko         md4.ko             sm4_generic.ko</span><br><span class="line">asymmetric_keys    ccm.ko               ecc.ko                 michael_mic.ko     streebog_generic.ko</span><br><span class="line">async_tx           cfb.ko               ecdh_generic.ko        nhpoly1305.ko      tcrypt.ko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@keep-VirtualBox:/lib/modules/5.17.1/kernel/crypto# insmod tcrypt.ko mode=1000</span><br><span class="line">insmod: ERROR: could not insert module tcrypt.ko: Resource temporarily unavailable</span><br><span class="line">root@keep-VirtualBox:/lib/modules/5.17.1/kernel/crypto# 7月 02 20:16:02 keep-VirtualBox kernel: alg des</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg md5</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg des3_ede</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg rot13</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: not found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg sha1</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg sha224</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg sha256</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg sm3</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg blowfish</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg twofish</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg serpent</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg sha384</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg sha512</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg md4</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg aes</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg cast6</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg arc4</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: not found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg michael_mic</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg deflate</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg crc32c</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg tea</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: not found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg xtea</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: not found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg khazad</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: not found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg wp512</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg wp384</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg wp256</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg xeta</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: not found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg fcrypt</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg camellia</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg seed</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: not found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg rmd160</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg lzo</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg lzo-rle</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg cts</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: not found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg sha3-224</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg sha3-256</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg sha3-384</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg sha3-512</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg streebog256</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: alg streebog512</span><br><span class="line">7月 02 20:16:02 keep-VirtualBox kernel: found</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入mode&#x3D;1000表示输出内核中注册的算法， 这里不包含组合的算法。具体的参数可以去看tcrypt.c的do_test函数。如果我们要自己添加一个测试算法的入口，那么只需要增加一个case， 然后调用我们自己指定的算法就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_test</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *alg, u32 type, u32 mask, <span class="type">int</span> m, u32 num_mb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (m) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="number">159</span>:</span><br><span class="line">            ret += tcrypt_test(<span class="string">&quot;cmac(sm4)&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">160</span>:</span><br><span class="line">            ret += tcrypt_test(<span class="string">&quot;zuc&quot;</span>); <span class="comment">// 加一个祖冲之算法测试用例调用入口</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>要能tcrypt测试， 还需要在内核编译make menuconfig的时候选择</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">--- Cryptographic API                                                                        │ │</span><br><span class="line"> │ │                            *** Crypto core or helper ***                                                          │ │</span><br><span class="line"> │ │                      -*-   Cryptographic algorithm manager                                                        │ │</span><br><span class="line"> │ │                      &lt;M&gt;   Userspace cryptographic algorithm configuration                                        │ │</span><br><span class="line"> │ │                      [ ]   Disable run-time self tests                                                            │ │ # 不选择</span><br><span class="line"> │ │                      -*-   Null algorithms                                                                        │ │</span><br><span class="line"> │ │                      &lt;M&gt;   Parallel crypto engine                                                                 │ │</span><br><span class="line"> │ │                      &#123;M&#125;   Software async crypto daemon                                                           │ │</span><br><span class="line"> │ │                      &#123;M&#125;   Authenc support                                                                        │ │</span><br><span class="line"> │ │                      &lt;M&gt;   Testing module                                                                         │ │  # 选择</span><br><span class="line"> │ │                            *** Public-key cryptography ***                                                        │ │</span><br><span class="line"> │ │                      -*-   RSA algorithm                                                                          │ │</span><br><span class="line"> │ │                      -*-   Diffie-Hellman algorithm                                                               │ │</span><br><span class="line"> │ │                      &#123;M&#125;   ECDH algorithm                                                                         │ │</span><br><span class="line"> │ │                      &lt;M&gt;   ECDSA (NIST P192, P256 etc.) algorithm                                                 │ │</span><br><span class="line"> │ │                      &lt;M&gt;   EC-RDSA (GOST 34.10) algorithm                                                         │ │</span><br><span class="line"> │ │                      &lt;M&gt;   SM2 algorithm                                                                          │ │</span><br><span class="line"> │ │                      &lt;M&gt;   Curve25519 algorithm                                                                   │ │</span><br><span class="line"> │ │                      &#123;M&#125;   x86_64 accelerated Curve25519 scalar multiplication library                            │ │</span><br><span class="line"> │ │                            *** Authenticated Encryption with Associated Data ***                                  │ │</span><br><span class="line"> │ │                      &#123;M&#125;   CCM support                                                                            │ │</span><br><span class="line"> │ │                      &#123;*&#125;   GCM/GMAC support                                                                       │ │</span><br><span class="line"> │ │                      &#123;M&#125;   ChaCha20-Poly1305 AEAD support                                                         │ │</span><br><span class="line"> │ │                      &lt;M&gt;   AEGIS-128 AEAD algorithm                                                               │ │</span><br><span class="line"> │ │                      &lt;M&gt;   AEGIS-128 AEAD algorithm (x86_64 AESNI+SSE2 implementation)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>最近股市行情不错，账户也已经回血了许多。但是搞了大半年，发现也就是几千块钱的收益(哈哈，主要是本金少)，还不如好好工作，拿个好绩效，做出成绩来得更实在一些。</p>
<p>另外，六月份的时候工作也转正了，工作上的事情还是蛮多的，有很多事情可以做，单单把目前看到的事情做好就得有个一两年吧。好好学习，天天向上吧。</p>
<p>现在开始做驱动开发，每天都会花个半小时到1小时的时间看驱动的书《Linux驱动开发详解：基于最新Linux4.0内核》,也是个大块头啊，发现内核里面做的事情还是很多的，有的学了。工作的时候，看到很多新的概念名词，还有知识点，由于实在太多，很多没有深入，但是基本上都记录下来了，需要多花写时间梳理小结一下，下半年出文章的数量估计会多一些, 当然保底依旧是每周一篇的。</p>
<p>周末和晚上的时间可以好好利用，做好规划，不断地在知识的海洋中遨游！</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(28)-内核调用crypto算法代码解析</title>
    <url>/2022/07/09/2022-20220709-linux-kernel-crypto/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上周讲了使用tcrypt对内核加密框架linux kernel crypto中算法的测试。今天具体看一下几个示例。</p>
<p>算法类型分为4种： hash、对称、非对称、随机数。</p>
<span id="more"></span>

<h2 id="hash算法调用"><a href="#hash算法调用" class="headerlink" title="hash算法调用"></a>hash算法调用</h2><p>对hash算法的调用主要有几个步骤：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg</span>[<span class="title">TVMEMSIZE</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">crypto_wait</span> <span class="title">wait</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ahash_request</span> *<span class="title">req</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">crypto_ahash</span> *<span class="title">tfm</span>;</span></span><br><span class="line"><span class="type">char</span> *output;</span><br><span class="line"><span class="type">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">tfm = crypto_alloc_ahash(algo, <span class="number">0</span>, mask); <span class="comment">// 根据算法名找到tfm</span></span><br><span class="line">   ...</span><br><span class="line">   test_hash_sg_init(sg); <span class="comment">// 创建输入数据</span></span><br><span class="line">   req = ahash_request_alloc(tfm, GFP_KERNEL); <span class="comment">//申请一个request</span></span><br><span class="line"></span><br><span class="line">   crypto_init_wait(&amp;wait); <span class="comment">// 初始化一个完成量</span></span><br><span class="line">ahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span><br><span class="line">			   crypto_req_done, &amp;wait); <span class="comment">// 设置完成回调</span></span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   output = kmalloc(MAX_DIGEST_SIZE, GFP_KERNEL); <span class="comment">//申请输出空间</span></span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (klen) <span class="comment">// 如果算法有key，设置key</span></span><br><span class="line">		crypto_ahash_setkey(tfm, tvmem[<span class="number">0</span>], klen);</span><br><span class="line">   </span><br><span class="line">   ret = crypto_wait_req(crypto_ahash_init(req), &amp;wait); <span class="comment">// hash初始化调用</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 把输入和输出的指针设置进去， 调用update  根据数据的多少 可能调用多次</span></span><br><span class="line">   ahash_request_set_crypt(req, sg, output, speed[i].plen);</span><br><span class="line">   ret = crypto_wait_req(crypto_ahash_update(req), &amp;wait);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后调用final</span></span><br><span class="line">   ahash_request_set_crypt(req, &amp;sg, out, <span class="number">0</span>);</span><br><span class="line">ret = crypto_wait_req(crypto_ahash_final(req), &amp;wait);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个是典型的init, update, final的流程。 有时候，数据没有那么长， 可以直接调用digest接口 一次运算就得到结果。 还有一个就是  init, update , finup的流程， 最后一次的upate和final结合起来， 中间可能就没有update的调用。</p>
<p>主要根据用户对数据的长度判断来决定。总之最后的结果肯定都是一样的。</p>
<h1 id="对称算法调用"><a href="#对称算法调用" class="headerlink" title="对称算法调用"></a>对称算法调用</h1><p>大的总体流程都是差不多的，首先根据算法名创建tfm，然后设置key， iv，最后再调用加解密的接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> tfm = crypto_alloc_skcipher(algo, <span class="number">0</span>, async ? <span class="number">0</span> : CRYPTO_ALG_ASYNC); <span class="comment">// 申请tfm</span></span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> req = skcipher_request_alloc(tfm, GFP_KERNEL); <span class="comment">// 申请request</span></span><br><span class="line"></span><br><span class="line"> skcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span><br><span class="line">	      crypto_req_done, &amp;wait);</span><br><span class="line"></span><br><span class="line"> ret = crypto_skcipher_setkey(tfm, key, *keysize); <span class="comment">// 设置key</span></span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">     pr_err(<span class="string">&quot;setkey() failed flags=%x\n&quot;</span>,</span><br><span class="line">         crypto_skcipher_get_flags(tfm));</span><br><span class="line">     <span class="keyword">goto</span> out_free_req;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//初始化数据</span></span><br><span class="line"> sg_init_table(sg, DIV_ROUND_UP(k, PAGE_SIZE));</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"> sg_set_buf(sg, tvmem[<span class="number">0</span>] + *keysize, bs);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 设置iv</span></span><br><span class="line"> skcipher_request_set_crypt(req, sg, sg, bs, iv); <span class="comment">// 加密</span></span><br><span class="line"></span><br><span class="line"> ret =  crypto_wait_req(crypto_skcipher_encrypt(req), wait); </span><br><span class="line"></span><br><span class="line"><span class="comment">//释放空间</span></span><br><span class="line"> skcipher_request_free(req);</span><br><span class="line"> crypto_free_skcipher(tfm);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="非对称算法调用"><a href="#非对称算法调用" class="headerlink" title="非对称算法调用"></a>非对称算法调用</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   tfm = crypto_alloc_akcipher(driver, type, mask);</span><br><span class="line"></span><br><span class="line">   req = akcipher_request_alloc(tfm, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">   crypto_init_wait(&amp;wait);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (vecs-&gt;public_key_vec)</span><br><span class="line">	err = crypto_akcipher_set_pub_key(tfm, key, vecs-&gt;key_len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	err = crypto_akcipher_set_priv_key(tfm, key, vecs-&gt;key_len);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   out_len_max = crypto_akcipher_maxsize(tfm);</span><br><span class="line">outbuf_enc = kzalloc(out_len_max, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!outbuf_enc)</span><br><span class="line">	<span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!vecs-&gt;siggen_sigver_test) &#123;</span><br><span class="line">	m = vecs-&gt;m;</span><br><span class="line">	m_size = vecs-&gt;m_size;</span><br><span class="line">	c = vecs-&gt;c;</span><br><span class="line">	c_size = vecs-&gt;c_size;</span><br><span class="line">	op = <span class="string">&quot;encrypt&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* Swap args so we could keep plaintext (digest)</span></span><br><span class="line"><span class="comment">	 * in vecs-&gt;m, and cooked signature in vecs-&gt;c.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	m = vecs-&gt;c; <span class="comment">/* signature */</span></span><br><span class="line">	m_size = vecs-&gt;c_size;</span><br><span class="line">	c = vecs-&gt;m; <span class="comment">/* digest */</span></span><br><span class="line">	c_size = vecs-&gt;m_size;</span><br><span class="line">	op = <span class="string">&quot;verify&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   sg_init_table(src_tab, <span class="number">3</span>);</span><br><span class="line">sg_set_buf(&amp;src_tab[<span class="number">0</span>], xbuf[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line">sg_set_buf(&amp;src_tab[<span class="number">1</span>], xbuf[<span class="number">0</span>] + <span class="number">8</span>, m_size - <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (vecs-&gt;siggen_sigver_test) &#123;</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(c_size &gt; PAGE_SIZE))</span><br><span class="line">		<span class="keyword">goto</span> free_all;</span><br><span class="line">	<span class="built_in">memcpy</span>(xbuf[<span class="number">1</span>], c, c_size);</span><br><span class="line">	sg_set_buf(&amp;src_tab[<span class="number">2</span>], xbuf[<span class="number">1</span>], c_size);</span><br><span class="line">	akcipher_request_set_crypt(req, src_tab, <span class="literal">NULL</span>, m_size, c_size);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	sg_init_one(&amp;dst, outbuf_enc, out_len_max);</span><br><span class="line">	akcipher_request_set_crypt(req, src_tab, &amp;dst, m_size,</span><br><span class="line">				   out_len_max);</span><br><span class="line">&#125;</span><br><span class="line">akcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span><br><span class="line">			      crypto_req_done, &amp;wait);</span><br><span class="line"></span><br><span class="line">err = crypto_wait_req(vecs-&gt;siggen_sigver_test ?</span><br><span class="line">		      <span class="comment">/* Run asymmetric signature verification */</span></span><br><span class="line">		      crypto_akcipher_verify(req) :</span><br><span class="line">		      <span class="comment">/* Run asymmetric encrypt */</span></span><br><span class="line">		      crypto_akcipher_encrypt(req), &amp;wait);</span><br><span class="line"></span><br><span class="line">   ...             </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 释放空间</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<h2 id="随机数算法调用"><a href="#随机数算法调用" class="headerlink" title="随机数算法调用"></a>随机数算法调用</h2><p>&#x2F;&#x2F; 参考testmgr.c  alg_test_cprng函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  rng = crypto_alloc_rng(driver, type, mask);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  seedsize = crypto_rng_seedsize(tfm);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(result, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(seed, template[i].v, template[i].vlen);</span><br><span class="line"><span class="built_in">memcpy</span>(seed + template[i].vlen, template[i].key,</span><br><span class="line">       template[i].klen);</span><br><span class="line"><span class="built_in">memcpy</span>(seed + template[i].vlen + template[i].klen,</span><br><span class="line">       template[i].dt, template[i].dtlen);</span><br><span class="line"></span><br><span class="line">err = crypto_rng_reset(tfm, seed, seedsize);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">	printk(KERN_ERR <span class="string">&quot;alg: cprng: Failed to reset rng &quot;</span></span><br><span class="line">	       <span class="string">&quot;for %s\n&quot;</span>, algo);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; template[i].loops; j++) &#123;</span><br><span class="line">	err = crypto_rng_get_bytes(tfm, result,</span><br><span class="line">				   template[i].rlen);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;alg: cprng: Failed to obtain &quot;</span></span><br><span class="line">		       <span class="string">&quot;the correct amount of random data for &quot;</span></span><br><span class="line">		       <span class="string">&quot;%s (requested %d)\n&quot;</span>, algo,</span><br><span class="line">		       template[i].rlen);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// result中就是结果了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="scatterlist"><a href="#scatterlist" class="headerlink" title="scatterlist"></a>scatterlist</h2><p>在前面的代码中看到，在设置数据的时候，很多地方使用了sg_init_table、	sg_set_buf函数，使用的就是scatterlist这个结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	page_link; <span class="comment">// 页索引， 4字节对齐的</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	offset; <span class="comment">//  页内偏移</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	length; <span class="comment">//长度</span></span><br><span class="line">	<span class="type">dma_addr_t</span>	dma_address; <span class="comment">// dma地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NEED_SG_DMA_LENGTH</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	dma_length;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于一个给定的数据块，在内存中可能是在一些离散的区域。scatterlist就是把这些区域信息汇聚在一起的结构，一般是以数组的形式出现。</p>
<p>sg_init_table用来初始化这一个数组，参数是数组指针和元素的个数。内部实现就是清空内存，然后在最后一个元素中page_link成员中设置结束标识。</p>
<p>sg_set_buf就是把缓冲区的地址和长度设置到每个scatterlist元素中。</p>
<p>然后，算法调用的时候再通过xxxkcipher_request_set_crypt函数把scatterlist形式的数据设置到request中的src&#x2F;dst。</p>
<p>另一边，在算法实现接口中，取出src&#x2F;dst。获取到对应的虚拟地址，也就得到了数据，然后进行算法计算。</p>
<p>参考代码： <code>https://gitee.com/fishmwei/blog_code/blob/master/linux-kernel/crypto_example/crypto.c</code></p>
<p>执行效果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd crypto_example</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">journalctl  -f &amp;</span><br><span class="line">insmod crypto.ko alg=aes len=16</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/202207/crypto_example.png" alt="avatar"></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>ZUC(祖冲之)算法</title>
    <url>/2022/07/10/2022-20220710-zuc/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ZUC</code>是一个对称流密码算法，其以中国古代著名数学家祖冲之的拼音(<code>ZU Chongzhi</code>)首字母命名，中文称作祖冲之算法。</p>
<p>这段时间在实现<code>ZUC</code>算法的驱动，<code>ZUC</code>是一个国产的密码算法集。包含了三个部分，分别是算法的描述，也就是如何产生密钥流的。然后就是保密性算法，用于对数据进行加解密。最后就是完整性算法，类似于<code>MD5</code>等的摘要算法，为给定的数据计算出一个唯一的消息认证码，用于确认消息在传递的过程中不被篡改。</p>
<span id="more"></span>

<p><code>ZUC</code>算法于 2011 年 9 月正式被 3GPP SA全会通过，成为 3GPP LTE 第三套加密标准核心算法。<code>ZUC</code>算法是中国第一个成为国际密码标准的密码算法。</p>
<p><code>ZUC</code>相关的国家标准文档可以在国家标准全文公开系统上面查询到。网址：<code>http://www.gb688.cn/bzgk/gb/index</code></p>
<p><img src="/images/202207/gb668.png" alt="avatar"></p>
<p><code>ZUC</code>是一种流加密算法，按位进行加密，跟<code>SNOW3G</code>是一样的算法。也是一种对称加密算法，跟<code>AES</code>等对称算法不同的是，它加解密的流程是完全一样的。一般对称算法加密和解密流程会有稍微的差别，只是加解密的密钥是完全一样的。</p>
<p>在<code>GMSSL</code>有关于<code>ZUC</code>算法的实现代码，可以参照标准和代码学习。不过在<code>GMSSL</code>中，仅仅实现了保密性算法的<code>EVP</code>，并没有实现完整性算法。不能直接使用<code>OpenSSL</code>调用完整性算法。<code>zuctest.c</code>文件给出了标准文档的数据测试用例。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>在线预览链接： </p>
<p><code>http://c.gb688.cn/bzgk/gb/showGb?type=online&amp;hcno=8C41A3AEECCA52B5C0011C8010CF0715</code></p>
<p>这个部分给出了祖冲之算法的一般结构。</p>
<p><img src="/images/202207/zuc_struct.png" alt="avatar"></p>
<p>这一部分主要描述的是如何根据输入的初始密钥k和初始向量iv、以及输入数据的长度得到同等长度的密钥字。</p>
<h2 id="保密性算法"><a href="#保密性算法" class="headerlink" title="保密性算法"></a>保密性算法</h2><p>在线预览链接： </p>
<p><code>http://c.gb688.cn/bzgk/gb/showGb?type=online&amp;hcno=5D3CBA3ADEC7989344BD1E63006EF2B3</code></p>
<p>这个部分描述了保密性算法的输入与输出。<br><img src="/images/202207/zuc_enc.png" alt="avatar"></p>
<p>一般情况下，比如在LTE应用场景中，初始向量IV是根据给定的参数得到的，然后再计算出密钥流，结合输入数据计算加密结果。</p>
<p><img src="/images/202207/zuc_iv_init.png" alt="avatar"></p>
<p>在加密的过程中，由于密钥流都是按照字来输出的，所以除了最后一片数据外,每次加密的数据的长度最好都是4字节的整数倍。</p>
<h2 id="完整性算法"><a href="#完整性算法" class="headerlink" title="完整性算法"></a>完整性算法</h2><p>在线预览链接：</p>
<p><code>http://c.gb688.cn/bzgk/gb/showGb?type=online&amp;hcno=C6D60AE0A7578E970EF2280ABD49F4F0</code></p>
<p>这个部分描述了完整性算法的输入与输出。</p>
<p><img src="/images/202207/zuc_dgst.png" alt="avatar"></p>
<p>跟保密性算法相同，初始向量IV也由具体的参数计算出来。</p>
<p><img src="/images/202207/zuc_eia_iv.png" alt="avatar"></p>
<p>在计算的过程中，由于密钥流都是按照字来输出的，所以除了最后一片数据外,每次处理的数据的长度最好都是4字节的整数倍。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>根据算法的描述文档，结合GMSSL的软算法的实现，可以比较容易的实现算法流程。</p>
<p>对称算法的原理，其实主要还是基于计算机的异或操作，同样的数，连续两次跟相同的数进行异或，结果就是其本身。</p>
<p>数学科学是一门比较神奇的学科，根据其产生了许多的应用。</p>
<p>了解一个算法，最好的方法就是去看官方文档，中国的国家标准可以从上面那个网站查询到。对于美国的nist文档(比如AES、DES等算法文档)，可以到<code>https://www.nist.gov/</code>网站查询，下面是AES算法文档链接： <code>https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf</code>， 比较方便的是这个网站上面的文档是可以下载的，但是我们国家的标准网站上面的文档只能在线看，当然对于文档页数不多的，可以自己截图保存再自行导出<code>pdf</code>文件。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(26)-Linux文件系统与驱动</title>
    <url>/2022/06/23/2022-20220623-linux-fs/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Linux中一切都是文件，所有的资源都是通过文件的形式来访问控制的。</p>
<p>驱动最终通过文件相关的系统调用来访问，Linux的驱动架构也是基于文件系统而设计的。</p>
<span id="more"></span>

<h1 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h1><h2 id="Linux文件目录"><a href="#Linux文件目录" class="headerlink" title="Linux文件目录"></a>Linux文件目录</h2><p>Linux根目录下面存在一些特定的目录，这些目录里面存放约定好的文件。</p>
<ul>
<li>bin 存放基本命令程序</li>
<li>sbin 存放系统命令的程序</li>
<li>dev 设备文件存储目录，通过这些文件的访问操作来控制设备</li>
<li>etc 配置文件目录</li>
<li>lib 库文件的存放目录</li>
<li>mnt 一般用于存放挂载存储设备的目录， &#x2F;etc&#x2F;fstab里面可以设置一些自动挂载的目录</li>
<li>opt 可选软件安装目录</li>
<li>proc 操作系统运行时， 进程及内核的信息， proc不是真正的文件系统，而是存在内存中的</li>
<li>tmp 临时文件目录</li>
<li>usr 用户存放程序的目录</li>
<li>var 经常变动的文件放在这里 比如log文件</li>
<li>sys sysfs文件系统映射的目录。Linux设备驱动模型中的总线、驱动和设备都可以在这里找到对应的文件节点。上篇文章中的内核模块安装后也会在&#x2F;sys&#x2F;module里面创建对应的节点。</li>
</ul>
<p>在内核中，用一个file_operations的结构控制文件的访问接口。每个打开的文件都有一个struct file对应，文件关闭后才释放， 里面存放了文件的一些flag和属性。在vfs中文件还对应一个indode的结构体，保存文件的权限属性、大小、访问时间等。</p>
<p><img src="/images/202206/fs_driver.png" alt="avatar"></p>
<p>在&#x2F;proc&#x2F;devices文件中记录了系统中的所有设备。第一列是主设备号，第二列是设备名。</p>
<h2 id="devfs和udev"><a href="#devfs和udev" class="headerlink" title="devfs和udev"></a>devfs和udev</h2><p>devfs设备文件系统使得驱动可以自己管理设备文件，内核2.4版本引入的。一般在驱动加载的时候创建文件，在驱动卸载的时候删除文件。</p>
<p><img src="/images/202206/devfs.png" alt="avatar"></p>
<p>udev用于取代devfs， 在内核2.6版本引入。udev工作在用户态，利用设备加入或者移除时发送的热插拔事件来工作。在设备热插拔时，内核会通过netlink套接字把信息发送出来， uevent。程序在接收到uevent后，根据信息管理文件。</p>
<p>下面有个例子，接收内核通过netlink发送出来的uevent的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    write(<span class="number">2</span>, s, <span class="built_in">strlen</span>(s));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nls</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;nls, <span class="number">0</span>, <span class="keyword">sizeof</span>(nls));</span><br><span class="line">    nls.nl_family = AF_NETLINK;</span><br><span class="line">    nls.nl_pid = getpid();</span><br><span class="line">    nls.nl_groups= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pfd.events = POLLIN;</span><br><span class="line">    pfd.fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);</span><br><span class="line">    <span class="keyword">if</span> (pfd.fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;not root\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(pfd.fd, (<span class="type">void</span>*)&amp;nls, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_nl)))</span><br><span class="line">        die(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">-1</span> != poll(&amp;pfd, <span class="number">1</span>, <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> i, len = recv(pfd.fd, buf, <span class="keyword">sizeof</span>(buf), MSG_DONTWAIT);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">            die(<span class="string">&quot;recv\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>, buf+i);</span><br><span class="line">            i += <span class="built_in">strlen</span>(buf+i) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    die(<span class="string">&quot;poll\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译运行之后，在virtual虚拟机可以控制CD光盘的加载删除触发uevent， 点击确定。</p>
<p><img src="/images/202206/addcd.png" alt="avatar"></p>
<p> 效果如下：</p>
<p><img src="/images/202206/getuevent.png" alt="avatar"></p>
<p>对于冷设备， 可以往&#x2F;sys&#x2F;module&#x2F;psmouse&#x2F;uevent写入一个add触发uevent。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">echo &quot;add&quot;&gt;/sys/module/psmouse/uevent</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">收到的信息如下</span></span><br><span class="line"></span><br><span class="line">ACTION=add</span><br><span class="line">DEVPATH=/module/psmouse</span><br><span class="line">SUBSYSTEM=module</span><br><span class="line">SYNTH_UUID=0</span><br><span class="line">SEQNUM=2736</span><br><span class="line">USEC_INITIALIZED=384805379</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>udev有对应的工具监控netlink。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">udevadm monitor --kernel --property --udev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>了解了netlink的使用， udev文件系统的工作的原理， 还有linux系统主要目录的用途、驱动跟文件系统的关联。一步步地加深对Linux内核的了解。</p>
<p>最近看了项目的驱动的代码，从一头雾水到渐渐明晰，这是个学习的过程，通过小结记录下相关的知识，加深印象和理解，不断进步中。。。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(29)-snow3g流密码算法</title>
    <url>/2022/07/17/2022-20220717-snow3g/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面讲过<code>ZUC</code>算法是3GPP LTE 第三套加密标准核心算法，而<code>Snow 3G</code>则是第二套加密标准核心算法，<code>ZUC</code>和<code>Snow 3G</code>算法的英文描述可以在这个网站上找到:</p>
<p><code>https://www.gsma.com/security/security-algorithms/</code></p>
<p><img src="/images/202207/3gpp_security.png" alt="avatar"></p>
<span id="more"></span>

<p>实现完<code>ZUC</code>的驱动后，这周实现了一下<code>Snow 3G</code>的驱动，顺带学习了一下这个算法。</p>
<h1 id="Snow-3G"><a href="#Snow-3G" class="headerlink" title="Snow 3G"></a>Snow 3G</h1><p><code>Snow 3G</code>也包含了完整性算法<code>UEA2</code>和保密性算法<code>UIA2</code>两个部分，同时也依赖一个算法描述如何生成密钥流。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>文档链接 <code>https://www.gsma.com/security/wp-content/uploads/2019/05/snow3gspec.pdf</code></p>
<p>根据输入的密钥和IV初始化，而后根据输入的数据长度产生密钥流。</p>
<p><img src="/images/202207/snow3g_spec.png" alt="avatar"></p>
<p>在文档后面还有对应的C语言实现程序，当然只是一个基础的实现，如果要应用到实际的产品中还需要重构一下。</p>
<h2 id="保密性算法"><a href="#保密性算法" class="headerlink" title="保密性算法"></a>保密性算法</h2><p>文档链接 <code>https://www.gsma.com/security/wp-content/uploads/2019/05/uea2uia2d1v21.pdf</code></p>
<p><img src="/images/202207/uea2.png" alt="avatar"></p>
<p><code>UEA2</code>是一种流加密算法，按位进行加解密。从上图中可以看到对应的输入参数和输出结果。这些参数首先会根据固定的算法产生IV数据，然后按照算法描述产生密钥流，最终跟要加密或者解密的数据进行运算得到最终的结果。</p>
<p><img src="/images/202207/uea2b.png" alt="avatar"></p>
<p>同样的，在文档的后面有对应的C语言实现程序。</p>
<h2 id="完整性算法"><a href="#完整性算法" class="headerlink" title="完整性算法"></a>完整性算法</h2><p>文档链接跟保密性算法是同一个文档。</p>
<p><img src="/images/202207/uia2.png" alt="avatar"></p>
<p>具体的计算过程可以参考文档。在文档的后面也有对应的C语言实现程序。</p>
<p>不过完整性算法的C语言代码，最后计算MAC是有错误的，需要修改一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*原始代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    MAC_I[i] = (mac32 &gt;&gt; (<span class="number">8</span>*(<span class="number">3</span>-i))) &amp; <span class="number">0xff</span>; <span class="comment">/* mac32是一个没有定义的变量 */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> MAC_I; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改代码 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">    MAC_I[i] = ((EVAL &gt;&gt; (<span class="number">56</span> - (i * <span class="number">8</span>))) ^ ((z[<span class="number">4</span>]) &gt;&gt; (<span class="number">24</span> - (i * <span class="number">8</span>)))) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> MAC_I;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我也是参考了一个go语言的<code>snow3g</code>的实现，然后是验证通过了的。</p>
<p><code>https://github.com/frankurcrazy/snow3g/blob/master/uia2/uia2.go</code></p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这个<code>3gpp</code>的英文文档内容还是比较齐全的，而且还自带了算法的实现代码。同样的，<code>ZUC</code>对应的<code>EEA3</code>和<code>EIA3</code>算法也有代码。不过，经过验证，我发现了一个问题，那就是<code>ZUC</code>的样例数据是按照大端字节序测试的，在小端主机上面，需要先把原始的数据转换一下字节序，才能得到正确的结果。而那个<code>snow 3g</code>的测试数据本身就认为你是小端的，在小端主机上面不需要转换字节序，计算出的结果就跟他的示例数据是一致的。如果有人研究的话，注意一下这点区别。</p>
<p>多学点知识还是有好处的，这边有个工作中的小插曲。</p>
<p>就是工作上需要在新的机型上验证一个功能，但是验证平台资源比较紧俏，运行速度又慢，而且很多人排着队等着去使用。那没有办法了，你只能在现有的机器资源上面先把代码编译测试了，然后再弄到新的机型上面去验证。也就是先本地验证了把基本的流程走通了，再换环境验证一下。不同的环境就有个系统版本不一致的问题，主要就是那个glibc的库不一样，系统内核版本不一样，那么就需要用到docker这个东西了。需要在本地搭建一个跟新机型上面环境一致的镜像系统，在这个镜像里面编译好了，再把生成的二进制拷贝到新机型上面验证。今年不是刚好看了一些docker的基础使用吗，然后自然就很快的用上了，节省了许多时间。</p>
<p>多学点东西是不错的，有博客记录一下更不错了，到用的时候可以来查一查，事半功倍。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(30)-ecc曲线原理</title>
    <url>/2022/07/24/2022-20220724-ecc/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周完成了流密码算法的驱动开发及调试。毕竟对驱动的一些机制了解的还不够深，还是花了许多时间才调试完成，加了三天的班。中间遇到了一个dma内存映射的问题，由于映射时参数错误导致数据一直没有更新。前面写驱动代码的时候，也只是参照着其它算法的代码写的，那个算法的代码比较久了，没有及时地更新，导致又走了些同样弯路。总之，还是自己对驱动相关的知识没有掌握导致的。</p>
<span id="more"></span>

<p>周五的时候就开始研究ECC曲线算法了，前面计划这周完成流密码算法的调试和ECC曲线编码的。计划赶不上变化，时间变得有些匆忙了。由于也是第一次接触这个ECC曲线算法，周五的时候花了一天的时间学习了一下。</p>
<h1 id="ECC曲线"><a href="#ECC曲线" class="headerlink" title="ECC曲线"></a>ECC曲线</h1><p>ECC算是非对称密码算法，提供签名验签的功能(ECDSA)，另外就是用于派生密钥(ECDH)。跟RSA的功能是相同的，不过效率会更高一些，安全性更好。</p>
<p>公钥密码学，是基于数学原理的，好比RSA获得两个大素数可以容易计算其乘积，但是通过乘积却很难因式分解到两个大素数。ECC曲线也是类似，给定固定参数的ECC曲线上， 然后给点一个点和常数k， 可以得到进行k次点乘后的点，但是通过两个点很难推出那个常量。</p>
<p>RSA的私钥和公钥都可以用来加密，不过ECC却不能这样，ECC的私钥是一个长度固定的数k，公钥是一对数(一个点的坐标Gx, Gy)。</p>
<p>ECC的标准有中国的国密SM2， 还有SECG组织的secp256k1, secp256r1。256表示私钥的长度，sec就是组织简称， p是素数prime的意思，k是一组曲线的名称(Koblitz提出的)，r就是随机数了。其中，secp256k1现在用于区块链，是区块链行业的标准了。安卓系统使用secp256r1.</p>
<p>ECC曲线满足下面这个方程式：</p>
<p><img src="/images/202207/ecc_expr.png" alt="ecc_expr"></p>
<p>至于ECC曲线长什么样，可以通过一个网站<code>https://www.geogebra.org/calculator</code>输入方程式得到曲线的形状。</p>
<p><img src="/images/202207/ecc_draw.png" alt="ecc_draw"></p>
<h2 id="数学概念"><a href="#数学概念" class="headerlink" title="数学概念"></a>数学概念</h2><p>ECC涉及到一些数学概念，只有了解了这些概念，后面才能更容易理解ECC是个什么玩意，为啥能够用来加解密。</p>
<p>取模，就是简单的算术模。主要用于把无穷的数，限定到一个有限的数域里面，这是个多对一的关系。</p>
<h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p>如果存在这么个元素的集合G，针对这个集合内部任意两个元素，定义了一个操作o，如果下列性质得到满足，那么G就叫作一个群，记为（G，o）。</p>
<p>A.1 满足封闭性——对于任意两个G里面的元素a和b做操作aob，得到的结果也属于G。<br>A.2 满足结合律——对于G中的任意元素a、b和c，都有（aob)oc&#x3D;ao(boc）成立。<br>A.3 唯一中性元——G中存在唯一个元素I，对于G中任意元素a，都有aoI&#x3D;Ioa&#x3D;a成立。<br>A.4 存在逆元——对于G中任意元素a，G中都能找到另一个唯一元素 [公式] ，使得 [公式] 。成立，那么 [公式] 就是a的逆元。<br>A.5 如果满足交换律——对于任意两个G里面的元素a和b，aob&#x3D;boa，那么这个群是交换群（也称为阿贝尔群）。<br>A.6 如果一个群中的元素是有限的，称这个群是一个有限群；否则称这个群是一个无限群。有限群中元素的个数称为群的阶(Group order)，通常记为n。这里n一定是个素数。<br>A.7 对于n阶有限群有两个特别重要的特性：<br>A.7.1 对于这个群的任意一个元素a做n次操作，我们必然能够得到中性元。即 [公式] 。此处特别定义 [公式]。这里的“指数n”的意义是”对n个相同元素连续做操作o”–而并非是a的n次方！例如，如果n&#x3D;3，意思是aoaoa &#x3D; I；<br>A.7.2 如果存在一个特定的元素g，对这个特定元素进行1~n-1次操作，我们将可以得到这个群G里面所有其它的元素，那么这个特定的元素g叫做这个群的生成元。此时这个群是个循环群。</p>
<h3 id="整数环"><a href="#整数环" class="headerlink" title="整数环"></a>整数环</h3><p>整数环是定义这么个集合Zp&#x3D; {1,2,3, p-1} 包括p个整数，在这个集合里面满足如下条件：</p>
<p>B.1 定义操作+，使得任意两个元素 a+b &#x3D; c (mod p), c 仍然在集合Zp当中。<br>B.2 定义操作x，使得任意两个元素 axb &#x3D; d (mod p), d 仍然在集合Zp当中；<br>B.3 特别地，如果p是个素数，那么，Zp内部所有元素均与p互质</p>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>其实是一个算数加法群和一个算数乘法群的“杂交”，它是这么个元素的集合F：</p>
<p>C.1 F中所有的元素形成一个加法群，这里的加法确实是算数加法 +；该加法群的中性元是自然数0–换句话说，0必然在F当中；<br>C.2 F如果把0剔除的话，剩余的元素形成一个乘法群，这里的乘法确实是算数乘法 *；该乘法群的中性元是自然数1–换句话说，1必然在F当中；<br>C.3 集合内满足分配率，即使用上述加法和乘法操作针对集合内任意元素做如下计算都成立：a x( b+c) &#x3D; axb + axc</p>
<p>概念这个东西有点儿绕，而且特征有点儿多，稍微看看了解一下。</p>
<h2 id="曲线参数"><a href="#曲线参数" class="headerlink" title="曲线参数"></a>曲线参数</h2><p>先看一个secp256k1的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">secp256k1 parameters</span></span><br><span class="line">a  = 0</span><br><span class="line">b  = 7</span><br><span class="line">n  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span><br><span class="line"></span><br><span class="line">Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</span><br><span class="line">Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8</span><br><span class="line">p  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Quick verify <span class="keyword">if</span>(Gx, Gy) is on secp256k1 curve:</span></span><br><span class="line">Gy**2 % p == (Gx**3 + Gx*a + b) % p</span><br></pre></td></tr></table></figure>

<p>a, b就是方程里的常数，可以唯一确定一条曲线。n表示点的阶，也可以理解为点的个数吧。Gx, Gy分别为一个点的坐标，这个点称为基点。secp256k1的参数（a, b, n)包含有n个点。基点(Gx, Gy)是一个生成元，就是对其作任意的加操作结果都是I(无穷点、中性元点)。</p>
<p>P是一个大素数。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>ECC曲线算法的操作有点加和点乘。点乘等于多个点加操作，可以类比算术的加和乘。这里的点加操作是这样的，两个点确定一条直线，然后找到这条直线和曲线的交点R，再得到这个点对于X轴对称的点R’。</p>
<p><img src="/images/202207/getR.png" alt="getR"></p>
<p>下面是点加的python代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Point_Add_General</span> (<span class="variable language_">self</span>, P: ECP, Q: ECP):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;calculate R = P + Q, for whatever P and Q (acceptable for P==Q) &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> Q.is_Unit_Point():</span><br><span class="line">            <span class="keyword">return</span> P</span><br><span class="line">        <span class="keyword">if</span> P.is_Unit_Point():</span><br><span class="line">            <span class="keyword">return</span> Q</span><br><span class="line">        <span class="keyword">if</span> Q.is_reverse(P, <span class="variable language_">self</span>.p_):</span><br><span class="line">            <span class="keyword">return</span> Unit</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> P == Q:</span><br><span class="line">        <span class="comment"># slope m for Dbl</span></span><br><span class="line">            m = ( <span class="number">3</span> * P.x_**<span class="number">2</span>  ) % <span class="variable language_">self</span>.p_</span><br><span class="line">            m = ( m + <span class="variable language_">self</span>.a_  ) % <span class="variable language_">self</span>.p_</span><br><span class="line">            div = modular_inverse(<span class="number">2</span>*P.y_, <span class="variable language_">self</span>.p_)</span><br><span class="line">            m = m*div % <span class="variable language_">self</span>.p_</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            m = ( P.y_ - Q.y_  ) % <span class="variable language_">self</span>.p_</span><br><span class="line">            </span><br><span class="line">            t2 = (P.x_ - Q.x_) % <span class="variable language_">self</span>.p_</span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">0</span>:</span><br><span class="line">                div = modular_inverse(t2+<span class="variable language_">self</span>.p_, <span class="variable language_">self</span>.p_)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                div = modular_inverse(t2, <span class="variable language_">self</span>.p_)</span><br><span class="line">            m = m*div % <span class="variable language_">self</span>.p_</span><br><span class="line"></span><br><span class="line">        <span class="comment"># common for Output point:</span></span><br><span class="line">        xo = ( m**<span class="number">2</span> - P.x_ - Q.x_  ) % <span class="variable language_">self</span>.p_</span><br><span class="line">        <span class="keyword">if</span> xo &lt; <span class="number">0</span>:</span><br><span class="line">            xo += <span class="variable language_">self</span>.p_</span><br><span class="line">        yo = (P.y_ + m*(xo - P.x_) ) % <span class="variable language_">self</span>.p_</span><br><span class="line">        <span class="keyword">if</span> yo &lt; <span class="number">0</span>:</span><br><span class="line">            yo += <span class="variable language_">self</span>.p_</span><br><span class="line"></span><br><span class="line">        Point_Out = (xo, yo)</span><br><span class="line">        T = ECP( Point_Out )</span><br><span class="line">        R = T.neg_point(<span class="variable language_">self</span>.p_)</span><br><span class="line">        <span class="keyword">return</span> R</span><br></pre></td></tr></table></figure>

<p>点乘就是进行k次点加,：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Point_Mult</span>(<span class="params">self, k, Pin: ECP</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; Point multiply by scalar k&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> k &lt; <span class="number">0</span> , <span class="string">&quot;Provided k &lt; 0 !&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="variable language_">self</span>.ECP_on_curve(Pin) , <span class="string">&quot;Provided Pin is not on curve!&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k % <span class="variable language_">self</span>.n_) == <span class="number">0</span> <span class="keyword">or</span> Pin.is_Unit_Point():</span><br><span class="line">            <span class="keyword">return</span> Unit</span><br><span class="line"></span><br><span class="line">        i = k</span><br><span class="line">        R = Unit</span><br><span class="line">        P = Pin</span><br><span class="line">        <span class="keyword">while</span> i:</span><br><span class="line">            <span class="keyword">if</span> i &amp; <span class="number">0x1</span>: <span class="comment"># when i[bit0] == 1</span></span><br><span class="line">                R = <span class="variable language_">self</span>.Point_Add_General(P, R)</span><br><span class="line"></span><br><span class="line">            P = <span class="variable language_">self</span>.Point_Add_General(P, P)</span><br><span class="line">            i &gt;&gt;= <span class="number">1</span>       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R</span><br></pre></td></tr></table></figure>

<p>k是一个长度固定的数，比如对应的secp256k1曲线对应256bit长度的k。这里k可以当做是私钥， 而求得的点R就是公钥。</p>
<p>从上面可以理出，ECC的参数包含： a, b, p, n， G点坐标。椭圆曲线求值 R&#x3D;kG， 已知k， G很容易求得R，但是，已知R，G却不容易求得k，椭圆曲线的原理就是基于此。 k是密钥， R就是公钥。</p>
<h2 id="加解密步骤"><a href="#加解密步骤" class="headerlink" title="加解密步骤"></a>加解密步骤</h2><p>椭圆曲线进行加密通信的过程：</p>
<p>1、用户A选定一条椭圆曲线Ep(a,b)，并取椭圆曲线上一点，作为基点G。<br>2、用户A选择一个私有密钥k，并生成公开密钥K&#x3D;kG。<br>3、用户A将Ep(a,b)和点K，G传给用户B。<br>4、用户B接到信息后 ，将待传输的明文编码到Ep(a,b)上一点M（编码方法很多，这里不作讨论），并产生一个随机整数r（r<br>5、用户B计算点C 1&#x3D;M+rK；C 2&#x3D;rG。<br>6、用户B将C 1、C 2传给用户A。<br>7、用户A接到信息后，计算C 1-kC 2，结果就是点M。因为<br>C 1-kC 2&#x3D;M+rK-k(rG)&#x3D;M+rK-r(kG)&#x3D;M<br>再对点M进行解码就可以得到明文， 这里k是私钥只有用户A知道。</p>
<p>密码学中，描述一条Fp上的椭圆曲线，常用到六个参量：<br>T&#x3D;(p,a,b,G,n,h)。<br>（p 、a 、b 用来确定一条椭圆曲线，G为基点，n为点G的阶，h 是椭圆曲线上所有点的个数m与n相除的整数部分）,这几个参量满足如下要求：</p>
<p>1、p 当然越大越安全，但越大，计算速度会变慢，200位左右可以满足一般安全要求；<br>2、p≠n×h；<br>3、pt≠1 (mod n)，1≤t&lt;20；<br>4、4a3+27b2≠0 (mod p)；<br>5、n 为素数；<br>6、h≤4。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>椭圆曲线又是一种数学的应用，看了许多篇文章，有了初步的理解。 下面是我看到的总结的比较好的文章链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/453717195">https://zhuanlan.zhihu.com/p/453717195</a></p>
<p><a href="https://blog.csdn.net/sahusoft/article/details/6868016">https://blog.csdn.net/sahusoft/article/details/6868016</a></p>
<p>后面再看一看椭圆曲线在内核中的应用。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(31)-ECC曲线的应用</title>
    <url>/2022/07/24/2022-20220724-ecdh/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ECC椭圆曲线的应用有两种： </p>
<ul>
<li>ECDSA 数字签名验签， 主要是使用私钥对信息的摘要加密，然后发送刚给对端，对端使用发送方的公钥解密得到摘要信息，再计算一下信息的摘要，对比一下确认摘要是否一致。主要用于确认这个信息是发送方发送的，没有被篡改过。</li>
<li>ECDH 密钥交换，主要用于协商通信双方使用的对称密钥。</li>
</ul>
<span id="more"></span>

<h2 id="ECDH"><a href="#ECDH" class="headerlink" title="ECDH"></a>ECDH</h2><p>DH密钥协商具体的流程下面如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A: g,p 协商生成公开的整数g,大素数p。明文形式发给B</span><br><span class="line">B: B获取到g,p</span><br><span class="line">A: 生成隐私数据: a (a&lt;p),计算得出 g^a%p,发送给B</span><br><span class="line">B: 生成隐私数据: b (b&lt;p),计算得出 g^b%p,发送给A</span><br><span class="line">A: 计算得出 [(g^ b%p)^a]%p = g ^ab%p,生成秘钥</span><br><span class="line">B:计算得出 [(g^ a%p)^b]%p = g ^ab%p,生成秘钥</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通信双方根据公开的g, p和各自私有的数各计算出一个值，然后发送给对端。再根据这个值和对端的数据，生成相同的数作为后续通信的共同的密钥。</p>
<p>ECDH密钥协商算法是ECC算法和DH密钥交换原理结合使用，用于密钥磋商。</p>
<p>ECC是建立在基于椭圆曲线的离散对数问题上的密码体制，给定椭圆曲线上的一个点P，一个整数k，求解Q&#x3D;kP很容易；给定一个点P、Q，知道Q&#x3D;kP，求整数k则是一个难题。</p>
<p>在密钥协商的阶段，通信时分别使用对端的公钥加密信息，然后双方都对接收到的信息使用自己的私钥解密，从而保证通信的安全。</p>
<h2 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h2><p>签名就比较简单了，就是发送方使用自身的私钥签名，接收方使用发送方的公钥解密摘要，对比签名。</p>
<p>ECC签名生成算法的输入输出如下：</p>
<p><img src="/images/202207/ecc_sign.png" alt="ecc_sign"></p>
<p>最后输出是一对整数(R, S)。</p>
<p>验签的话，输入输出是消息，还有签名(R, S)和公钥。</p>
<p><img src="/images/202207/ecc_ver.png" alt="ecc_ver"></p>
<p>也是算出摘要，然后结合S计算出参数、导入参数的G点和公钥，计算出一个新的点，最终对比点的X坐标是否等于R来决定验签是否通过。</p>
<p>具体的计算过程可以看NIST.FIPS.186-5-draft.pdf的第6章。</p>
<h2 id="内核中的应用"><a href="#内核中的应用" class="headerlink" title="内核中的应用"></a>内核中的应用</h2><p>EDCH在内核中用的是crypto_kpp这种算法，比如secp192r1曲线的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// crypto/ecdh.c中  linux 5.17版本</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kpp_alg</span> <span class="title">ecdh_nist_p192</span> =</span> &#123;</span><br><span class="line">	.set_secret = ecdh_set_secret,</span><br><span class="line">	.generate_public_key = ecdh_compute_value,</span><br><span class="line">	.compute_shared_secret = ecdh_compute_value,</span><br><span class="line">	.max_size = ecdh_max_size,</span><br><span class="line">	.init = ecdh_nist_p192_init_tfm,</span><br><span class="line">	.base = &#123;</span><br><span class="line">		.cra_name = <span class="string">&quot;ecdh-nist-p192&quot;</span>,</span><br><span class="line">		.cra_driver_name = <span class="string">&quot;ecdh-nist-p192-generic&quot;</span>,</span><br><span class="line">		.cra_priority = <span class="number">100</span>,</span><br><span class="line">		.cra_module = THIS_MODULE,</span><br><span class="line">		.cra_ctxsize = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ecdh_ctx),</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到内核中实现的ecdh的设置私钥、导出公钥、密钥交换的接口。</p>
<p>ECDSA在内核中用的是akcipher_alg算法，比如secp384r1曲线对应的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">akcipher_alg</span> <span class="title">ecdsa_nist_p384</span> =</span> &#123;</span><br><span class="line">	.verify = ecdsa_verify,</span><br><span class="line">	.set_pub_key = ecdsa_set_pub_key,</span><br><span class="line">	.max_size = ecdsa_max_size,</span><br><span class="line">	.init = ecdsa_nist_p384_init_tfm,</span><br><span class="line">	.<span class="built_in">exit</span> = ecdsa_exit_tfm,</span><br><span class="line">	.base = &#123;</span><br><span class="line">		.cra_name = <span class="string">&quot;ecdsa-nist-p384&quot;</span>,</span><br><span class="line">		.cra_driver_name = <span class="string">&quot;ecdsa-nist-p384-generic&quot;</span>,</span><br><span class="line">		.cra_priority = <span class="number">100</span>,</span><br><span class="line">		.cra_module = THIS_MODULE,</span><br><span class="line">		.cra_ctxsize = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ecc_ctx),</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ECDSA实现了公钥设置和验签的接口。其实，akcipher_alg接口中也有签名、加解密，不过在内核中没有实现这些接口。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这周写完了ECC曲线的代码，调试过程中还存在一些问题，下周重点就是解决这些个问题。<br>限制于硬件资源，工作进展还是很慢的，一个是多人共用资源，另外一个是环境时钟频率很低，运行缓慢。第三个就是底层支持不给力，硬件手册很多注意点没有提及，协调比较困难。第四就是驱动这玩意我也是刚开始玩，入门而已，缺乏深入。</p>
<p>本来打算周末的时候要呆在家中鲁一把代码的，被家里一些事情耽搁了，这两天做了专职的司机，开车开得手臂都感觉有点儿酸了。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(32)- 近期遇到的那些事儿</title>
    <url>/2022/08/05/2022-20220805-weekly-lately/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有些忙吧，在做一些开发调试的工作，也就遇到了一些问题和知识盲区，稍微回顾一下，也跟大家分享一下。</p>
<span id="more"></span>

<h1 id="知识盲区"><a href="#知识盲区" class="headerlink" title="知识盲区"></a>知识盲区</h1><h2 id="ECC曲线算法"><a href="#ECC曲线算法" class="headerlink" title="ECC曲线算法"></a>ECC曲线算法</h2><p>ECC曲线算法是数学知识的一个实际应用，在前面有出了两篇文章讲了一下大体的原理，更详细的需要看一下标准文档和网络上大神的详细的总结。在编码的过程中，同时也简单地了解了一下ASN1的编码格式。ECC曲线的应用主要是密钥导出、密钥交换、签名和验签。</p>
<h2 id="流密码算法"><a href="#流密码算法" class="headerlink" title="流密码算法"></a>流密码算法</h2><p>了解了祖冲之算法和snow3G算法的大概实现流程，在前面也分别有文章简单地聊了一下这两种算法。</p>
<p>在实现算法的过程中，又涉及到一个端序的概念。就是大小端数据的组织。在以往的工作中，默认网络包的格式是大端的，正常主机是小端的。然后，过去在开发的过程中，对于字节流而言，是不区分什么大小端的，大小端都是针对那些整型字段而言的，转换端序的时候也只是对那些整形字段作转换。开发驱动却不是这样的，它这个端序是针对所有数据的， 也就是大端顺序是0 - N, 转为小端顺序就是 N - 0， 这样子。</p>
<h2 id="内核模块代码添加宏"><a href="#内核模块代码添加宏" class="headerlink" title="内核模块代码添加宏"></a>内核模块代码添加宏</h2><p>看到同事写的代码里面，需要主动通过添加 #define AAAA， 上网查了一下， 只需要在Makefile里面添加选项就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">EXTRA_CFLAGS += -DAAAA</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般的Makefile可以直接在make之后添加-DAAA， 内核需要手动加到EXTRA_CFLAGS中去。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="dma映射方向搞错，获取不到数据"><a href="#dma映射方向搞错，获取不到数据" class="headerlink" title="dma映射方向搞错，获取不到数据"></a>dma映射方向搞错，获取不到数据</h2><p>刚开始驱动调试的时候，不了解dma的接口，然后死活获取不到硬件给的数据，原来是在映射的时候，方向没有设置成双向的。</p>
<h2 id="无符号差值保存到有符号变量中，实际还是一个无符号的数"><a href="#无符号差值保存到有符号变量中，实际还是一个无符号的数" class="headerlink" title="无符号差值保存到有符号变量中，实际还是一个无符号的数"></a>无符号差值保存到有符号变量中，实际还是一个无符号的数</h2><p>这是昨天调试的时候发现的一个问题:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u32 a = <span class="number">47</span>;</span><br><span class="line">u32 b = <span class="number">48</span>;</span><br><span class="line"><span class="type">ssize_t</span> diff = a - b; <span class="comment">// diff = -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//... </span></span><br><span class="line"><span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do sth.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do other sth.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果走了do sth.分支。。。</span></span><br><span class="line"><span class="comment">// 最后只能改成这样   ssize_t diff = (int)a - (int)b;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="虚拟机升级了内核版本后，共享文件夹不可用了"><a href="#虚拟机升级了内核版本后，共享文件夹不可用了" class="headerlink" title="虚拟机升级了内核版本后，共享文件夹不可用了"></a>虚拟机升级了内核版本后，共享文件夹不可用了</h2><p>最近升级了一下虚拟机的内核版本，添加了对tcrypt和一些算法的支持。但是，重启之后，发现原来设置的共享文件夹不能用了，进入目录后一片空白。</p>
<p>上网查了一下，重新设置一下共享文件夹。执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd /mnt</span><br><span class="line">mkdir SF_SHARE</span><br><span class="line"></span><br><span class="line">mount -t vboxsf VM_SHARE /mnt/SF_SHARE </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/sbin/mount.vboxsf: mounting failed with the error: No such device</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是由于增强工具没有安装， 继续下面的命令：</span></span><br><span class="line"></span><br><span class="line">cd /opt/VBoxGuestAdditions-*/init  </span><br><span class="line">./vboxadd setup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装好之后， 继续执行， 就可以了。</span></span><br><span class="line"></span><br><span class="line">mount -t vboxsf VM_SHARE /mnt/SF_SHARE   # VM_SHARE是设置的共享文件夹名称</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="作dma映射后，程序卡死"><a href="#作dma映射后，程序卡死" class="headerlink" title="作dma映射后，程序卡死"></a>作dma映射后，程序卡死</h2><p>这个是由于作dma映射的空间不是cache对齐的， 导致cache刷新不同步，内容改变导致非法，再去访问就出问题了。所以说，后面要做dma映射的空间，要确保它的其实地址是cacheline对齐的，这样刷新的时候都是同步刷新的，不会跟其他数据混在一起。</p>
<h2 id="使用局部变量作dma映射，程序卡死"><a href="#使用局部变量作dma映射，程序卡死" class="headerlink" title="使用局部变量作dma映射，程序卡死"></a>使用局部变量作dma映射，程序卡死</h2><p>执行dma映射的空间不能是全局变量和局部变量。</p>
<h2 id="多个内核版本，修改默认启动版本"><a href="#多个内核版本，修改默认启动版本" class="headerlink" title="多个内核版本，修改默认启动版本"></a>多个内核版本，修改默认启动版本</h2><p>由于历史问题，在一台机器上更新了内核版本之后，默认启动的内核还是旧的版本，导致每次需要启动时，选择启动内核版本，有点麻烦。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改</span> </span><br><span class="line">vi /etc/default/grub</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置， 如果设置有问题 注意看后面update-grub的命令提示</span></span><br><span class="line">GRUB_DEFAULT=&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.15.0&quot;</span><br><span class="line"></span><br><span class="line">update-grub</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启后就更新了</span></span><br></pre></td></tr></table></figure>


<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>编写内核经常导致那个系统挂掉，原来可以在系统主板上也有串口的，可以插个串口线看那个堆栈的，请原谅我现在才知道，哈哈。</p>
<p>生活可以忙忙碌碌随大流，思想必须偷偷摸摸求上进。</p>
<p>最近吃了湾湾的那个瓜， 祖国加油！</p>
<p>周末要去接娃来了，神兽又要来捣蛋了，^_^!</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(33)-字符设备驱动</title>
    <url>/2022/08/14/2022-20220814-driver-char/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继续驱动学习小结。字符设备驱动是驱动架构的基础。</p>
<span id="more"></span>

<h2 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><p>字符设备的关键数据结构有cdev、file_operations</p>
<p>cdev描述了一个字符设备的信息。file_operations描述了驱动提供给虚拟文件系统的接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">/* 文件操作*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">dev_t</span> dev; <span class="comment">// 设备号  12位主设备号 + 20位次设备号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count; </span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> flags);</span><br><span class="line">	<span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">	<span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">	<span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">	<span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">			  <span class="type">loff_t</span> len);</span><br><span class="line">	<span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line">			<span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">				   <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">				   <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line">	<span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">const</span> <span class="keyword">struct</span> file_operations *)</span>;</span><br><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_put</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内核提供了对cdev进行操作的接口，主要功能如下：</p>
<ul>
<li>cdev_init  关联cdev和file_operations结构</li>
<li>cdev_alloc 申请一个cdev结构空间</li>
<li>cdev_add, cdev_del 往系统添加&#x2F;删除一个cdev描述的字符设备， 一般分别在驱动probe, remove中调用。</li>
<li>cdev_put  字符模块驱动的解引用， 引用一般在访问接口内部实现。</li>
</ul>
<h3 id="设备号的申请释放"><a href="#设备号的申请释放" class="headerlink" title="设备号的申请释放"></a>设备号的申请释放</h3><p>在调用cdev_add 前，需要调用register_chrdev_region或者alloc_chrdev_region向系统申请设备号。register_chrdev_region是已知主设备号时调用， alloc_chrdev_region则是不提供主设备号，由系统自动分配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * register_chrdev_region() - register a range of device numbers</span></span><br><span class="line"><span class="comment"> * @from: the first in the desired range of device numbers; must include</span></span><br><span class="line"><span class="comment"> *        the major number.</span></span><br><span class="line"><span class="comment"> * @count: the number of consecutive device numbers required</span></span><br><span class="line"><span class="comment"> * @name: the name of the device or driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return value is zero on success, a negative error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_chrdev_region() - register a range of char device numbers</span></span><br><span class="line"><span class="comment"> * @dev: output parameter for first assigned number</span></span><br><span class="line"><span class="comment"> * @baseminor: first of the requested range of minor numbers</span></span><br><span class="line"><span class="comment"> * @count: the number of minor numbers required</span></span><br><span class="line"><span class="comment"> * @name: the name of the associated device or driver</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocates a range of char device numbers.  The major number will be</span></span><br><span class="line"><span class="comment"> * chosen dynamically, and returned (along with the first minor number)</span></span><br><span class="line"><span class="comment"> * in @dev.  Returns zero or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件操作提供几个接口，主要实现如下的功能：</p>
<ul>
<li>llseek 设置文件当前位置</li>
<li>read 读取文件数据</li>
<li>write 写入文件数据</li>
<li>unlocked_ioctl 非读写操作，对应fcntl, ioctl等的接口</li>
<li>mmap 将设备内存映射到进程空间</li>
<li>open 打开文件</li>
<li>poll 询问设备是否可以被非阻塞的读写</li>
<li>aio_read, aio_write 异步读写操作</li>
</ul>
<p>读写文件传入的地址都是用户空间的地址，用户空间不能直接访问内核的内存，需要通过copy_from_user, copy_to_user函数来实现数据的复制。在这两个函数中，会判断传入的地址是否是用户空间，防止随意改写了内核空间导致出现不可预料的错误。</p>
<p><img src="/images/202208/cdev_arch.png" alt="cdev_arch"></p>
<p>在具体的实现中，在open接口中会把设备对应的cdev指针设置到file文件对应的私有数据private_data成员上，这样在其他接口中，可以很方便的从file指针获取到对应的cdev空间，从而访问相应的空间。</p>
<h3 id="用户空间调用"><a href="#用户空间调用" class="headerlink" title="用户空间调用"></a>用户空间调用</h3><p>加载驱动模块后，对应的&#x2F;proce&#x2F;devices就可以看到对应的设备。这个时候需要手动在&#x2F;dev目录下，使用mknod创建一个文件跟设备关联起来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mknod /dev/globalmem c 230 0  # 创建字符设备文件 对应主设备号230， 次设备号 0</span><br></pre></td></tr></table></figure>

<p>然后使用echo xxx &gt; <file> 或者 cat <file> 就会调用到对应的write和read函数了。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>字符设备主要就是一个cdev和file_operation结构。通过申请好设备号，然后注册到系统，手动创建文件关联设备，然后就可以在用户空间访问到驱动接口了。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>这周项目组来了几个应届的新人，安排每个老同事带一个新人，结成个师徒关系吧，还宣布带新人也要占工作的40%绩效。说实话，项目组里的基本都是新人，除了两个呆了有一年以上的，其他的老同事也基本上是今年社招入职的，大部分都是跨领域的，有的也只是工作经验吧，也都是在学习的阶段。</p>
<p>嗯，这算是我第二次带新人了，上一次是好多年前了。参照某为的新人试用期机制，以及这几个月我工作的心得，给安排了一些学习要点和minitask，先让他自己看了一周，动手学习并完成给定的任务，并及时输出总结文档。</p>
<p>现在发现的一个最主要问题就是缺少主动沟通，很少提问，需要我这边主动找他才有反馈。要求每天反馈的日报，也没有严格执行，要求整理总结文档也没有。本来担心他日报没啥写的，就让他晚上九点前给日报的，这周五的日报就没发了，相应的进度也有些慢，看来还是压力没有给到位，没有紧迫感，执行力不强。</p>
<p>也许我对新人的期望高了一些，需要转变一下策略，得主动先给他讲一下再安排任务，直接给任务的话，他也不及时沟通确认任务，问一下都是明白了，做起来却不是一回事。</p>
<p>00后都出来工作了，我们这些老骨头也要加强学习了，各方面都得加强。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>驱动</category>
      </categories>
  </entry>
  <entry>
    <title>设备驱动的阻塞和非阻塞IO， 轮询编程</title>
    <url>/2022/08/14/2022-20220814-driver-io/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux IO中有阻塞和非阻塞之分。阻塞就是在执行操作的过程中，如果不能获得资源则挂起进程，直到满足可操作的条件后再进行操作。非阻塞则不会挂起，直接返回结果，然后可以不停的来查询直到可以进行操作，也可以放弃操作。</p>
<span id="more"></span>
<h2 id="驱动的阻塞和非阻塞IO"><a href="#驱动的阻塞和非阻塞IO" class="headerlink" title="驱动的阻塞和非阻塞IO"></a>驱动的阻塞和非阻塞IO</h2><p>驱动实现的read和write操作，可以支持阻塞和非阻塞的操作。需要在read和write接口实现代码中，根据文件的flag实现不同的流程。阻塞的话，进程会挂起，调用schedule让出cpu，直到中断返回才继续执行。非阻塞就直接返回。</p>
<p><img src="/images/202208/driver_io.png" alt="driver_io"></p>
<p>是否阻塞，需要在打开文件的时候，传入对应的标记O_NONBLOCK。也可以通过ioctl, fcntl改变属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/path/to/file&quot;</span>, O_RDWR | O_NON_BLOCK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fcntl(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ioctl(m_sock, FIONBIO , &amp;has);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="阻塞实现"><a href="#阻塞实现" class="headerlink" title="阻塞实现"></a>阻塞实现</h2><p>阻塞实现是基于等待队列来实现的， 等待队列是linux的一个机制。在函数实现时，创建一个等待队列元素，保存当前任务的task结构，然后添加等待队列到等待队列头中。然后在需要阻塞的时候，调用schedule让出CPU。在满足条件的地方调用wake_up函数来调度之前阻塞的任务。</p>
<p>下面分析一下read的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalfifo_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">			       <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">globalfifo_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data; <span class="comment">// 获取驱动设备信息</span></span><br><span class="line">	DECLARE_WAITQUEUE(wait, current);  <span class="comment">// 创建一个等待队列，保存current task</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">	add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait); <span class="comment">// 添加到等待队列头r_wait中</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (dev-&gt;current_len == <span class="number">0</span>) &#123; <span class="comment">// 只有当没有数据时 需要阻塞住</span></span><br><span class="line">		<span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123; <span class="comment">// 非阻塞直接返回</span></span><br><span class="line">			ret = -EAGAIN;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">		mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">		schedule();  <span class="comment">// 让出CPU</span></span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123; <span class="comment">// 被信号中断  直接返回</span></span><br><span class="line">			ret = -ERESTARTSYS;</span><br><span class="line">			<span class="keyword">goto</span> out2;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &gt; dev-&gt;current_len)</span><br><span class="line">		count = dev-&gt;current_len; <span class="comment">//最多只读当前的长度</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(buf, dev-&gt;mem, count)) &#123; <span class="comment">// 读数据</span></span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(dev-&gt;mem, dev-&gt;mem + count, dev-&gt;current_len - count);</span><br><span class="line">		dev-&gt;current_len -= count;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;read %d bytes(s),current_len:%d\n&quot;</span>, count,</span><br><span class="line">		       dev-&gt;current_len);</span><br><span class="line"></span><br><span class="line">		wake_up_interruptible(&amp;dev-&gt;w_wait); <span class="comment">// 通知潜在的可能的写阻塞任务</span></span><br><span class="line"></span><br><span class="line">		ret = count;</span><br><span class="line">	&#125;</span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"> out2:</span><br><span class="line">	remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);</span><br><span class="line">	set_current_state(TASK_RUNNING);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="轮询编程"><a href="#轮询编程" class="headerlink" title="轮询编程"></a>轮询编程</h2><p>非阻塞的IO可以通过select、poll等接口查询当前文件是否可进行读写操作。实际系统调用的是驱动的poll函数。poll函数的工作主要是调用poll_wait将等待队列添加到poll_table中，并返回对应的掩码标识。这样将触发select或者poll的进一步执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">globalfifo_poll</span><span class="params">(<span class="keyword">struct</span> file *filp, poll_table * wait)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">globalfifo_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	poll_wait(filp, &amp;dev-&gt;r_wait, wait);</span><br><span class="line">	poll_wait(filp, &amp;dev-&gt;w_wait, wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;current_len != <span class="number">0</span>) &#123;</span><br><span class="line">		mask |= POLLIN | POLLRDNORM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;current_len != GLOBALFIFO_SIZE) &#123;</span><br><span class="line">		mask |= POLLOUT | POLLWRNORM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">	<span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在用户空间就可以写对应的poll函数监听文件了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_CLEAR 0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_LEN 20</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd, num;</span><br><span class="line">	<span class="type">char</span> rd_ch[BUFFER_LEN];</span><br><span class="line">	fd_set rfds, wfds;	<span class="comment">/* 读/写文件描述符集 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 以非阻塞方式打开/dev/globalfifo设备文件 */</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/globalfifo&quot;</span>, O_RDONLY | O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="comment">/* FIFO清0 */</span></span><br><span class="line">		<span class="keyword">if</span> (ioctl(fd, FIFO_CLEAR, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ioctl command failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			FD_ZERO(&amp;rfds);</span><br><span class="line">			FD_ZERO(&amp;wfds);</span><br><span class="line">			FD_SET(fd, &amp;rfds);</span><br><span class="line">			FD_SET(fd, &amp;wfds);</span><br><span class="line"></span><br><span class="line">			select(fd + <span class="number">1</span>, &amp;rfds, &amp;wfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="comment">/* 数据可获得 */</span></span><br><span class="line">			<span class="keyword">if</span> (FD_ISSET(fd, &amp;rfds)) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Poll monitor:can be read\n&quot;</span>);</span><br><span class="line">                <span class="type">int</span> len = read(fd, rd_ch, BUFFER_LEN);</span><br><span class="line">                rd_ch[len<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read data %s\r\n&quot;</span>, rd_ch);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">/* 数据可写入 */</span></span><br><span class="line">			<span class="keyword">if</span> (FD_ISSET(fd, &amp;wfds))</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Poll monitor:can be written\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Device open failure\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>了解了驱动阻塞和非阻塞IO的实现，以及处理用户空间select&#x2F;poll&#x2F;epoll的并发IO处理的poll函数实现。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>驱动</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(34)-DMA地址映射api使用</title>
    <url>/2022/08/27/2022-20220827-dma-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做驱动开发免不了要用到DMA技术， 这是一种高速的数据传输操作，允许外设直接读写存储器，不需要CPU的介入。这样CPU就可以继续做其它的事情了。控制这个操作的是DMA控制器。</p>
<h2 id="CPU地址和DMA地址"><a href="#CPU地址和DMA地址" class="headerlink" title="CPU地址和DMA地址"></a>CPU地址和DMA地址</h2><p>系统内核使用的是虚拟地址，任何从kmalloc, valloc返回的地址都是虚拟地址，可以使用void *变量存储。虚拟地址可以通过内存管理系统(MMU)转换为CPU的物理地址。内核管理的设备资源一般都是物理地址，比如设备的寄存器地址之类的，这些地址的范围都存在于<code>/proc/iomem</code>文件中。物理地址是不能直接使用的，需要通过ioremap映射得到一个虚拟地址,然后代码才可以访问。</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:~# cat /proc/iomem</span><br><span class="line">00000000-00000fff : Reserved</span><br><span class="line">00001000-0009fbff : System RAM</span><br><span class="line">0009fc00-0009ffff : Reserved</span><br><span class="line">000a0000-000bffff : PCI Bus 0000:00</span><br><span class="line">000c0000-000c7fff : Video ROM</span><br><span class="line">000e2000-000e2fff : Adapter ROM</span><br><span class="line">000f0000-000fffff : Reserved</span><br><span class="line">  000f0000-000fffff : System ROM</span><br><span class="line">00100000-dffeffff : System RAM</span><br><span class="line">  a7000000-a80020df : Kernel code</span><br><span class="line">  a8200000-a8ca6fff : Kernel rodata</span><br><span class="line">  a8e00000-a918af7f : Kernel data</span><br><span class="line">  a945e000-a99fffff : Kernel bss</span><br><span class="line">dfff0000-dfffffff : ACPI Tables</span><br><span class="line">e0000000-fdffffff : PCI Bus 0000:00</span><br><span class="line">  e0000000-e0ffffff : 0000:00:02.0</span><br><span class="line">    e0000000-e0ffffff : vmwgfx probe</span><br><span class="line">  f0000000-f01fffff : 0000:00:02.0</span><br><span class="line">    f0000000-f01fffff : vmwgfx probe</span><br><span class="line">  f0200000-f021ffff : 0000:00:03.0</span><br><span class="line">    f0200000-f021ffff : e1000</span><br><span class="line">  f0400000-f07fffff : 0000:00:04.0</span><br><span class="line">    f0400000-f07fffff : vboxguest</span><br><span class="line">  f0800000-f0803fff : 0000:00:04.0</span><br><span class="line">  f0804000-f0804fff : 0000:00:06.0</span><br><span class="line">    f0804000-f0804fff : ohci_hcd</span><br><span class="line">  f0806000-f0807fff : 0000:00:0d.0</span><br><span class="line">    f0806000-f0807fff : ahci</span><br><span class="line">fec00000-fec00fff : Reserved</span><br><span class="line">  fec00000-fec003ff : IOAPIC 0</span><br><span class="line">fee00000-fee00fff : Local APIC</span><br><span class="line">  fee00000-fee00fff : Reserved</span><br><span class="line">fffc0000-ffffffff : Reserved</span><br><span class="line">100000000-21fffffff : System RAM</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IO设备还会用到一个概念：总线地址。设备使用总线地址读写系统的内存。有些系统总线地址等同于物理地址，但是大部分系统并不是这样的，是两套不同的地址描述。IOMMU可以管理物理地址和总线地址的映射关系。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">             CPU                  CPU                  Bus</span><br><span class="line">           Virtual              Physical             Address</span><br><span class="line">           Address              Address               Space</span><br><span class="line">            Space                Space</span><br><span class="line"></span><br><span class="line">          +-------+             +------+             +------+</span><br><span class="line">          |       |             |MMIO  |   Offset    |      |</span><br><span class="line">          |       |  Virtual    |Space |   applied   |      |</span><br><span class="line">        C +-------+ --------&gt; B +------+ ----------&gt; +------+ A</span><br><span class="line">          |       |  mapping    |      |   by host   |      |</span><br><span class="line">+-----+   |       |             |      |   bridge    |      |   +--------+</span><br><span class="line">|     |   |       |             +------+             |      |   |        |</span><br><span class="line">| CPU |   |       |             | RAM  |             |      |   | Device |</span><br><span class="line">|     |   |       |             |      |             |      |   |        |</span><br><span class="line">+-----+   +-------+             +------+             +------+   +--------+</span><br><span class="line">          |       |  Virtual    |Buffer|   Mapping   |      |</span><br><span class="line">        X +-------+ --------&gt; Y +------+ &lt;---------- +------+ Z</span><br><span class="line">          |       |  mapping    | RAM  |   by IOMMU</span><br><span class="line">          |       |             |      |</span><br><span class="line">          |       |             |      |</span><br><span class="line">          +-------+             +------+</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内核读取设备的总线地址，转换为CPU物理地址，存储在struct resource结构中，可以在<code>/proc/iomem</code>中看到。然后驱动通过<code>ioremap</code>把物理地址映射到虚拟地址，并通过专门的接口读写寄存器，如：ioread32(C)，访问设备对应的总线地址。这个有点儿绕，驱动访问虚拟地址，最终落到设备的总线地址上面。</p>
<p>使用DMA操作时，驱动通过kmalloc申请一片空间A，A对应到物理地址B上去。设备要访问物理地址B的话，需要有个IOMMU通过A转换得到一个DMA地址C对应到B上去。驱动告诉设备DMA操作的目的地址是C，IOMMU会把C映射到物理地址B上面去，最后操作的是物理地址B。驱动通过dma_map_single接口，获取到虚拟地址A对应的DMA地址C。</p>
<p>虚拟地址A， DMA地址C，对应的物理地址都是B。</p>
<h2 id="DMA限制"><a href="#DMA限制" class="headerlink" title="DMA限制"></a>DMA限制</h2><p>不是所有的内核内存地址都可以使用DMA技术的。使用__get_free_page或者kmalloc、kmem_cache_alloc返回的地址可以使用DMA，而使用vmalloc返回的地址不能使用DMA。还需要保证地址是cacheline对齐的，否则会出现一致性的问题，如果不是cacheline对齐的，CPU和DMA会打架的，CPU和DMA同时操作一片cache，会导致内容相互覆盖。</p>
<h2 id="DMA寻址能力"><a href="#DMA寻址能力" class="headerlink" title="DMA寻址能力"></a>DMA寻址能力</h2><p>内核默认支持32bit的DMA地址空间，支持64bit的设备相应的可以支持64bit，设备有限制的话也可以相应的减少位数。正确的操作是调用接口dma_set_mask_and_coherent设置DMA地址空间寻址位数。接口如果返回非0的话，则表示设备不支持设置的dma空间大小，那么后续就不要通过DMA方式操作，否则会出现不可预料的问题的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="number">64</span>))) &#123;</span><br><span class="line">	dev_warn(dev, <span class="string">&quot;mydev: No suitable DMA available\n&quot;</span>);</span><br><span class="line">	<span class="keyword">goto</span> ignore_this_device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DMA映射方式"><a href="#DMA映射方式" class="headerlink" title="DMA映射方式"></a>DMA映射方式</h2><p>DMA有两种类型的映射： 一致性DMA和流式DMA。</p>
<p>一致性DMA在驱动注册的时候就映射了，最后才解除映射。硬件会自己保证设备和CPU可以并行的访问数据，并且数据都是实时更新的，不需要开发者做额外的工作。默认一致性DMA支持的空间为32位寻址空间。如果需要，可以自行设置DMA掩码位。有一点需要注意的是，一致性DMA并不是完全按序写入数据的，如果不同地址间数据写入存在互相依赖，需要使用wmb做同步。</p>
<p>使用一致性DMA的场景有：</p>
<ul>
<li>网卡的ring描述符</li>
<li>SCSI适配的mailbox命令数据</li>
<li>设备固件的微码内存</li>
</ul>
<p>流式DMA一般在需要做DMA转换的时候才做映射，而后动态的解除映射。使用流式DMA需要明确调用接口设置想要的操作。<br>使用流式DMA的场景有：</p>
<ul>
<li>网络包buffers的接收发送</li>
<li>文件系统的读写buffers</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">dma_addr_t</span> dma_handle;</span><br><span class="line"></span><br><span class="line">cpu_addr = dma_alloc_coherent(dev, size, &amp;dma_handle, gfp);</span><br><span class="line"></span><br><span class="line">   dma_free_coherent(dev, size, cpu_addr, dma_handle);</span><br></pre></td></tr></table></figure>

<p>一致性DMA的使用代码如上，接口返回CPU可以访问的虚拟地址以及dma_handle地址(传给设备的地址)。返回的地址都是PAGE_SIZE对齐的大小的，即使你传入的size小于PAGE_SIZE也是一样的。</p>
<p>如果需要大量的小size的内存，可以自行管理使用dma_alloc_coherent分配的空间， 也可以使用dma_pool的接口来实现， dma_pool底层实际也是管理的dma_alloc_coherent分配的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dma_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">pool = dma_pool_create(name, dev, size, align, boundary); <span class="comment">// align必须是2的次方， boundary表示内存的边界，不允许一次性从pool申请超过多少大小的内存。</span></span><br><span class="line"></span><br><span class="line">   cpu_addr = dma_pool_alloc(pool, flags, &amp;dma_handle);</span><br><span class="line"></span><br><span class="line">   dma_pool_free(pool, cpu_addr, dma_handle);</span><br><span class="line"></span><br><span class="line">   dma_pool_destroy(pool); <span class="comment">// free pool之前要保证所有从pool申请的内存都free了</span></span><br></pre></td></tr></table></figure>

<h2 id="DMA方向"><a href="#DMA方向" class="headerlink" title="DMA方向"></a>DMA方向</h2><p>DMA相关接口需要填写DMA方向，表示DMA操作时的方向，目前有如下的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DMA_BIDIRECTIONAL</span><br><span class="line">DMA_TO_DEVICE</span><br><span class="line">DMA_FROM_DEVICE</span><br><span class="line">DMA_NONE</span><br></pre></td></tr></table></figure>

<p>一般只有流式DMA需要设置方向，一致性DMA默认是双向的DMA_BIDIRECTIONAL。</p>
<h2 id="流式DMA映射"><a href="#流式DMA映射" class="headerlink" title="流式DMA映射"></a>流式DMA映射</h2><p>流式DMA映射可以在中断上下文中调用，可以映射一个独立的内存区域，也可以映射一个scatterlist表示的多个内存区域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;my_dev-&gt;dev;</span><br><span class="line"><span class="type">dma_addr_t</span> dma_handle;</span><br><span class="line"><span class="type">void</span> *addr = buffer-&gt;ptr;</span><br><span class="line"><span class="type">size_t</span> size = buffer-&gt;len;</span><br><span class="line"></span><br><span class="line">dma_handle = dma_map_single(dev, addr, size, direction);</span><br><span class="line"><span class="keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * reduce current DMA mapping usage,</span></span><br><span class="line"><span class="comment">	 * delay and try again later or</span></span><br><span class="line"><span class="comment">	 * reset driver.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">goto</span> map_error_handling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dma_unmap_single(dev, dma_handle, size, direction);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// scatterlist形式</span></span><br><span class="line">   <span class="type">int</span> i, count = dma_map_sg(dev, sglist, nents, direction);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">sg</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_sg(sglist, sg, count, i) &#123;</span><br><span class="line">	hw_address[i] = sg_dma_address(sg);</span><br><span class="line">	hw_len[i] = sg_dma_len(sg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   dma_unmap_sg(dev, sglist, nents, direction);</span><br></pre></td></tr></table></figure>

<p>dma_map_single就是不能映射high memory， 可以使用dma_map_page接口替代。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;my_dev-&gt;dev;</span><br><span class="line">	<span class="type">dma_addr_t</span> dma_handle;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> buffer-&gt;page;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> offset = buffer-&gt;offset;</span><br><span class="line">	<span class="type">size_t</span> size = buffer-&gt;len;</span><br><span class="line"></span><br><span class="line">	dma_handle = dma_map_page(dev, page, offset, size, direction);</span><br><span class="line">	<span class="keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * reduce current DMA mapping usage,</span></span><br><span class="line"><span class="comment">		 * delay and try again later or</span></span><br><span class="line"><span class="comment">		 * reset driver.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">goto</span> map_error_handling;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	dma_unmap_page(dev, dma_handle, size, direction);</span><br></pre></td></tr></table></figure>

<p>在流式DMA映射取消映射之前，CPU不应该访问DMA buffer，如果需要访问，则必须在DMA传输后相应地调用如下函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dma_sync_single_for_cpu(dev, dma_handle, size, direction);</span><br><span class="line">dma_sync_sg_for_cpu(dev, sglist, nents, direction);</span><br></pre></td></tr></table></figure>
<p>CPU访问结束后，将buffer还给设备DMA使用时，需要相应调用如下函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dma_sync_single_for_device(dev, dma_handle, size, direction);</span><br><span class="line">dma_sync_sg_for_device(dev, sglist, nents, direction);</span><br></pre></td></tr></table></figure>

<p>for_cpu 和 for_device的区别在于控制权是属于cpu还是device。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li>调用dma_alloc_coherent后判断返回值是否为NULL， 调用dma_map_sg判断返回值是否为0</li>
<li>dma_map_single和dma_map_page调用后，使用dma_mapping_error判断是否失败</li>
</ul>
<p>在映射失败后，记得释放已经成功的地址区域。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>写驱动的时候遇到过DMA的问题，然后这周外部也反馈了一个问题跟DMA相关，虽然之前看了许多DMA相关的内容，但是没有总结过总觉得掌握的不够透。周末抽空看看内核中的文档关于DMA接口使用的描述(Documentation&#x2F;core-api&#x2F;dma-api-howto.rst)，边看边整理，好好系统学习一下。刚写完这个文章去看了一下前段日子写的驱动代码，发现还是有些需要改一下。温故而知新，的确如此，当然关键是花了这个时间，真真切切地学进去了，才有收获。</p>
<p>周末这两天的事情主要就是小孩上学注册，昨天搬家，今天注册。上学的地方离得比较远，只好让家里领导去学校附近租个房先陪读一年，暂时过渡一下。等明年有资格买房了先买个二手房,再转学过来。这几年也辛苦娃跟着到处奔波了，余生好好工作，好好培养爱护他们。</p>
<p>上周又落下了一期文章，坚持不易啊。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>驱动</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(35)-Makefile基础复习</title>
    <url>/2022/09/04/2022-20220904-weekly-makefile/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周使用cmake构建了一个新工程代码，目录结构参照GmSSL3.0进行了划分，新增的代码和测试代码都编译测试运行OK，也增加了相应的README说明。在我看来，初步版本已经是完整的了。使用cmake可以使得构建中间文件跟源代码分离，而且cmake还提供了安装、打包的功能，已经相当的完善了。初期的工作是完成了。</p>
<span id="more"></span>

<p>代码提交审核，呵呵，人家不知道cmake是什么东东(兴许是搞驱动搞久了，没看过太多开源代码吧)，也不愿意接纳这个新事物，要求让手写Makefile，觉得这样才更符合C项目的编写惯例。虽然cmake很方便，但是会增加组内成员的学习成本，不方便大家使用。WTF，不懂学习一下不就行了，这么多的优点不值得学一下么？好吧，再搞个Makefile版本。有一句话说的是，”你不可能总是得到你想要的, 你想要的并不是别人要的”。</p>
<p>复习复习Makefile的基础吧。</p>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>Makefile最主要的就是变量和函数了。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的赋值跟shell类似，var&#x3D;value</p>
<p>取值是$(变量名)或者${变量名}</p>
<p>Makefile还提供了一些默认的变量名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS # 编译选项 如 -g -Wall</span><br><span class="line">LDFLAGS #链接选项</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令中使用的自动变量</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">@ <span class="comment"># 表示规则的目标</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&lt; <span class="comment"># 表示规则中的第一个条件</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">^: <span class="comment"># 表示规则中的所有条件，空格分隔</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%.o:%.c</span><br><span class="line">    $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>模式规则用来说明依赖文件是如何生成目标文件的，一般就是%号加上后缀，上面的例子表示.c文件如何生成.o文件。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>最常用的函数是wildcard, 和patsubst：</p>
<ul>
<li>wildcard 用于获取以某个后缀结尾的所有函数。</li>
<li>patsubst 把指定后缀替换为新的后缀，如.c –&gt; .o</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SRC=$(wildcard *.c) <span class="comment"># 获取所有.c结尾的文件</span></span><br><span class="line">OBJS=$(patsubst %.c, %.o, $(SRC)) <span class="comment"># SRC中.c替换为.o</span></span><br><span class="line">TARGET=main</span><br><span class="line">$(TARGET):$(OBJS)</span><br><span class="line">	$(CC) $(OBJS) -o $(TARGET)</span><br><span class="line">%.o:%.c</span><br><span class="line">	$(CC) -c $&lt; -o <span class="variable">$@</span> <span class="comment"># 依赖条件第一个$&lt; 编译成目标文件 $@</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>经常使用make clean或者make all命令来清理或者编译目标，这里的clean和all一般都是伪目标，即不是实际存在的文件， 需要使用.PHONY声明。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SRC=$(wildcard *.c)</span><br><span class="line">OBJS=$(patsubst %.c,%.o,$(SRC))</span><br><span class="line">TARGET=main</span><br><span class="line"></span><br><span class="line">.PHONY: all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all: $(TARGET)</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make all&quot;</span></span><br><span class="line"></span><br><span class="line">$(TARGET):$(OBJS)</span><br><span class="line">	$(CC) $(OBJS) -o $(TARGET)</span><br><span class="line">%.o:%.c</span><br><span class="line">	$(CC) -c $&lt; -o <span class="variable">$@</span></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">	<span class="built_in">rm</span> -rf $(OBJS) $(TARGET)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Makefile嵌套"><a href="#Makefile嵌套" class="headerlink" title="Makefile嵌套"></a>Makefile嵌套</h2><p>Makefile的嵌套，一种是最外层的Makefile需要包含更深层的Makefile内容，才能编译完成。这种需要使用include关键字包含深层次的Makefile，类似于C语言的include，被include的Makefile内容会展开到对应的外层Makefile。</p>
<p>另外一种是，更深层的Makefile本身就可以独立编译，最外层的Makefile可以调用到内层的Makefile完成功能。最外层可以通过<code>make -C path/to/subdir</code>的命令调用深层次的Makefile编译。</p>
<p>更多的是第三种最外层的Makefile直接包含了所有内层目录的源文件，整个工程就一个Makefile。</p>
<p>如果需要在Makefile间传递变量， 可以使用export关键字，这样深层次的Makefile可以获取到对应的变量值。 在深层次Makefile注意使用?&#x3D;方式给对应的变量设置默认值。</p>
<p>第一种可以参考linux kernel 生成的Makefile。</p>
<p>第二种参考<code>https://gitee.com/mirrors/intel-ipsec-mb</code> 代码的Makefile：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all clean style install uninstall <span class="built_in">help</span> TAGS</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	$(MAKE) -C lib</span><br><span class="line">	$(MAKE) -C <span class="built_in">test</span></span><br><span class="line">	$(MAKE) -C perf</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	$(MAKE) -C lib clean</span><br><span class="line">	$(MAKE) -C <span class="built_in">test</span> clean</span><br><span class="line">	$(MAKE) -C perf clean</span><br><span class="line"></span><br><span class="line">style:</span><br><span class="line">	$(MAKE) -C lib style</span><br><span class="line">	$(MAKE) -C <span class="built_in">test</span> style</span><br><span class="line">	$(MAKE) -C perf style</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">	$(MAKE) -C lib install</span><br><span class="line"></span><br><span class="line">uninstall:</span><br><span class="line">	$(MAKE) -C lib uninstall</span><br><span class="line"></span><br><span class="line"><span class="built_in">help</span>:</span><br><span class="line">	$(MAKE) -C lib <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">doxy:</span><br><span class="line">	$(MAKE) -C lib doxy</span><br><span class="line"></span><br><span class="line">README: README.md</span><br><span class="line">	pandoc -f markdown -t plain $&lt; -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">... <span class="comment"># 省略后续内容</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三种参考 <code>git@gitee.com:kunpengcompute/KAE.git</code>代码的Makefile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Src</span></span><br><span class="line">SRCDIRS   := <span class="variable">$&#123;WORK_PATH&#125;</span>/</span><br><span class="line">SRCDIRS   += <span class="variable">$&#123;WORK_PATH&#125;</span>/alg/pkey</span><br><span class="line">SRCDIRS   += <span class="variable">$&#123;WORK_PATH&#125;</span>/alg/dh</span><br><span class="line">SRCDIRS   += <span class="variable">$&#123;WORK_PATH&#125;</span>/alg/ciphers</span><br><span class="line">SRCDIRS   += <span class="variable">$&#123;WORK_PATH&#125;</span>/alg/digests</span><br><span class="line">SRCDIRS   += <span class="variable">$&#123;WORK_PATH&#125;</span>/async</span><br><span class="line">SRCDIRS   += <span class="variable">$&#123;WORK_PATH&#125;</span>/wdmngr</span><br><span class="line">SRCDIRS   += <span class="variable">$&#123;WORK_PATH&#125;</span>/utils</span><br><span class="line"></span><br><span class="line">SRCEXTS   := .c <span class="comment"># C program</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">SOURCES = $(foreach d,$(SRCDIRS),$(wildcard $(addprefix $(d)/*,$(SRCEXTS))))</span><br><span class="line"></span><br><span class="line">OBJS    = $(foreach x,$(SRCEXTS), \</span><br><span class="line">      $(patsubst %$(x), %.o, $(filter %$(x),$(SOURCES))))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>Makefile的基础知识差不多是这些，更多的还可以命令调用不同的shell命令执行想要的操作。最基础的就是使用rm命令清理编译文件了。</p>
<p>在码云gitee上面，基本上都有github上众多知名开源库的镜像库，可以提升我们的下载速度。毕竟很多时候github总是连接不上，如果单纯是下载代码学习的话，推荐直接使用gitee查找开源库代码来下载。</p>
<p>不论是在生活，学习还是工作中，你不可能总是得到你想要的。那么就多学习一些知识，提高自身应对需求的能力吧。</p>
<p>近期长沙开启了降温模式，已然进入了秋天，周末早起带我妈去橘子洲景区走了一圈，让她也在长沙旅游一下。我妈从老家来长沙帮忙带娃,平常一个人在陌生的环境中也不容易，周末有时间带她多走走逛逛了！</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(36)-samba配置</title>
    <url>/2022/09/13/2022-20220913-samba/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信大家大部分情况都是使用linux服务器写代码编译代码，看代码又是在Windows系统下。那么就需要有种方法，让我们可以在windows下面直接看linux服务器上面的代码，也就是可以共享linux服务器上面的文件到windows系统中。samba就是满足这种需求的软件。这个算是程序员工作中比较基础的脚手架了。</p>
<span id="more"></span>

<p>很多人可能会说，直接ssh连上服务器，然后使用vim编辑器不就可以了。是的，这是一种不错的方法，但是学习那个vim也是一个过程，况且大家都比较习惯使用windows看代码，不容易改变。最主要的是，对于C程序员而言，windows下有强大的source insight编辑器的存在，这个是vim目前无法替代的，看大型代码还是用si方便，vim只适合在熟悉代码的情况下，进行简单的编辑。</p>
<h2 id="samba配置"><a href="#samba配置" class="headerlink" title="samba配置"></a>samba配置</h2><p>samba配置简单的分几个步骤： 安装、配置、使用。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我讲的是在Ubuntu下安装samba，使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install samba</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置主要就是配置我们要分享哪个目录，配置对外分享名称，用户的权限设置等。</p>
<p>打开 &#x2F;etc&#x2F;samba&#x2F;smb.conf 文件， 在末尾添加以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[shared]			  //windows中看到的共享目录的名称</span><br><span class="line">path = /path/to/shared/directory  //linux中共享的目录的路径</span><br><span class="line">available = <span class="built_in">yes</span>		 //后面这些全是访问权限</span><br><span class="line">browseable = <span class="built_in">yes</span></span><br><span class="line">public = <span class="built_in">yes</span>		</span><br><span class="line">writeable = <span class="built_in">yes</span>		//me是自己的用户名，记得修改为自己的用户名</span><br><span class="line">valid <span class="built_in">users</span> = keep	//给samba服务设置账户</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还需要给用户设置密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbpasswd -a keep</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置完成后，重启smbd服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">systemctl restart  smbd.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>在windows中，访问对应的linux服务器的ip, <code>\\ip</code>就可以看到shared目录， 点击目录，输入账户密码就可以访问了。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>工作中利用好工具，可以事半功倍的。当然，很多时候习惯也不容易改变，主要看需求的紧迫程度了。</p>
<p>我们组内就有个同事，由于他的linux系统跟他的笔记本网络不通，刚开始拿着U盘拷贝代码。后面在办公网搞了个wifi，他就从笔记本的linux虚拟机scp代码到linux系统。每次最新的代码在他本机修改之后，再拷贝到linux上面编译(为什么不在虚拟机编译呢，因为linux系统是arm平台的，虚拟机是x86，部分代码是编译不了的)。在我看来是有点儿低效率了。直接用samba不是更好。</p>
<p>代码都是git管理的，再不济也可以把代码先push到个人分支，到linux下pull下来更快。可以方便的保证两端代码的一致性。</p>
<p>当然，最终他也用上了samba，让自己的笔记本跟linux机器共享文档了。</p>
<p>另外推荐个学习git的工具网站，图形界面，步步为营，简单易懂。对于刚入门的程序员，好好学习git是很有裨益的。</p>
<p><code>https://learngitbranching.js.org/?locale=zh_CN</code></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(37)-DPDK中cryptodev框架介绍</title>
    <url>/2022/09/18/2022-20220918-cryptodev-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据平面开发套件(DPDK, Data Plane Development Kit)是由6WIND,Intel等多家公司开发，主要基于Linux系统运行，用于快速数据包处理的函数库与驱动集合，可以极大提高数据处理性能和吞吐量，提高数据平面应用程序的工作效率。<br>CryptoDev库是DPDK中的一个软件库，提供的管理和配置Crypto poll mode drivers的软件，定义了统一的操作接口。支持加密、认证、链式加密认证、AEAD等对称类算法操作和非对称类算法操作。</p>
<span id="more"></span>

<p><img src="/images/202209/DPDK_CryptoDev.png" alt="cryptodev_algos"></p>
<p>cryptodev库的文件大概十几个，代码仅3千行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:/media/sf_VM_SHARE/code/dpdk/lib# tree cryptodev/</span><br><span class="line">cryptodev/</span><br><span class="line">├── cryptodev_pmd.c</span><br><span class="line">├── cryptodev_pmd.h</span><br><span class="line">├── cryptodev_trace_points.c</span><br><span class="line">├── meson.build</span><br><span class="line">├── rte_crypto_asym.h</span><br><span class="line">├── rte_cryptodev.c</span><br><span class="line">├── rte_cryptodev_core.h</span><br><span class="line">├── rte_cryptodev.h</span><br><span class="line">├── rte_cryptodev_trace_fp.h</span><br><span class="line">├── rte_cryptodev_trace.h</span><br><span class="line">├── rte_crypto.h</span><br><span class="line">├── rte_crypto_sym.h</span><br><span class="line">└── version.map</span><br><span class="line"></span><br><span class="line">0 directories, 13 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>CryptoDev库管理不同的crypto poll mode drivers， 对上提供统一的接口，把pmd抽象成不同的设备。主要功能模块如下图：<br><img src="/images/202209/cryptodev_arch.png" alt="cryptodev_arch"></p>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p>类似linux的驱动管理，CryptoDev把每一种实现算法的硬件或者软件库当做一个crypto设备，定义了crypto设备对应的结构体rte_cryptodev。目前最大支持64个crypto设备，这些信息都会存在一个全局变量cryptodev_globals中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_cryptodev</span> <span class="title">rte_crypto_devices</span>[<span class="title">RTE_CRYPTO_MAX_DEVS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_cryptodev</span> *<span class="title">rte_cryptodevs</span> =</span> rte_crypto_devices;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_cryptodev_global</span> <span class="title">cryptodev_globals</span> =</span> &#123;</span><br><span class="line">		.devs			= rte_crypto_devices,</span><br><span class="line">		.data			= &#123; <span class="literal">NULL</span> &#125;,</span><br><span class="line">		.nb_devs		= <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在创建完设备之后，使用设备之前需要调用相关的接口对设备相关的资源进行配置和初始化，后面才开始正常处理。</p>
<h3 id="设备创建"><a href="#设备创建" class="headerlink" title="设备创建"></a>设备创建</h3><p>物理加密设备在DPDK初始化阶段的PCI探测到。虚拟设备可以在程序执行时指定vdev或者在代码中硬编码创建。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--vdev  <span class="string">&#x27;crypto_aesni_mb0,max_nb_queue_pairs=2,socket_id=0&#x27;</span></span><br><span class="line">rte_vdev_init(<span class="string">&quot;crypto_aesni_mb&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;max_nb_queue_pairs=2,socket_id=0&quot;</span>)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>在PMD中调用RTE_PMD_REGISTER_VDEV注册为给定vdev的驱动。</p>
<h3 id="设备描述标识"><a href="#设备描述标识" class="headerlink" title="设备描述标识"></a>设备描述标识</h3><p>描述一个设备有两种标识。一个是设备的索引，另外一个是设备的名称。可以类比接口名和接口索引。<br>设备索引主要在于设备创建的顺序，名称是PMD注册时指定的。</p>
<h3 id="设备配置"><a href="#设备配置" class="headerlink" title="设备配置"></a>设备配置</h3><p>配置主要就是资源的配置(如：队列数目)，默认状态，计数器初始化。</p>
<h3 id="队列对配置"><a href="#队列对配置" class="headerlink" title="队列对配置"></a>队列对配置</h3><p>pmd最主要的模式就是针对一个队列对入队出队，通过rte_cryptodev_queue_pair_setup接口分别设置crypto设备的队列对，从指定的socket申请资源。</p>
<h2 id="设备特性及能力"><a href="#设备特性及能力" class="headerlink" title="设备特性及能力"></a>设备特性及能力</h2><p>Crypto设备定义全局的feature和算法能力，来描述crypto设备支持的功能。</p>
<p>在设备创建时，定义设备支持的特性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// openssl pmd 创建时设置 feature</span></span><br><span class="line"></span><br><span class="line">dev-&gt;feature_flags = RTE_CRYPTODEV_FF_SYMMETRIC_CRYPTO |</span><br><span class="line">			RTE_CRYPTODEV_FF_SYM_OPERATION_CHAINING |</span><br><span class="line">			RTE_CRYPTODEV_FF_CPU_AESNI |</span><br><span class="line">			RTE_CRYPTODEV_FF_IN_PLACE_SGL |</span><br><span class="line">			RTE_CRYPTODEV_FF_OOP_SGL_IN_LB_OUT |</span><br><span class="line">			RTE_CRYPTODEV_FF_OOP_LB_IN_LB_OUT |</span><br><span class="line">			RTE_CRYPTODEV_FF_ASYMMETRIC_CRYPTO |</span><br><span class="line">			RTE_CRYPTODEV_FF_RSA_PRIV_OP_KEY_EXP |</span><br><span class="line">			RTE_CRYPTODEV_FF_RSA_PRIV_OP_KEY_QT |</span><br><span class="line">			RTE_CRYPTODEV_FF_SYM_SESSIONLESS;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个PMD会提供各自的算法能力数组，类型为<code>struct rte_cryptodev_capabilities</code>。一般在算法执行前，使用者通过rte_cryptodev_info_get接口调用到具体PMD提供的接口，获取到PMD的能力，再决定能否继续操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  	rte_cryptodev_info_get(dev_id, &amp;dev_info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(dev_info.feature_flags &amp; RTE_CRYPTODEV_FF_SYMMETRIC_CRYPTO)) &#123;</span><br><span class="line">	RTE_LOG(INFO, USER1, <span class="string">&quot;Feature flag requirements for Snow3G &quot;</span></span><br><span class="line">			<span class="string">&quot;testsuite not met\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> TEST_SKIPPED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ... </span><br><span class="line"></span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_cryptodev_capabilities</span> <span class="title">openssl_pmd_capabilities</span>[] =</span> &#123;</span><br><span class="line">&#123;	<span class="comment">/* MD5 HMAC */</span></span><br><span class="line">	.op = RTE_CRYPTO_OP_TYPE_SYMMETRIC,</span><br><span class="line">	&#123;.sym = &#123;</span><br><span class="line">		.xform_type = RTE_CRYPTO_SYM_XFORM_AUTH,</span><br><span class="line">		&#123;.auth = &#123;</span><br><span class="line">			.algo = RTE_CRYPTO_AUTH_MD5_HMAC,</span><br><span class="line">			.block_size = <span class="number">64</span>,</span><br><span class="line">			.key_size = &#123;</span><br><span class="line">				.min = <span class="number">1</span>,</span><br><span class="line">				.max = <span class="number">64</span>,</span><br><span class="line">				.increment = <span class="number">1</span></span><br><span class="line">			&#125;,</span><br><span class="line">			.digest_size = &#123;</span><br><span class="line">				.min = <span class="number">1</span>,</span><br><span class="line">				.max = <span class="number">16</span>,</span><br><span class="line">				.increment = <span class="number">1</span></span><br><span class="line">			&#125;,</span><br><span class="line">			.iv_size = &#123; <span class="number">0</span> &#125;</span><br><span class="line">		&#125;, &#125;</span><br><span class="line">	&#125;, &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;	<span class="comment">/* MD5 */</span></span><br><span class="line">	.op = RTE_CRYPTO_OP_TYPE_SYMMETRIC,</span><br><span class="line">	&#123;.sym = &#123;</span><br><span class="line">		.xform_type = RTE_CRYPTO_SYM_XFORM_AUTH,</span><br><span class="line">		&#123;.auth = &#123;</span><br><span class="line">			.algo = RTE_CRYPTO_AUTH_MD5,</span><br><span class="line">			.block_size = <span class="number">64</span>,</span><br><span class="line">			.key_size = &#123;</span><br><span class="line">				.min = <span class="number">0</span>,</span><br><span class="line">				.max = <span class="number">0</span>,</span><br><span class="line">				.increment = <span class="number">0</span></span><br><span class="line">			&#125;,</span><br><span class="line">			.digest_size = &#123;</span><br><span class="line">				.min = <span class="number">16</span>,</span><br><span class="line">				.max = <span class="number">16</span>,</span><br><span class="line">				.increment = <span class="number">0</span></span><br><span class="line">			&#125;,</span><br><span class="line">			.iv_size = &#123; <span class="number">0</span> &#125;</span><br><span class="line">		&#125;, &#125;</span><br><span class="line">	&#125;, &#125;</span><br><span class="line">&#125;,</span><br><span class="line">   ... <span class="comment">// 省略</span></span><br></pre></td></tr></table></figure>

<h2 id="操作处理"><a href="#操作处理" class="headerlink" title="操作处理"></a>操作处理</h2><p>Crypto Operation使用入队出队的接口集实现操作处理。使用enqueue_burst接口接收待处理的operations，软件pmd一般会直接进行算法执行，硬件pmd会把数据放到硬件的input queue。使用dequeue_burst接口获取已经处理完成的operations，软件pmd一般从软件的已完成的队列中获取完成的operations，硬件pmd从硬件的output&#x2F;processed queue获取。</p>
<h3 id="私有数据"><a href="#私有数据" class="headerlink" title="私有数据"></a>私有数据</h3><p>提供set和get接口API设置算法计算时需要的用户数据到crypto session数据结构中。对于session-less的操作，私有数据可以存放到operation内存尾部。所谓的私有数据一般是各个pmd内部识别算法使用的数据结构。</p>
<h3 id="回调API"><a href="#回调API" class="headerlink" title="回调API"></a>回调API</h3><p>支持注册回调函数，在关联的队列对调用enqueue_burst之后，或者调用dequeue_burst之前，执行额外的操作。<br>这些回调函数，需要用户自己控制注销，以免造成内存泄漏。</p>
<p>感觉这个没有多大用处。</p>
<h3 id="Enqueue-x2F-Dequeue-Burst-接口"><a href="#Enqueue-x2F-Dequeue-Burst-接口" class="headerlink" title="Enqueue&#x2F;Dequeue Burst 接口"></a>Enqueue&#x2F;Dequeue Burst 接口</h3><p>提供接口往指定设备的指定队列队塞或者拉取operations。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">rte_cryptodev_enqueue_burst</span><span class="params">(<span class="type">uint8_t</span> dev_id, <span class="type">uint16_t</span> qp_id,</span></span><br><span class="line"><span class="params">                                     <span class="keyword">struct</span> rte_crypto_op **ops, <span class="type">uint16_t</span> nb_ops)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">rte_cryptodev_dequeue_burst</span><span class="params">(<span class="type">uint8_t</span> dev_id, <span class="type">uint16_t</span> qp_id,</span></span><br><span class="line"><span class="params">                                     <span class="keyword">struct</span> rte_crypto_op **ops, <span class="type">uint16_t</span> nb_ops)</span></span><br></pre></td></tr></table></figure>

<h3 id="Operation结构定义"><a href="#Operation结构定义" class="headerlink" title="Operation结构定义"></a>Operation结构定义</h3><p>定义了operation的结构。一部分通用的区域，然后再分别跟着sym或者asym的operation，最后是私有的数据。开发者需要填充好各个字段，后续PMD才能正常执行。不同的算法都有一个约定好的数据格式，各个pmd按照约定去解析数据。</p>
<h3 id="Operation分配管理"><a href="#Operation分配管理" class="headerlink" title="Operation分配管理"></a>Operation分配管理</h3><p>对Operation空间的分配管理提供了一套API接口。<br>定义一个mempool来分配operation空间， 以及如何从pool申请&#x2F;释放空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> rte_mempool *</span><br><span class="line"><span class="title function_">rte_crypto_op_pool_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">enum</span> rte_crypto_op_type type,</span></span><br><span class="line"><span class="params">                          <span class="type">unsigned</span> nb_elts, <span class="type">unsigned</span> cache_size, <span class="type">uint16_t</span> priv_size,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> socket_id)</span>;</span><br><span class="line"><span class="keyword">struct</span> rte_crypto_op *<span class="title function_">rte_crypto_op_alloc</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mempool,</span></span><br><span class="line"><span class="params">                                          <span class="keyword">enum</span> rte_crypto_op_type type)</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">rte_crypto_op_bulk_alloc</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mempool,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">enum</span> rte_crypto_op_type type,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> rte_crypto_op **ops, <span class="type">uint16_t</span> nb_ops)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_crypto_op_free</span><span class="params">(<span class="keyword">struct</span> rte_crypto_op *op)</span></span><br></pre></td></tr></table></figure>

<h3 id="对称算法支持"><a href="#对称算法支持" class="headerlink" title="对称算法支持"></a>对称算法支持</h3><p>主要用图描述一下对称算法的使用。</p>
<p><img src="/images/202209/symflow.png" alt="symflow"></p>
<h3 id="非对称算法支持"><a href="#非对称算法支持" class="headerlink" title="非对称算法支持"></a>非对称算法支持</h3><p>主要用图描述一下非对称算法的使用。</p>
<p><img src="/images/202209/asymflow.png" alt="asymflow"></p>
<h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><p>部分pmd支持同步模式，可以不使用enqueue_burst和dequeue_burst接口，而直接使用rte_cryptodev_sym_cpu_crypto_process。此时，需要设置feature 标记RTE_CRYPTODEV_FF_SYM_CPU_CRYPTO。</p>
<h3 id="Raw-Data-path-API"><a href="#Raw-Data-path-API" class="headerlink" title="Raw Data-path API"></a>Raw Data-path API</h3><p>不使用DPDK提供的数据结构（rte_mbuf, rte_crypto_op等），可以使用用户定义的结构直接转换。待深入了解。</p>
<h2 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><p>可以使用工具dpdk-telemetry.py查看设备信息。</p>
<p><img src="/images/202209/telemetry.png" alt="telemetry"></p>
<p>DPDK还提供了许多tools来作大页内存配置&#x2F;设备绑定等。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>CryptoDev库的代码使用了面向对象编程的方法，抽象出许多实体，使用指针的方式关联这些实体。</p>
<p>随着软件行业的发展，面向对象编程使用的也更加广泛了。现在很多使用C语言编写的库都应用了面向对象编程的设计。包括Linux内核代码也一样，比如Linux Crypto框架，把算法抽象成了对象，还使用了模板，使得代码更加形象化。</p>
<p>这周给组内分享了一下DPDK CryptoDev框架的基础，星期一的时候花了一整天的时间全面地看了一下cryptodev的主要代码。今天小结一下。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>DPDK</category>
      </categories>
  </entry>
  <entry>
    <title>DPDK ZUC PMD代码笔记</title>
    <url>/2022/10/01/2022-20221001-zuc-weekly/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>最近看了流密码算法的Crypto PMD，稍微总结一下。</p>
<h1 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2. 介绍"></a>2. 介绍</h1><p>Snow3g&#x2F;Zuc PMD都是基于intel-ipsec-mb库实现的库。许多数据和操作都是公共的，代码都位于dpdk&#x2F;drivers&#x2F;crypto&#x2F;ipsec_mb目录下。</p>
<p>intel-ipsec-mb库是为包处理提供的一个软件加密库，可以用在IPsec， TLS， Wireless等应用中。</p>
<p>ipsec_mb下还有多个pmd，对应不同的算法。不同pmd类型相关的数据会保存到ipsec_mb_pmds变量中，公共函数根据当前的pmd类型获取对应pmd的数据和函数处理数据。实现不同pmd的分离。PMD类型在PMD初始化时保存到dev的dev_private区域。</p>
<span id="more"></span>

<h1 id="3-ZUC-PMD"><a href="#3-ZUC-PMD" class="headerlink" title="3. ZUC PMD"></a>3. ZUC PMD</h1><p>ZUC PMD的主要函数整理如下：</p>
<p><img src="/images/202210/zuc_pmd_func.png" alt="zuc_pmd_func"></p>
<p>下面描述一下主要的功能实现：</p>
<h2 id="3-1-PMD操作回调及数据设置"><a href="#3-1-PMD操作回调及数据设置" class="headerlink" title="3.1 PMD操作回调及数据设置"></a>3.1 PMD操作回调及数据设置</h2><p>ipsec_mb_register_zuc函数在程序启动时设置ZUC PMD相关的配置，保存到全局数组变量ipsec_mb_pmds中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Constructor function to register zuc PMD */</span></span><br><span class="line">RTE_INIT(ipsec_mb_register_zuc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipsec_mb_internals</span> *<span class="title">zuc_data</span></span></span><br><span class="line"><span class="class">	    =</span> &amp;ipsec_mb_pmds[IPSEC_MB_PMD_TYPE_ZUC];</span><br><span class="line"></span><br><span class="line">	zuc_data-&gt;caps = zuc_capabilities;</span><br><span class="line">	zuc_data-&gt;dequeue_burst = zuc_pmd_dequeue_burst;</span><br><span class="line">	zuc_data-&gt;feature_flags = RTE_CRYPTODEV_FF_SYMMETRIC_CRYPTO</span><br><span class="line">			| RTE_CRYPTODEV_FF_SYM_OPERATION_CHAINING</span><br><span class="line">			| RTE_CRYPTODEV_FF_NON_BYTE_ALIGNED_DATA</span><br><span class="line">			| RTE_CRYPTODEV_FF_OOP_SGL_IN_LB_OUT</span><br><span class="line">			| RTE_CRYPTODEV_FF_SYM_SESSIONLESS</span><br><span class="line">			| RTE_CRYPTODEV_FF_OOP_LB_IN_LB_OUT;</span><br><span class="line">	zuc_data-&gt;internals_priv_size = <span class="number">0</span>;</span><br><span class="line">	zuc_data-&gt;ops = &amp;zuc_pmd_ops;</span><br><span class="line">	zuc_data-&gt;qp_priv_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> zuc_qp_data);</span><br><span class="line">	zuc_data-&gt;session_configure = zuc_session_configure;</span><br><span class="line">	zuc_data-&gt;session_priv_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> zuc_session);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTE_INIT的实现如下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_PRIO(prio) \</span></span><br><span class="line"><span class="meta">	RTE_PRIORITY_ ## prio</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run function before main() with high priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param func</span></span><br><span class="line"><span class="comment"> *   Constructor function.</span></span><br><span class="line"><span class="comment"> * @param prio</span></span><br><span class="line"><span class="comment"> *   Priority number must be above 100.</span></span><br><span class="line"><span class="comment"> *   Lowest number is the first to run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RTE_INIT_PRIO <span class="comment">/* Allow to override from EAL */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_INIT_PRIO(func, prio) \</span></span><br><span class="line"><span class="meta">static void __attribute__((constructor(RTE_PRIO(prio)), used)) func(void)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run function before main() with low priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The constructor will be run after prioritized constructors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param func</span></span><br><span class="line"><span class="comment"> *   Constructor function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_INIT(func) \</span></span><br><span class="line"><span class="meta">	RTE_INIT_PRIO(func, LAST)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RTE_INIT使用的是编译器的constructor属性，使得该函数在main函数运行之前就调用，类似于静态执行的一种机制。</p>
<h2 id="3-2-设备驱动发现及卸载"><a href="#3-2-设备驱动发现及卸载" class="headerlink" title="3.2 设备驱动发现及卸载"></a>3.2 设备驱动发现及卸载</h2><p>上一篇文章中讲过，PMD会调用RTE_PMD_REGISTER_VDEV注册虚拟设备到DPDK框架中，在应用启动之后主动把驱动的发现和卸载的接口注册上去，也是调用的RTE_INIT实现的。</p>
<p>ZUC PMD设备驱动发现及卸载函数分别调用ipsec_mb_create、ipsec_mb_remove。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">zuc_probe</span><span class="params">(<span class="keyword">struct</span> rte_vdev_device *vdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ipsec_mb_create(vdev, IPSEC_MB_PMD_TYPE_ZUC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_vdev_driver</span> <span class="title">cryptodev_zuc_pmd_drv</span> =</span> &#123;</span><br><span class="line">	.probe = zuc_probe,</span><br><span class="line">	.remove = ipsec_mb_remove</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cryptodev_driver</span> <span class="title">zuc_crypto_drv</span>;</span></span><br><span class="line"></span><br><span class="line">RTE_PMD_REGISTER_VDEV(CRYPTODEV_NAME_ZUC_PMD, cryptodev_zuc_pmd_drv);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设备发现实现函数ipsec_mb_create，主要内容：</p>
<p>1)获取pmd操作函数及数据<br>2)解析参数，创建pmd<br>3)在dev的私有数据部分，保存pmd类型及队列数目配置<br>4)获取驱动id， 驱动id在注册时确定，跟设备id不一样，驱动存放在cryptodev_driver_list<br>5)设置出入队函数、特性等数据到dev  </p>
<p>设备卸载实现函数ipsec_mb_remove  </p>
<ol>
<li>释放队列对资源  </li>
<li>释放pmd</li>
</ol>
<h2 id="3-3-能力定义"><a href="#3-3-能力定义" class="headerlink" title="3.3 能力定义"></a>3.3 能力定义</h2><p>ZUC PMD顾名思义就是只支持ZUC算法了。</p>
<p><img src="/images/202210/zuc_capacity.png" alt="zuc_capacity"></p>
<h2 id="3-4-队列对配置"><a href="#3-4-队列对配置" class="headerlink" title="3.4 队列对配置"></a>3.4 队列对配置</h2><p>实现函数为ipsec_mb_qp_setup：<br>1）为dev-&gt;data-&gt;queue_pairs[qp_id]申请空间，并初始化相关内容。<br>2）保存mp_pool, mp_pool_private。<br>3）创建队列对的软件队列rte_ring<br>4）队列对相关的统计数据结构初始化</p>
<h2 id="3-5-Session处理"><a href="#3-5-Session处理" class="headerlink" title="3.5 Session处理"></a>3.5 Session处理</h2><p>rte_cryptodev_sym_session_create从队列对对应的mp_pool申请一个rte_cryptodev_sym_session。调用rte_cryptodev_sym_session_init初始化，从mp_pool_private申请PMD的私有session结构，调用sys_session_configure把xform数据转换为私有的session数据。</p>
<p>看了许多DPDK的示例代码，默认一个vdev申请一个session， 每个session对应一种算法，也就对应到一个chain类型(CIPHER, AUTH, CIPHER_AUTH, AUTH_CIPHER和AEAD)。在出队入队时，同一批的ops，默认会是同一个session的，当然，具体看那个应用的实现了，也是可以支持不同算法类型的ops的，框架并没有对此限定。</p>
<p>ZUC pmd实现函数zuc_session_configure：<br>1）解析xform链，获取operation对应的类型及相关的cipher_xform， auth_xform, aead_xform<br>2）从xform中获取数据信息填充到私有session结构  </p>
<h2 id="3-6-Operation管理"><a href="#3-6-Operation管理" class="headerlink" title="3.6 Operation管理"></a>3.6 Operation管理</h2><p>用户根据情况自行创建op_mpool，调用rte_crypto_op_pool_create创建，op_mpool池分为对称和非对称两种类型。后面可以追加用户自定义的数据。<br>struct rte_mempool *<br>rte_crypto_op_pool_create(const char *name, enum rte_crypto_op_type type,<br>        unsigned nb_elts, unsigned cache_size, uint16_t priv_size,<br>        int socket_id)</p>
<p>大致结构如下：  </p>
<p><img src="/images/202210/zuc_operation.png" alt="zuc_operation"></p>
<p>然后rte_crypto_op_alloc申请对应的operation，把session跟operation关联起来，把数据相关的信息填充到operation中。<br>一般把iv放到priv data区域。</p>
<h2 id="3-7-入队出队"><a href="#3-7-入队出队" class="headerlink" title="3.7 入队出队"></a>3.7 入队出队</h2><p>入队统一使用公共的ipsec_mb_enqueue_burst，实现比较简单，直接把相关的ops添加到ingress_queue中，增加入队计数。<br>出队列实现函数zuc_pmd_dequeue_burst：    </p>
<ul>
<li>从ingress_queue获取nu_ops个ops    </li>
<li>获取ops管理的session数据， 得到ops对应的算法类型。    </li>
<li>获取相同算法类型的ops集中处理，最大16个。前N个类型相同，则最多处理16个，如果N小于16，则先处理N个，再处理下一种类型数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">zuc_pmd_dequeue_burst</span><span class="params">(<span class="type">void</span> *queue_pair,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> rte_crypto_op **c_ops, <span class="type">uint16_t</span> nb_ops)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_crypto_op</span> *<span class="title">curr_c_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zuc_session</span> *<span class="title">curr_sess</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zuc_session</span> *<span class="title">sessions</span>[<span class="title">ZUC_MAX_BURST</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_crypto_op</span> *<span class="title">int_c_ops</span>[<span class="title">ZUC_MAX_BURST</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">ipsec_mb_operation</span> <span class="title">prev_zuc_op</span> =</span> IPSEC_MB_OP_NOT_SUPPORTED;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">ipsec_mb_operation</span> <span class="title">curr_zuc_op</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipsec_mb_qp</span> *<span class="title">qp</span> =</span> queue_pair;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nb_dequeued;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="type">uint8_t</span> burst_size = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint8_t</span> processed_ops;</span><br><span class="line"></span><br><span class="line">	nb_dequeued = rte_ring_dequeue_burst(qp-&gt;ingress_queue,</span><br><span class="line">			(<span class="type">void</span> **)c_ops, nb_ops, <span class="literal">NULL</span>); <span class="comment">// 出队指定个数的ops</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb_dequeued; i++) &#123;</span><br><span class="line">		curr_c_op = c_ops[i];</span><br><span class="line"></span><br><span class="line">		curr_sess = (<span class="keyword">struct</span> zuc_session *)</span><br><span class="line">			ipsec_mb_get_session_private(qp, curr_c_op); <span class="comment">// 获取私有session</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(curr_sess == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			curr_c_op-&gt;status =</span><br><span class="line">					RTE_CRYPTO_OP_STATUS_INVALID_SESSION;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		curr_zuc_op = curr_sess-&gt;op; <span class="comment">// 得到相同算法类型的操作</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Batch ops that share the same operation type</span></span><br><span class="line"><span class="comment">		 * (cipher only, auth only...).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (burst_size == <span class="number">0</span>) &#123;</span><br><span class="line">			prev_zuc_op = curr_zuc_op;</span><br><span class="line">			int_c_ops[<span class="number">0</span>] = curr_c_op;</span><br><span class="line">			sessions[<span class="number">0</span>] = curr_sess;</span><br><span class="line">			burst_size++;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr_zuc_op == prev_zuc_op) &#123;</span><br><span class="line">			int_c_ops[burst_size] = curr_c_op; <span class="comment">// 保存ops到临时数组中</span></span><br><span class="line">			sessions[burst_size] = curr_sess;  <span class="comment">// 同步保存私有的session</span></span><br><span class="line">			burst_size++;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * When there are enough ops to process in a batch,</span></span><br><span class="line"><span class="comment">			 * process them, and start a new batch.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (burst_size == ZUC_MAX_BURST) &#123; <span class="comment">//  按16个批量处理</span></span><br><span class="line">				processed_ops = process_ops(int_c_ops, curr_zuc_op,</span><br><span class="line">						sessions, qp, burst_size);</span><br><span class="line">				<span class="keyword">if</span> (processed_ops &lt; burst_size) &#123;</span><br><span class="line">					burst_size = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				burst_size = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Different operation type, process the ops</span></span><br><span class="line"><span class="comment">			 * of the previous type.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			processed_ops = process_ops(int_c_ops, prev_zuc_op, <span class="comment">// 遇到有不同算法的op，先处理之前的op</span></span><br><span class="line">					sessions, qp, burst_size);</span><br><span class="line">			<span class="keyword">if</span> (processed_ops &lt; burst_size) &#123;</span><br><span class="line">				burst_size = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			burst_size = <span class="number">0</span>;</span><br><span class="line">			prev_zuc_op = curr_zuc_op;</span><br><span class="line"></span><br><span class="line">			int_c_ops[<span class="number">0</span>] = curr_c_op;</span><br><span class="line">			sessions[<span class="number">0</span>] = curr_sess;</span><br><span class="line">			burst_size++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (burst_size != <span class="number">0</span>) &#123; <span class="comment">//处理达不到批量数量的op</span></span><br><span class="line">		<span class="comment">/* Process the crypto ops of the last operation type. */</span></span><br><span class="line">		processed_ops = process_ops(int_c_ops, prev_zuc_op,</span><br><span class="line">				sessions, qp, burst_size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	qp-&gt;stats.dequeued_count += i;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-8-Session池创建"><a href="#3-8-Session池创建" class="headerlink" title="3.8 Session池创建"></a>3.8 Session池创建</h2><p>每个numa节点分别分配一个mp_pool和一个mp_pool_private。<br>mp_pool的成员为rte_cryptodev_sym_session， 元素个数为设备数目乘以队列数，也就是让每个队列都能分配到一个session。<br>mp_pool使用接口rte_cryptodev_sym_session_pool_create创建</p>
<p>struct rte_mempool *<br>rte_cryptodev_sym_session_pool_create(const char *name, uint32_t nb_elts,<br>    uint32_t elt_size, uint32_t cache_size, uint16_t user_data_size,<br>    int socket_id)</p>
<p>mp_pool的元素为rte_cryptodev_sym_session</p>
<p><img src="/images/202210/crypto_sym_session.png" alt="crypto_sym_session"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cryptodev symmetric crypto session</span></span><br><span class="line"><span class="comment"> * Each session is derived from a fixed xform chain. Therefore each session</span></span><br><span class="line"><span class="comment"> * has a fixed algo, key, op-type, digest_len etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_cryptodev_sym_session</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> opaque_data;</span><br><span class="line">	<span class="comment">/**&lt; Can be used for external metadata */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_drivers;</span><br><span class="line">	<span class="comment">/**&lt; number of elements in sess_data array */</span></span><br><span class="line">	<span class="type">uint16_t</span> user_data_sz;</span><br><span class="line">	<span class="comment">/**&lt; session user data will be placed after sess_data */</span></span><br><span class="line">	__extension__ <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">void</span> *data;</span><br><span class="line">		<span class="type">uint16_t</span> refcnt;</span><br><span class="line">	&#125; sess_data[];</span><br><span class="line">	<span class="comment">/**&lt; Driver specific session material, variable size */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据代码注释，我们可以确定每个session对应固定的算法， key，操作类型等数据。<br>mp_pool_priveate的则是PMD定义的私有数据，大小通过PMD提供的sym_session_get_size接口获取。mp_pool_private使用rte_mempool_create创建。<br>这两个pool池会被设置到队列对的配置中去。调用rte_cryptodev_queue_pair_setup进行配置。</p>
<p>PMD初始化的时候会保存socket_id到dev结构中。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>大概梳理了一下ZUC PMD的接口，及其app调用的流程中的部分功能实现。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>DPDK</category>
      </categories>
  </entry>
  <entry>
    <title>周谈(39)-近期小事</title>
    <url>/2022/10/16/2022-20221016-lats-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>国庆后这周连续上来7天班，事情做了许多，也包含了许多小事儿，大的部分暂时没有准备好。本周就拼凑着讲一下几个小事儿。</p>
<span id="more"></span>

<h1 id="DPDK-ring出队是否卡住"><a href="#DPDK-ring出队是否卡住" class="headerlink" title="DPDK ring出队是否卡住"></a>DPDK ring出队是否卡住</h1><p>节前的时候，组里的同事检视我的代码，提了一个意见。说是rte_ring这个环状队列，被调用批量出队的时候，如果对内里面的个数小于期望的个数，那么会返回0或者卡住。我就写了个demo验证了一下，结果如下：</p>
<p><img src="/images/202210/rte_ring.png" alt="rte_ring"></p>
<p>可以看出，出队时并不会卡住，即使不满足期望个数也会出队实际的个数。</p>
<h1 id="动态库的constructor方法在库被加载时才会被调用"><a href="#动态库的constructor方法在库被加载时才会被调用" class="headerlink" title="动态库的constructor方法在库被加载时才会被调用"></a>动态库的constructor方法在库被加载时才会被调用</h1><p>我们知道，如果设置了一个函数的gcc属性为__attribute__(constructor)，那么在main函数运行之前就会调用这个函数。</p>
<p>同事在把DPDK的driver库编译为动态库的时候，发现运行的时候很多数据没有正常初始化。然后打印了断点，函数也没有被断到，可以确定对应的函数没有执行。</p>
<p>想来没有加载动态库的时候，这些函数也就在main运行之前不会被调用了，很正常。DPDK的eal参数提供了加载指定驱动的命令选项， 可以通过加载指定的so，后续在运行的时候发现数据正常初始化了。</p>
<p>看了一下这块的代码，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-d LIB.so|DIR       Add a driver or driver directory</span><br><span class="line">                     (can be used multiple times)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">eal_parse_common_option</span><span class="params">(<span class="type">int</span> opt, <span class="type">const</span> <span class="type">char</span> *optarg,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> internal_config *conf)</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* force loading of external driver */</span></span><br><span class="line">	<span class="keyword">case</span> &#x27;d&#x27;:</span><br><span class="line">		<span class="title function_">if</span> <span class="params">(eal_plugin_add(optarg) == <span class="number">-1</span>)</span></span><br><span class="line">			<span class="keyword">return</span> -1;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">eal_plugin_add</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shared_driver</span> *<span class="title">solib</span>;</span></span><br><span class="line"></span><br><span class="line">	solib = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*solib));</span><br><span class="line">	<span class="keyword">if</span> (solib == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		RTE_LOG(ERR, EAL, <span class="string">&quot;malloc(solib) failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(solib, <span class="number">0</span>, <span class="keyword">sizeof</span>(*solib));</span><br><span class="line">	strlcpy(solib-&gt;name, path, PATH_MAX);</span><br><span class="line">	TAILQ_INSERT_TAIL(&amp;solib_list, solib, next);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">eal_plugins_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shared_driver</span> *<span class="title">solib</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we are not statically linked, add default driver loading</span></span><br><span class="line"><span class="comment">	 * path if it exists as a directory.</span></span><br><span class="line"><span class="comment">	 * (Using dlopen with NOLOAD flag on EAL, will return NULL if the EAL</span></span><br><span class="line"><span class="comment">	 * shared library is not already loaded i.e. it&#x27;s statically linked.)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (is_shared_build() &amp;&amp;</span><br><span class="line">			*default_solib_dir != <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">			stat(default_solib_dir, &amp;sb) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">			S_ISDIR(sb.st_mode))</span><br><span class="line">		eal_plugin_add(default_solib_dir);</span><br><span class="line"></span><br><span class="line">	TAILQ_FOREACH(solib, &amp;solib_list, next) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (stat(solib-&gt;name, &amp;sb) == <span class="number">0</span> &amp;&amp; S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (eal_plugindir_init(solib-&gt;name) == <span class="number">-1</span>) &#123;</span><br><span class="line">				RTE_LOG(ERR, EAL,</span><br><span class="line">					<span class="string">&quot;Cannot init plugin directory %s\n&quot;</span>,</span><br><span class="line">					solib-&gt;name);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			RTE_LOG(DEBUG, EAL, <span class="string">&quot;open shared lib %s\n&quot;</span>,</span><br><span class="line">				solib-&gt;name);</span><br><span class="line">			solib-&gt;lib_handle = eal_dlopen(solib-&gt;name);</span><br><span class="line">			<span class="keyword">if</span> (solib-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，在参数解析的时候会把driver对应的路径存起来， 在后面的eal_plugins_init时候调用dlopen加载该动态库。<br>很多插件的实现原理也是类似，通过加载固定文件夹下的so，触发特定的函数执行，或者是调用so内部的特定函数，实现对应的功能。</p>
<h1 id="destructor在函数异常退出是不会调用被调用"><a href="#destructor在函数异常退出是不会调用被调用" class="headerlink" title="destructor在函数异常退出是不会调用被调用"></a>destructor在函数异常退出是不会调用被调用</h1><p>最近在设计一个用户态库的接口，需要对外提供资源的申请释放的接口，资源是通过ioctl调用内核的驱动模块来操作的，也就是多个用户态进程会共同使用内核的资源。我本来是想着，如果使用接口的进程异常退出了，那么就由用户态的库自动释放这些资源。本来我是想着使用attribute(destructor)属性的函数来实现已申请的资源的释放的。实验了一下，发现此路不同。</p>
<p>show you code:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用于验证异常情况下， destructor是否会被调用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">结论：</span></span><br><span class="line"><span class="comment">进程异常(被kill)退出，不会调用destructor函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">beforeFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;beforeFunction\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">afterFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;afterFunction\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> times = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; times)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;current i = %d\r\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译运行之后，我使用kill -9 命令杀死这个进程，可以看到，并没有输出afterFunction。</p>
<p><img src="/images/202210/destructor.png" alt="destructor"></p>
<h1 id="device-create创建设备文件"><a href="#device-create创建设备文件" class="headerlink" title="device_create创建设备文件"></a>device_create创建设备文件</h1><p>之前在学习驱动的时候，文章<a href="https://fishmwei.github.io/2022/08/14/driver-char/">字符设备驱动</a>使用的mknod命令手动创建了设备文件。这周看了之前的驱动代码， 使用device_create函数创建了设备文件。</p>
<p>在调用device_create前要先用class_create创建一个类。类这个概念在Linux中被抽象成一种设备的集合。类在&#x2F;sys&#x2F;class目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@keep-VirtualBox:/sys/class# ls /sys/class/</span><br><span class="line">ata_device  block          devlink   drm_dp_aux_dev  hidraw       intel_scu_ipc  mem       net       power_supply  ptp           remoteproc   scsi_generic  thermal   vc            watchdog</span><br><span class="line">ata_link    bsg            dma       extcon          hwmon        iommu          misc      pci_bus   ppdev         pwm           rfkill       scsi_host     tpm       vfio          wwan</span><br><span class="line">ata_port    devcoredump    dma_heap  firmware        i2c-adapter  leds           mmc_host  pci_epc   ppp           rapidio_port  rtc          sound         tpmrm     virtio-ports</span><br><span class="line">backlight   devfreq        dmi       gpio            i2c-dev      lirc           msr       phy       pps           rc            scsi_device  spi_master    tty       vtconsole</span><br><span class="line">bdi         devfreq-event  drm       graphics        input        mdio_bus       nd        powercap  printer       regulator     scsi_disk    spi_slave     usb_role  wakeup</span><br><span class="line">root@keep-VirtualBox:/sys/class#</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   ...</span><br><span class="line">   globalmem_devp-&gt;dev_class = class_create(THIS_MODULE, <span class="string">&quot;driver_dev&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (IS_ERR(globalmem_devp-&gt;dev_class)) &#123;</span><br><span class="line">       printk(<span class="string">&quot;class create error\r\n&quot;</span>);</span><br><span class="line">       ret =  -EBUSY;</span><br><span class="line">       <span class="keyword">goto</span> fail_malloc;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   devices = device_create(globalmem_devp-&gt;dev_class, <span class="literal">NULL</span>, MKDEV(globalmem_major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;globalmem&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="literal">NULL</span> == devices)&#123;</span><br><span class="line">	printk(<span class="string">&quot;device_create error\r\n&quot;</span>);</span><br><span class="line">	ret =  -EBUSY;</span><br><span class="line">       class_destroy(globalmem_devp-&gt;dev_class);</span><br><span class="line">	<span class="keyword">goto</span> fail_malloc;</span><br><span class="line">&#125;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>安装之后， 可以在&#x2F;sys&#x2F;class和&#x2F;dev下找到driver_dev和globalmem</p>
<p><img src="/images/202210/char_dev.png" alt="char_dev"></p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这篇知识比较零碎。具体的测试代码在Gitee仓库中<a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#105;&#116;&#101;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#64;&#x67;&#105;&#116;&#101;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a>:fishmwei&#x2F;blog_code.git。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（40）-用户态库</title>
    <url>/2022/11/08/2022-20221108-userlib/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一段时间，主要在忙着给一个设备驱动设计并开发一个用户态库，并且在项目组里评审。期间，比较系统的学习了华为KAE加速库、Intel的QAT加速库的代码，时间很快两三周就过去了。</p>
<span id="more"></span>

<h1 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h1><p>用户态库，顾名思义就是在用户空间的调用的库。相对于内核模块而已，运行在用户态的，相对比较安全可控，修改调试更方便。用户态库直接对上层的应用提供接口，就比如我们经常使用的libc、sqlite之类的库。在物理形态上，用户态库包含头文件和一个静态库（或者动态库），我使用cmake编译安装到&#x2F;usr&#x2F;local目录下，同时创建一个pc文件到&#x2F;usr&#x2F;lib&#x2F;pkgconfig目录下使得pkg-config可以找到这个库。</p>
<p><img src="/images/202211/arch_userlib.png" alt="arch_userlib"></p>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>用户态库向应用提供基础的API，应用通过API的调用实现功能。</p>
<p>API分为管理API、功能API：</p>
<ul>
<li>管理API主要就是资源的申请释放接口，相关数据结构的初始化接口等</li>
<li>功能API就是实现了具体功能的API</li>
</ul>
<p>接口根据特定的粒度提供，也可以提供便捷的聚合接口（软件设计模式中的门面模式）。</p>
<h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>在具体实现上面，接口除了通过读写映射内存实现功能外，主要的功能就是参数校验，并根据硬件的特性进行特殊的适配操作。</p>
<p>具体到代码上的实现，就是要做到尽量的简洁高效了。例如，使用数组的形式替换冗长的Switch-case和if-else。结构的定义尽量使得数据以2的幂次大小对齐，多用位操作替换模、除等操作。</p>
<p>另外就是要易于使用、易于调试了。</p>
<p>通过cmake工具直接将编译后库和头文件安装到系统中，使得应用开发者可以很容易的集成使用。</p>
<p>易于调试，就需要有方便的日志工具，我就是把之前写的clog日志文件集成进去了。</p>
<p>另外需要考虑的就是整个流程的连贯，并考虑另外的一些功能性需求了(支持多进程、资源互斥等)。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>除了工作任务外，领导还安排了两个新人让我带。都是不省油的灯啊， 一个刚毕业一年多的A，一个工作了4年的B。前面他们两个在另外的同事指导下，结果没有什么产出，领导感觉他们的能力没有得到发挥，然后就换给我带了。下面分别聊聊这两人的情况。</p>
<p>刚工作一年的A呢，属于要躺平的类型了，每天来的挺早的，下班也很准点。是对技术没有什么追求的一个人，就只想做和尚敲钟的。前面在同事的指导下，主要任务就是学习。学习完了呢，没有任务就在摸鱼了。问他业余有没有看些技术书的，答曰：“上班都没事干，回家更不会去搞技术了，有任务了再学习吧，反正技术都够用，需要的时候再学啊”。然而，在做工作汇报(就是新人在组内讲讲自己做了什么工作)的时候，讲的也不好，就是抓不到重点，不懂得总结提炼，光贴了一堆代码在那儿讲。可爱的是，遇到问题竟然还说不知道那些是问题。同事让其验证个功能，然后代码在某个版本的内核系统上面编译不了了，就不去解决了，没有去找到具体的解决方案，然后就放那儿不管了，验证的活就卡在那了。不是一个死磕技术的主。</p>
<p>工作四年的B呢，前面也安排学习一个项目的代码和材料。然后，领导让他设计一个方案，后面拖拖拉拉的难产了，做工作汇报时，很多内容也不能讲个所以然来。前面带的同事觉得他技术是不行的，我现在是深有同感了。</p>
<p>苦逼的事情就来了，我安排A去看个小模块，后面找他了解进展的时候很有自信的都学完了，结果问了几个问题都答不上来，结果说是只看了一个文件，然后就去问那个文件的内容，又是很多不知道的，只知道流程，细节都没深入。再安排A去给一个测试程序加个选项，然后换个接口测试下功能，卡了一两天硬是没进展。</p>
<p>B呢，更糟糕，让他看数据手册验证一个功能，脑袋就是不开窍，没看明白是什么东西。我就耐心给他的画了图，讲了一遍，说是理解了。过了两天去看，写出来的代码还是错误的，完全不搭边。更可怕的是，我发现他连简单的C语言的变量和指针都搞不清楚。给一个变量赋值之后，又从另外的地方拷贝内存到这个变量中去，哎，不知道他写的什么东西。代码不符合基础的编码规范，还在头文件里面放变量定义，放一些static的函数声明，真的是毁了我的三观。不知道他这工作四年是怎么混过来的。后面我自己写了一个函数，让他照着改改其他函数，结果还是写的一塌糊涂，真的是基础不行啊，没救了。</p>
<p>跟领导反应了这些问题，哎，让我把他们当应届生看吧。但是，他们的水平真的还不如应届生啊，A的态度也不如应届生! </p>
<p>没办法了，毕竟是领导招的人嘛，总不会裁掉打自己脸吧~</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（41）- 对称算法模式</title>
    <url>/2022/11/20/2022-20221120-algmode-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算法类型定义算法加密的数学实现（如明文块的长度，如何对明文密文进行加解密），算法模式则定义具体类型中加密的流程细节（例如加密的轮数、如何操作加解密的输入输出）。</p>
<span id="more"></span>

<p>对称算法根据明文的加密方式分成了流算法和分组算法。</p>
<ul>
<li>流算法一次加密明文中的一个位，解密也是按位解密的。主要的有祖冲之算法和SNOW3G算法，主要用于5G场景，由于5G场景中空口带宽比较珍贵，计算粒度到位。</li>
<li>分组算法一次加密明文中的一个块，不同的算法块长度可以不一样，具体可以体现在算法的名称中，如AES-128-CBC。</li>
</ul>
<h1 id="算法模式"><a href="#算法模式" class="headerlink" title="算法模式"></a>算法模式</h1><p>对于分组算法，如果直接对明文块进行加密，如果不同的块内容一样，会导致加密出来的密文也都是一样的，比较容易被破译。为了处理这种问题，就引入了算法模式，给不同块的输入增加一些盐值，这样即使块的内容一样，由于盐值不一样，加密出的密文也会不一样。不同的算法模式，根据盐值如何产生，及模块加密的流程分为了ECB、CBC、CFB、OFB、CTR模式。</p>
<h2 id="电子编码簿（ECB）模式"><a href="#电子编码簿（ECB）模式" class="headerlink" title="电子编码簿（ECB）模式"></a>电子编码簿（ECB）模式</h2><p>ECB模式是最简单的模式，也是最基础的模式。ECB模式没有盐值，直接将明文消息分成64位块，然后单独加密每个块。所有的块使用相同的密钥进行加密。如果原文中有多个相同的明文块，那么也会产生多个相同的密文块。</p>
<p><img src="/images/202211/ECB.png" alt="ECB"></p>
<p>这种模式适合那些短消息加密，明文重复概率比较小。</p>
<h2 id="加密块链接（CBC）模式"><a href="#加密块链接（CBC）模式" class="headerlink" title="加密块链接（CBC）模式"></a>加密块链接（CBC）模式</h2><p>CBC模式为了解决ECB模式的相同明文块加密得到相同密文块的问题。通过使用反馈的形式，把上一块的加密结果反馈到当前块的加密中，当前块的加密跟前面所有块的加密结果都相关，这样就可以使得相同明文块加密得到不同的密文块。第一个明文块则跟一个随机的文本（初始向量）相关,第一个密文块作为第二个明文块的初始向量，以此类推。</p>
<p><img src="/images/202211/CBC.png" alt="CBC"></p>
<p>CBC模式下加密有三个重要的相关项： 初始向量、密钥、明文消息。每个块的初始向量不一样，但是加密的密钥是一样的。</p>
<h2 id="加密反馈（CFB）模式"><a href="#加密反馈（CFB）模式" class="headerlink" title="加密反馈（CFB）模式"></a>加密反馈（CFB）模式</h2><p>前面两种模式都是按块加密的，但不是所有的应用都适用块加密。这时候就使用流加密或者CFB模式了，CFB模式加密数据可以使用更小的单元，比如8位，小于块的长度（64位）。</p>
<p>CFB模式一次处理8位，流程相对前面两种更复杂一些。</p>
<p>1、CFB模式也采用64位的初始化向量，通过加密方式得到加密后的向量。</p>
<p><img src="/images/202211/CFB1.png" alt="CFB1"></p>
<p>2、加密后的向量的前j位和明文异或，产生j为密文C，把C发送给接收方。<br><img src="/images/202211/CFB2.jpg" alt="CFB2"></p>
<p>3、加密后的向量左移j位，并把第二步得到的C填充到最右边的j位。</p>
<p><img src="/images/202211/CFB3.png" alt="CFB3"></p>
<p>4、重复1-3步，一直到加密完所有的明文数据。<br><img src="/images/202211/CFB4.jpg" alt="CFB4"></p>
<h2 id="输出反馈（OFB）模式"><a href="#输出反馈（OFB）模式" class="headerlink" title="输出反馈（OFB）模式"></a>输出反馈（OFB）模式</h2><p>OFB模式跟CFB模式很像，CFB模式是把密文填入下一个阶段的向量低8位，而OFB是把向量加密的结果填入下一阶段的向量低8位。这样一来，OFB的加密结果跟前一个明文无关，跟IV相关。而CFB的加密结果跟前一个明文和IV都是相关的。</p>
<p><img src="/images/202211/OFB.jpg" alt="OFB"></p>
<h2 id="计数器-CTR-模式"><a href="#计数器-CTR-模式" class="headerlink" title="计数器(CTR)模式"></a>计数器(CTR)模式</h2><p>CTR模式各个块的IV采用一个计数器值，计数加密之后再和明文异或得到密文。计数块的大小等于明文块的大小。</p>
<p><img src="/images/202211/CTR.jpg" alt="CTR"></p>
<p>CTR模式可以并行地计算多个块，因为输入跟前面的明文没有什么关系。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>加密模式还有一种xts，具体带学习后再小结。模式比较多，又很相似，刚开始看很容易混淆，后面慢慢地熟悉了就好了吧。</p>
<h1 id="更多1"><a href="#更多1" class="headerlink" title="更多1"></a>更多1</h1><p>今年小组扩张的比较猛，从年初的5人扩充到了14人。人多了，就有很多人比较闲。后面招的基本都是应届生或者工作三年以下的，应届生就不用说了，基本等于白纸。工作几年的那几个呢，我感觉都不是技术爱好者，仅仅是工作糊口而已。</p>
<p>人多了，问题也就多了。当然，这些问题主要还是因为大家没有很强的责任心导致的。联调一个功能，遇到问题了，不去积极解决问题，而是在互相推诿。A和B联调，A遇到问题了，首先自身没有深入定位，直接就去找B了。而B呢，直接说代码不是他写的，他没有改过，让找C。C又是说代码已经移交个B，又让找B。真的好扯，都是一个组的，代码就在那，都不愿意自己gdb去看看，总想着推脱责任，好无语。</p>
<p>另外，很多工作并没有比较明确的时间点，有些也没有明确的目标，大家都在磨洋工啊。技术不好的也不想着提升技术，团队就是个散沙，然后有事情了又是拉几个老员工顶上去。呵呵。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（42）- XTS算法模式</title>
    <url>/2022/12/01/2022-20221201-aes-xts-weekly/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一次了解了对称算法的基本模式ECB&#x2F;CBC&#x2F;CFB&#x2F;OFB&#x2F;CTR，今天学习一下xts模式。</p>
<span id="more"></span>

<h1 id="xts模式"><a href="#xts模式" class="headerlink" title="xts模式"></a>xts模式</h1><p>xts模式用于磁盘加密，对于磁盘数据都是按扇区存储的，不希望有额外的空间存储前面那些模式需要的IV向量，而且任意块都应该是可以随时加解密的，块(扇区)之间不应该有相关性。当然，我们也不能用ECB模式，这个是不安全的，容易被分析出来。后面就有人提出了可调整的分组密码算法，除了key和明文外，又引入了tweak值，这个tweak是可以调整的，不同的tweak会导致加密的结果不同（其实也是一个salt）。</p>
<h2 id="加密一个块的流程："><a href="#加密一个块的流程：" class="headerlink" title="加密一个块的流程："></a>加密一个块的流程：</h2><p><img src="/images/202212/xts_tweak.png" alt="xts_tweak"></p>
<p>公式表示就是：<code>C ← XTS-AES-blockEnc(Key, P, i, j)</code></p>
<p>xts模式有两个密钥K1|K2，一个用于调整tweak， 另外一个用于分组加密。<br>P是一个128bit的明文块<br>i是一个128bit的tweak值<br>j是这个块在数据单元中的索引<br>C是这个块加密后的密文</p>
<p>1、 tweak使用密钥K2进行AES加密(ECB模式， 不需要iv），结果进行一个有限域数aj的乘运算，得到T<br>2、T跟明文块P异或得到PP<br>3、PP再使用K1进行AES加密得到CC<br>4、CC再和1中的T异或得到最终的密文C</p>
<h2 id="加密一个数据单元的流程"><a href="#加密一个数据单元的流程" class="headerlink" title="加密一个数据单元的流程"></a>加密一个数据单元的流程</h2><p>一个数据单元包含多个数据块。<br>公式表示：<code>C ← XTS-AES-Enc (Key, P, i) </code><br>Key， P, i含义跟上面一样。</p>
<p>一个明文P分成m+1个明文块 <code>P = P0 |… |Pm−1|Pm</code>, 128*m &lt; P的位数， 前0-m-1块长度都是128bit， 最后一块为0-127bit。</p>
<p>前面0 ~ m-2 块直接计算： <code>Cq ← XTS-AES-blockEnc(Key, Pj, i, q)</code></p>
<p>最后两块的加密特殊一些<br>1、当最后一块长度为0时，<br><code>Cm-1 ← XTS-AES-blockEnc(Key, Pm-1, i, m-1)</code><br><code>Cm为空</code></p>
<p>2、最后一块长度不为0时，<br><code>a) CC ← XTS-AES-blockEnc(Key, Pm-1, i, m-1)</code> 先根据第m-1计算加密密文 CC<br><code>b) Cm ← first b bits of CC</code> 取出CC中的前b个字节作为第m块的加密密文<br><code>c) CP ← last (128-b) bits of CC</code> 取CC的后128-b bit得到CP<br><code>d) PP ← Pm | CP </code>CP和Pm组成PP<br><code>e) Cm-1 ← XTS-AES-blockEnc(Key, PP, i, m)</code> 计算Cm-1</p>
<p>最后汇总所有的密文。</p>
<p><img src="/images/202212/xts_aes_m1127.png" alt="xts_aes_enc"></p>
<h2 id="解密一个块的流程"><a href="#解密一个块的流程" class="headerlink" title="解密一个块的流程"></a>解密一个块的流程</h2><p><img src="/images/202212/xts_dec_block.png" alt="xts_aes_enc"></p>
<p>解密跟加密基本一样，就是明文和密文对调一下。</p>
<h2 id="解密一个数据单元的流程"><a href="#解密一个数据单元的流程" class="headerlink" title="解密一个数据单元的流程"></a>解密一个数据单元的流程</h2><p>解密数据单元跟加密数据单元也是相同的。同样的最后两块也是特殊处理一下。</p>
<p><img src="/images/202212/xts_aes_decm1127.png" alt="xts_aes_decm1127"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>tweak加密后会作一个什么有限域的运算aj， 这个aj的是怎么来的呢？ 有限域运算又是啥呢，最终还是没有搞懂。 </p>
<p>内核的linux kernel crypto 的源码需要认真的读一读。</p>
<p>参考资料：</p>
<p><a href="https://new.qq.com/rain/a/20220305A08CQ500">https://new.qq.com/rain/a/20220305A08CQ500</a></p>
<p><a href="http://libeccio.di.unisa.it/Crypto14/Lab/p1619.pdf">http://libeccio.di.unisa.it/Crypto14/Lab/p1619.pdf</a></p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>年底了， 公司通知剩余的年假赶紧休掉，否则年底统一清零，要跨年的需要特殊申请。今年3月份入职的，折算一下有八天年假，领导让休假那就休假吧。年假只算工作日，那么我就连续休息11天啦。到今天算是第六天了， 过半了。脑袋也放空了5天了，接下来的时间得看点东西了。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>AES算法</title>
    <url>/2022/12/02/2022-20221202-aes/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>AES是目前最常见的一种对称算法， AES是一种分组算法，所有的数据都按块进行加密，AES的数据块大小为16字节（128bit）， 但是AES的密钥有128&#x2F;192&#x2F;256bits三种，密钥的长度不同的话，加密的轮数有差异。</p>
<span id="more"></span>

<p>比如AES128算法，会进行10次轮运算，也就是一个分组数据会被加密10次。</p>
<h1 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>AES算法每个分组长度为128bit，即16字节。这16个字节组成一个4X4的矩阵。在算法的每一轮中，矩阵的内容都在变化，直到最后的结果作为密文。<br><img src="/images/202212/aes_block.png" alt="aes_block"></p>
<p>类似地，128bit的密钥也用字节表示成矩阵，通过密钥的编排函数矩阵扩展为一个44个字的序列<code>W[0-43]</code>。前4个字是原始的密钥， 后面的40个字分别为每一轮运算的密钥。</p>
<p><img src="/images/202212/aes_keys.png" alt="aes_keys"></p>
<p>AES算法的整体流程如下:</p>
<p><img src="/images/202212/aes_flow.png" alt="aes_flow"></p>
<p>1、在第一轮之前，使用原始密钥对明文进行一次异或<br>2、第1~9轮的处理一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。<br>3、第10轮：字节代换、行位移、轮密钥加。</p>
<p>AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。</p>
<p>参考资料： <a href="https://blog.csdn.net/qq_28205153/article/details/55798628">https://blog.csdn.net/qq_28205153/article/details/55798628</a></p>
<h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p>分组算法每次输入都是固定长度的数据，如果数据总长度不是分组长度的整数倍，那么最后一块分组数据就需要在后面填充数据，补齐分组长度。</p>
<p>根据怎么对明文进行填充，分为3种方式：</p>
<ul>
<li>NoPadding 不填充，那么就是不支持数据长度不是分组长度倍数的数据， 对AES就必须是128bit的倍数</li>
<li>PKCS5Padding （默认） 在明文块后面填充响应数量的字符，每个字符的值等于缺少的字符数。 如10个字节， 后面的6个字节都填6.</li>
<li>ISO10126Padding 最后一个字符填充成缺少的字符数， 其他的随机。</li>
</ul>
<h2 id="密钥长度"><a href="#密钥长度" class="headerlink" title="密钥长度"></a>密钥长度</h2><p>不同密钥长度的算法，进行的轮数不一样。 AES128 10轮， AES192 12轮， AES256 14轮。运算的逻辑都一样。具体的运算细节不深入了。</p>
<p>加密都是按块加密，每个块128位即16字节。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>周谈（43）- 消息验证码(MAC)算法</title>
    <url>/2022/12/05/2022-20221205-weekly-mac/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MAC算法用于验证消息的正确性， 通信的双方根据共享的密钥，分别对消息进行计算。发送方发送原始消息+计算结果A，接收方接收到消息后，也对消息进行计算得到计算结果B，并对比A和B来判断消息是否完整正确。</p>
<span id="more"></span>
<p>消息认证码加密使用两种方法， 一种是基于散列函数实现，另一种是基于分组密码实现。</p>
<h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p>基于散列实现的称为HMAC(Hash Message Authentication Code)。</p>
<p>原始消息经过散列函数计算得到摘要， 摘要和密钥作用生成最终的认证码。发送方把消息和认证码发送出去，接收方也是用相同的散列函数记得得到摘要2，摘要2和密钥作用生成认证码，对比两个认证码来判断消息是否被篡改。</p>
<p>HMAC包含几个输入量：</p>
<p>散列函数MD、原始消息M、消息M的块数、每块的位数b、密钥K和<br>ipad&#x2F;opad 00110110, 01011010重复b&#x2F;8次。</p>
<h2 id="CBCMAC"><a href="#CBCMAC" class="headerlink" title="CBCMAC"></a>CBCMAC</h2><p>基于分组算法密码实现，对消息使用CBC模式进行加密，取密文的最后一块作为认证码。如果使用的是AES加密，那就是AES的CBC-MAC。</p>
<p>首先对消息进行分组和填充，然后进行分组链接加密。</p>
<p><img src="/images/202212/cbc_mac.png" alt="cbc_mac"></p>
<h2 id="CMAC"><a href="#CMAC" class="headerlink" title="CMAC"></a>CMAC</h2><p>CMAC（Cipher Block Chaining-Message Authentication Code），也简称为CBC_MAC，它也是一种基于对称秘钥分组加密算法的消息认证码。</p>
<p>CMAC算法通过密钥派生出两个子秘钥，然后对最后的一个块作处理，再使用CBC模式加密数据，取最后一个块的高n为作为MAC。</p>
<p>参考链接：<a href="https://blog.csdn.net/KXue0703/article/details/119522934">https://blog.csdn.net/KXue0703/article/details/119522934</a></p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>稍微过一下mac的实现方式，有个粗略的记忆。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>2020书单</title>
    <url>/2020/01/01/2020-20200101-2020books/</url>
    <content><![CDATA[<h1 id="2020书单"><a href="#2020书单" class="headerlink" title="2020书单"></a>2020书单</h1><p>人不读书要落后，每年都需要读一些书来支持自我提升。电子书也好、实体书也好、亦或者是极客时间&#x2F;知乎上的专栏都可以纳入，看完之后，对应写一篇读后感总结之类的文章。书籍可以是新书，也可以是读过的书，不论是增长见识、还是温故而知新都是不错的体验。主要是要保证自己坚持写博客。</p>
<h2 id="书单列表"><a href="#书单列表" class="headerlink" title="书单列表"></a>书单列表</h2><ul>
<li>[x]《数学之美》 实体书 </li>
<li><input checked="" disabled="" type="checkbox"> 《C程序设计语言》 实体书 2020.05-06 <a href="/2020/06/22/reflection4c/">读后感</a> </li>
<li><input checked="" disabled="" type="checkbox"> 《程序员的自我修养》 实体书 2020.06 </li>
<li><input disabled="" type="checkbox"> 《Linux命令行与shell脚本编程大全》实体书 </li>
<li><input checked="" disabled="" type="checkbox"> 《明朝那些事儿》 微信读书电子书 2020.04.19读完 </li>
<li><input disabled="" type="checkbox"> 巨人三传 &#x2F;&#x2F; 贝多芬传、米开朗基罗传、托尔斯泰传</li>
</ul>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>书单</category>
      </categories>
  </entry>
  <entry>
    <title>二进制包大小优化思路</title>
    <url>/2020/06/09/2020-20200609-tiny-program/</url>
    <content><![CDATA[<p>对于嵌入式开发这种对空间要求比较苛刻的环境，对程序包的大小还是比较敏感的。一来， 可以节省空间。二来，在一定程度上可以减少页错误导致的载入载出，提升程序的性能。第三，对一些低速网络(比如：zigbee)连接的设备，提升OTA升级的效率。</p>
<p>可执行文件都是elf格式的， 文件都是由各个段组成的，对文件大小的优化就可以归结为各个段的优化。<br>第一，可以去掉执行时不需要的段，比如：release版本不需要调试信息、符号表等， 可以直接strip掉。 第二，还可以缩小一些段的内容，比如代码段。通过优化合并代码，减少重复代码。数据段，对于一些全局变量，定义的时候可以不进行初始化，在程序启动的时候初始化，使得这些全局变量放到bss段，不占用程序大小。只读的数据段，主要是一些字符串、const等不可变量。在发布的时候，通过宏控制删除大部分无用的调试信息，仅保留必要的错误日志的信息输出，这样可以减少只读数据段的大小。这个是单个文件的优化思路。</p>
<p>对于同时运行不同程序的平台，可以使用动态库，共享基础库。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>todo</title>
    <url>/2020/02/13/2020-20200213-todo/</url>
    <content><![CDATA[<h1 id="2021-TODO列表"><a href="#2021-TODO列表" class="headerlink" title="2021 TODO列表"></a>2021 TODO列表</h1><span id="more"></span>

<ul>
<li><input disabled="" type="checkbox"> 内核模块编写</li>
<li><input disabled="" type="checkbox"> socket</li>
<li><input disabled="" type="checkbox"> 线程创建</li>
<li><input disabled="" type="checkbox"> tcpdump</li>
<li><input disabled="" type="checkbox"> makefile使用</li>
<li>[ ]</li>
</ul>
<h1 id="2020年-TODO列表"><a href="#2020年-TODO列表" class="headerlink" title="2020年 TODO列表"></a>2020年 TODO列表</h1><h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h2><ul>
<li><input disabled="" type="checkbox"> socket</li>
<li><input disabled="" type="checkbox"> 线程创建</li>
</ul>
<h2 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h2><ul>
<li><input checked="" disabled="" type="checkbox"> sed命令使用</li>
<li><input checked="" disabled="" type="checkbox"> awk命令使用</li>
<li><input checked="" disabled="" type="checkbox"> grep命令使用</li>
<li><input disabled="" type="checkbox"> tcpdump</li>
</ul>
<h2 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h2><ul>
<li><input disabled="" type="checkbox"> makefile使用</li>
<li><input checked="" disabled="" type="checkbox"> coredump</li>
<li><input checked="" disabled="" type="checkbox"> 包大小</li>
</ul>
<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><ul>
<li><input disabled="" type="checkbox"> radius</li>
<li><input disabled="" type="checkbox"> lldp</li>
<li><input disabled="" type="checkbox"> mpls</li>
<li><input disabled="" type="checkbox"> sctp</li>
<li><input disabled="" type="checkbox"> ppp</li>
<li><input disabled="" type="checkbox"> pppoe</li>
<li><input disabled="" type="checkbox"> ip相关</li>
<li><input disabled="" type="checkbox"> ah协议</li>
<li><input disabled="" type="checkbox"> gre</li>
<li><input disabled="" type="checkbox"> gtp</li>
<li><input disabled="" type="checkbox"> hdlc</li>
<li><input disabled="" type="checkbox"> teredo</li>
<li><input disabled="" type="checkbox"> 报文分片</li>
<li><input disabled="" type="checkbox"> TCP&#x2F;UDP系列？</li>
</ul>
<h2 id="开发经验-x2F-想法"><a href="#开发经验-x2F-想法" class="headerlink" title="开发经验&#x2F;想法"></a>开发经验&#x2F;想法</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 单例重构</li>
<li><input disabled="" type="checkbox"> 关于看书的经验</li>
<li><input checked="" disabled="" type="checkbox"> getopt，C命令行参数</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><input disabled="" type="checkbox"> 正则表达式</li>
</ul>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>一次被坑的惨痛经历</title>
    <url>/2020/01/19/2020-20200119-problem/</url>
    <content><![CDATA[<p>事情是这样的，项目在同一个系统下运行着2个程序A和B，A由同事负责，B由我负责。 A和B会有共享的一块内存， 内存主要分成几种情况：</p>
<ul>
<li>由A填写， B来读取</li>
<li>由B填写， A来读取</li>
<li>B自己读写</li>
<li>A自己读写</li>
</ul>
<p>各部分内存没有机制保证被合法读写， 只能通过代码写入的地址保证。 这种情况下， 应该各自封装接口，对地址越界的情况进行判断，然后通过接口调用，这样才能保证内存的安全访问。</p>
<span id="more"></span>

<p>然后，问题是这样的，程序在开启某个功能的时候， B程序肯定就会崩溃。 通过调用栈分析，是由于某个全局指针变量的内容被改写了， 然后程序使用错误的地址访问内存，导致崩溃。通过B程序代码的各种分析，也无法查到任何内存会被改写的情况。和组内另一个资深员工，分析了很多场景都无法搞清楚问题的原因。甚至祭出了回滚代码，二分查找问题的土方法了， 竟然发现很早之前的代码也存在问题，实在是匪夷所思。就这样过了快一周，惭愧还是没有头绪。最后我翻出了系统手册，分析了内存之间的使用关系，才开始怀疑是A程序导致的问题， 回滚A程序的代码，发现问题没有了。通过GDB断点A程序写内容的函数，证实是A程序地址计算错误，往B程序使用内存写入内容导致问题的。就是这么一个缺乏入参判断的接口，导致了这么一个无厘头的问题，还搭上了大概2人周的时间去定位，真的是代价巨大。</p>
<p>为什么会花费这么长时间才会定位出问题呢？</p>
<ol>
<li>刚接触项目，我对系统的内存使用情况不清晰</li>
<li>资深老员工对系统的内存机制也不了解？ 以往的经验诱导了他使用代码定位问题，没有从根本上分析问题。</li>
</ol>
<p>为什么会出现这么低级的错误？</p>
<ol>
<li>A程序由一个刚毕业的同事负责，对代码要求不高，经验欠缺。自己的功能都没有测试，内容写错地址了都不知道。。。</li>
<li>A程序代码入库没有四眼检视，但凡有一个稍有经验的人进行代码检视，这种低级问题应该是可以被拦截在此阶段的。</li>
<li>A程序地址写内容的接口不健壮，缺少基本的入参判断， 历史的锅？</li>
</ol>
<p>终于，问题是解决了，但是不知道未来还有多少坑。要锻造出健壮的代码，和程序员的编程素质相关，跟公司的开发流程相关。程序员需要对系统机制了解的足够深透，实现的功能需要通过充分的自测才跟他人联调，代码入库一定需要四眼检视。</p>
<p>在以往的公司，这些都是基本的流程，然而，以往终究是以往，自己还是需要保持好这些习惯。遇事要敢于怀疑别人。。。 呵呵~</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>开发经验</tag>
      </tags>
  </entry>
  <entry>
    <title>C程序的命令行参数处理函数getopt</title>
    <url>/2020/06/13/2020-20200613-c-command/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>工作中，存在着这么一个问题。开发提供给测试的二进制版本，都是记录在一个excel表中，保存着对应版本的提测日期和文件的Md5值、以及对应的svn标签信息。但是，文件这种东西，是需要靠人来填写的。许多临时的版本，就没有记录了。经常出现测试的文件找不到对应的记录，不知道是何时提供、解决了什么问题。 那么，就有这么个需求，把对应的信息保存到二进制文件，在编译的时候，获取编译的时间，svn版本号，编译机器的用户名(一般可以对应到开发人员)等信息，自动生成源代码文件，记入编译文件。然后，还需要提供一种方式读取这些信息，让二进制文件支持参数处理是一个不错的方式。</p>
<span id="more"></span>

<p>之前代码中有一些可变的配置也是可以通过运行时入参实现的，已经有对参数的处理代码了，不过是通过手动解析argv入参的，方式比较粗暴。远没有系统提供的getopt函数优雅，我们要做一个有追求的程序员，改!</p>
<h1 id="自动获取编译信息"><a href="#自动获取编译信息" class="headerlink" title="自动获取编译信息"></a>自动获取编译信息</h1><p>首先在makefile中通过执行shell脚本把编译信息获取到生成信息文件。 这里自动生成了一个version.h文件。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main: version.h main.c</span><br><span class="line">	gcc main.c -o main</span><br><span class="line"></span><br><span class="line"># 生成version.h文件</span><br><span class="line">version.h:</span><br><span class="line">	sh ./genversion.sh</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	@rm -fr main version.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">FILENAME=./version.h</span><br><span class="line"></span><br><span class="line">echo &#x27;#ifndef _VERSION_H_&#x27;&gt;$FILENAME</span><br><span class="line">echo &#x27;#define _VERSION_H_&#x27;&gt;&gt;$FILENAME</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">build_date=`date +&quot;%k:%M:%S %m-%d-%Y&quot;`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;#define BUILD_DATE  \&quot;$&#123;build_date&#125;\&quot;&quot;&gt;&gt;$FILENAME</span><br><span class="line">echo &quot;#define BUILD_LINUX_USER \&quot;$&#123;USER&#125;\&quot;&quot;&gt;&gt;$FILENAME</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &#x27;#endif&#x27;&gt;&gt;$FILENAME</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="命令行参数处理"><a href="#命令行参数处理" class="headerlink" title="命令行参数处理"></a>命令行参数处理</h1><h2 id="头文件及内容说明"><a href="#头文件及内容说明" class="headerlink" title="头文件及内容说明"></a>头文件及内容说明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span>  </span></span><br><span class="line"><span class="comment">// linux 一般在系统的 /usr/include/getopt.h</span></span><br><span class="line"><span class="comment">// mac 在 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/getopt.h  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>contents:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GETOPT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GETOPT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/cdefs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * GNU-like getopt_long()/getopt_long_only() with 4.4BSD optreset extension.</span></span><br><span class="line"><span class="comment"> * getopt() is declared here too for GNU programs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> no_argument        0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> required_argument  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> optional_argument  2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> &#123;</span></span><br><span class="line">	<span class="comment">/* name of long option */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * one of no_argument, required_argument, and optional_argument:</span></span><br><span class="line"><span class="comment">	 * whether option takes an argument</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> has_arg;</span><br><span class="line">	<span class="comment">/* if not NULL, set *flag to val when option found */</span></span><br><span class="line">	<span class="type">int</span> *flag;</span><br><span class="line">	<span class="comment">/* if flag not NULL, value to set *flag to; else return value */</span></span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"><span class="type">int</span>	<span class="title function_">getopt_long</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> * <span class="type">const</span> *, <span class="type">const</span> <span class="type">char</span> *,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="keyword">struct</span> option *, <span class="type">int</span> *)</span>;  <span class="comment">// 只处理 --prefix 和短选项</span></span><br><span class="line"><span class="type">int</span>	<span class="title function_">getopt_long_only</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> * <span class="type">const</span> *, <span class="type">const</span> <span class="type">char</span> *,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="keyword">struct</span> option *, <span class="type">int</span> *)</span>;  <span class="comment">// 处理 --prefix , -prefix 和短选项</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GETOPT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	_GETOPT</span></span><br><span class="line"><span class="type">int</span>	 <span class="title function_">getopt</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> * <span class="type">const</span> [], <span class="type">const</span> <span class="type">char</span> *)</span> __<span class="title function_">DARWIN_ALIAS</span><span class="params">(getopt)</span>; <span class="comment">// 只处理 -a 短选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *optarg;			<span class="comment">/* getopt(3) external variables */</span> <span class="comment">// 指向当前选项的参数 如果没有则为NULL</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> optind, opterr, optopt; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">optind —— 再次调用 getopt() 时的下一个 argv指针的索引。</span></span><br><span class="line"><span class="comment">optopt —— 最后一个未知选项。</span></span><br><span class="line"><span class="comment">opterr ­—— 如果不希望getopt()打印出错信息，则只要将全域变量opterr设为0即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _OPTRESET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	_OPTRESET</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> optreset;			<span class="comment">/* getopt(3) external variable */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__END_DECLS</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !_GETOPT_H_ */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="option结构"><a href="#option结构" class="headerlink" title="option结构"></a>option结构</h2><p>用来配置长选项，可以设置对应的短选项，是否有参数。 短选项最好添加到optstring里</p>
<h2 id="optstring"><a href="#optstring" class="headerlink" title="optstring"></a>optstring</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *optstring = “ab:c::”;</span><br><span class="line">单个字符a         表示选项a没有参数            格式：-a即可，不加参数</span><br><span class="line">单字符加冒号b:     表示选项b有且必须加参数      格式：-b 100或-b100,但-b=100错</span><br><span class="line">单字符加2冒号c::   表示选项c可以有，也可以无     格式：-c200 其它格式错误</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>如果所有命令行选项都解析完毕，返回 -1；<br>如果选项成功找到，返回选项字母(长选项返回对应短字母)；如果遇到选项字符不在 optstring 中，且在长选项也找不到，返回字符’?’; 如果遇到丢失参数，那么返回值依赖于 optstring 中第一个字符，如果第一个字符是 ‘:’ 则返回’:’，否则返回’?’并提示出错误信息。</p>
<p>针对长选项，如果不存在对应的短字母，可以参考使用 option_index来解析。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_LETTER   (1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_VALUE (0xFFFFFFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  reqargIndex = <span class="number">0</span>,</span><br><span class="line">  optargIndex,</span><br><span class="line">  noargIndex,</span><br><span class="line">  noletterIndex,</span><br><span class="line">  nullIndex</span><br><span class="line">&#125; <span class="type">option_index_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] =</span></span><br><span class="line">&#123;  </span><br><span class="line">    &#123;<span class="string">&quot;reqarg&quot;</span>, required_argument,<span class="literal">NULL</span>, <span class="string">&#x27;r&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;optarg&quot;</span>, optional_argument,<span class="literal">NULL</span>, <span class="string">&#x27;o&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;noarg&quot;</span>,  no_argument,         <span class="literal">NULL</span>,<span class="string">&#x27;n&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;noletter&quot;</span>, no_argument, <span class="literal">NULL</span>, NO_LETTER &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,     <span class="number">0</span>,                      <span class="literal">NULL</span>, NO_LETTER&#125;,</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a_val = INVALID_VALUE;</span><br><span class="line"><span class="type">int</span> b_val = INVALID_VALUE;</span><br><span class="line"><span class="type">int</span> c_val = INVALID_VALUE;</span><br><span class="line"><span class="type">int</span> d_val = INVALID_VALUE;</span><br><span class="line"><span class="type">int</span> r_val = INVALID_VALUE;</span><br><span class="line"><span class="type">int</span> o_val = INVALID_VALUE;</span><br><span class="line"><span class="type">int</span> n_val = INVALID_VALUE;</span><br><span class="line"><span class="type">int</span> no_letter = INVALID_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return 1: break, 0:continue</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setOption</span><span class="params">(<span class="type">int</span> opt, <span class="type">char</span> *optarg, <span class="type">char</span> *argv[], <span class="type">int</span> option_index)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(opt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (optarg) &#123;</span><br><span class="line">          a_val = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          a_val = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            b_val = atoi(optarg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        c_val = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        d_val = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (optarg) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;warnning:option d no require argument. ignore value %s\n&quot;</span>, optarg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            r_val = atoi(optarg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (optarg) &#123;</span><br><span class="line">          o_val = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          o_val = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;n‘:</span></span><br><span class="line"><span class="string">        n_val = 1;</span></span><br><span class="line"><span class="string">        if (optarg) &#123;</span></span><br><span class="line"><span class="string">          printf(&quot;warnning:option n no require argument. ignore value %s\n&quot;, optarg);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        break;</span></span><br><span class="line"><span class="string">      case NO_LETTER:</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            switch(option_index) &#123;</span></span><br><span class="line"><span class="string">            case  noletterIndex:</span></span><br><span class="line"><span class="string">              no_letter = 1;</span></span><br><span class="line"><span class="string">              break;</span></span><br><span class="line"><span class="string">            case  nullIndex:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">            default:</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        break;</span></span><br><span class="line"><span class="string">      default:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return 1;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#define showV(x)  printf(#x&quot;=%d\n&quot;, x)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void showValues() &#123;</span></span><br><span class="line"><span class="string">  printf(&quot;=========\n&quot;);</span></span><br><span class="line"><span class="string">  showV(a_val);</span></span><br><span class="line"><span class="string">  showV(b_val);</span></span><br><span class="line"><span class="string">  showV(c_val);</span></span><br><span class="line"><span class="string">  showV(d_val);</span></span><br><span class="line"><span class="string">  showV(r_val);</span></span><br><span class="line"><span class="string">  showV(o_val);</span></span><br><span class="line"><span class="string">  showV(n_val);</span></span><br><span class="line"><span class="string">  showV(no_letter);</span></span><br><span class="line"><span class="string">  printf(&quot;=========\n&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(int argc, char *argv[])</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    int opt;</span></span><br><span class="line"><span class="string">    int option_index = 0;</span></span><br><span class="line"><span class="string">    char *string = &quot;a::b:c:dr:o::n&quot;;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //initValues();</span></span><br><span class="line"><span class="string">    while((opt =getopt_long_only(argc,argv,string,long_options,&amp;option_index))!= -1)</span></span><br><span class="line"><span class="string">    &#123;  </span></span><br><span class="line"><span class="string">        printf(&quot;opt = %c\t\t&quot;, opt);</span></span><br><span class="line"><span class="string">        printf(&quot;optarg = %s\t\t&quot;,optarg);</span></span><br><span class="line"><span class="string">        printf(&quot;optind = %d\t\t&quot;,optind);</span></span><br><span class="line"><span class="string">        printf(&quot;argv[optind] =%s\t\t&quot;, argv[optind]);</span></span><br><span class="line"><span class="string">        printf(&quot;option_index = %d\n&quot;,option_index);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if (setOption(opt, optarg, argv, option_index)) &#123;</span></span><br><span class="line"><span class="string">            showValues();</span></span><br><span class="line"><span class="string">            return -1;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    showValues();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Keep:syscall keep$ ./a -reqarg 3  # 匹配长选项 带参数 -</span><br><span class="line">opt = r         optarg = 3              optind = 3              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ ./a --reqarg 3 # 匹配长选项 带参数 --</span><br><span class="line">opt = r         optarg = 3              optind = 3              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ ./a --reqarg # 不匹配长选项 带参数 --</span><br><span class="line">a: option `--reqarg&#x27; requires an argument</span><br><span class="line">opt = ?         optarg = (null)         optind = 2              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ ./a --optarg   # 匹配长选项 可选参数 --</span><br><span class="line">opt = o         optarg = (null)         optind = 2              argv[optind] =(null)            option_index = 1</span><br><span class="line">Keep:syscall keep$ ./a --optarg 9 # 不匹配长选项 可选参数 --</span><br><span class="line">opt = o         optarg = (null)         optind = 2              argv[optind] =9         option_index = 1</span><br><span class="line">Keep:syscall keep$ ./a --optarg=9 # 匹配长选项 可选参数 --</span><br><span class="line">opt = o         optarg = 9              optind = 2              argv[optind] =(null)            option_index = 1</span><br><span class="line">Keep:syscall keep$ ./a -optarg=9  # 匹配长选项 可选参数 -</span><br><span class="line">opt = o         optarg = 9              optind = 2              argv[optind] =(null)            option_index = 1</span><br><span class="line">Keep:syscall keep$ ./a -noarg 3   # 匹配长选项 无参数 -  跳过3</span><br><span class="line">opt = n         optarg = (null)         optind = 2              argv[optind] =3         option_index = 2</span><br><span class="line">Keep:syscall keep$ ./a -noarg 3 -optarg=9   </span><br><span class="line">opt = n         optarg = (null)         optind = 2              argv[optind] =3         option_index = 2</span><br><span class="line">opt = o         optarg = 9              optind = 4              argv[optind] =(null)            option_index = 1</span><br><span class="line">Keep:syscall keep$ ./a -a999    # 匹配短选项 可选参数 -</span><br><span class="line">opt = a         optarg = 999            optind = 2              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ ./a -a=999  # 匹配短选项 可选参数 错误 -</span><br><span class="line">opt = a         optarg = =999           optind = 2              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ ./a -b999  # 匹配短选项 带参数 -</span><br><span class="line">opt = b         optarg = 999            optind = 2              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ ./a -b=999 # 匹配短选项 带参数 错误 -</span><br><span class="line">opt = b         optarg = =999           optind = 2              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ ./a -a=999</span><br><span class="line">opt = a         optarg = =999           optind = 2              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ </span><br><span class="line">Keep:syscall keep$ ./a -b 999</span><br><span class="line">opt = b         optarg = 999            optind = 3              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ </span><br><span class="line">Keep:syscall keep$ ./a -o=999</span><br><span class="line">opt = o         optarg = =999           optind = 2              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ ./a -o999</span><br><span class="line">opt = o         optarg = 999            optind = 2              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ ./a -o999 -n</span><br><span class="line">opt = o         optarg = 999            optind = 2              argv[optind] =-n                option_index = 0</span><br><span class="line">opt = n         optarg = (null)         optind = 3              argv[optind] =(null)            option_index = 0</span><br><span class="line">Keep:syscall keep$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>使用getopt_long_only时，会自动最长前缀匹配，存在唯一长选项时，即使没有敲全命令 也认为是匹配上了。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">./a  -hel  会自动匹配到help选项</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>使用getopt_long时，会自动按字符依次匹配。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">./a  -hel  分配按序匹配 h , e, l 三个字符</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>代码参考： </p>
<p><a href="https://github.com/fishmwei/blog_code/tree/master/getopt">https://github.com/fishmwei/blog_code/tree/master/getopt</a></p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>结构体偏移</title>
    <url>/2020/06/17/2020-20200617-memberoffsetof/</url>
    <content><![CDATA[<h1 id="结构体偏移"><a href="#结构体偏移" class="headerlink" title="结构体偏移"></a>结构体偏移</h1><p>项目通过定义union联合体使用同一块内存， 在代码运行的不同阶段访问具体的成员。针对一些希望跨阶段存在的数据在不同的结构中保持了一份相同的成员，保证在不同的阶段都可以方便的访问到该内容。要实现这样的目的，必须使各个结构中的相同成员在整个联合体的偏移是一样的。</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构如下：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regionA</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="type">char</span> globalData[<span class="number">30</span>]; <span class="comment">// 各个阶段共用的，不希望被覆盖的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regionB</span>&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">8</span>];</span><br><span class="line">  <span class="type">char</span> globalData[<span class="number">30</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regsionC</span>&#123;</span></span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">char</span> resv[<span class="number">7</span>];</span><br><span class="line">  <span class="type">char</span> globalData[<span class="number">30</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sharedRegion</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">regionA</span> <span class="title">areaA</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">regionB</span> <span class="title">areaB</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">regionC</span> <span class="title">areaC</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之前都是通过人工手动计算保证globalData在各个结构中的偏移保持不变。 针对简单的结构可以算出来，复杂一点的就容易出错了，因此，我们需要一种方式保证偏移的准确性。默认头文件sys&#x2F;_types.h中提供了 __builtin_offsetof的实现，可以支持快速计算成员的偏移.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) &amp;&amp; (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 5 || __GNUC__ &gt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __offsetof(type, field) __builtin_offsetof(type, field)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !(gcc &gt;= 3.5) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __offsetof(type, field) ((size_t)(&amp;((type *)0)-&gt;field))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* (gcc &gt;= 3.5) */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>如此，我们就可以定义一个宏,再通过asset来保证各个结构体的偏移是一样的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> memberOffsetof(TYPE, MEMBER) ((size_t)(&amp;((TYPE *)0)-&gt;MEMBER))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">assert(memberOffsetof(<span class="keyword">struct</span> regionA, globalData) == memberOffsetof(<span class="keyword">struct</span> regionB, globalData));</span><br><span class="line">assert(memberOffsetof(<span class="keyword">struct</span> regionA, globalData) == memberOffsetof(<span class="keyword">struct</span> regionC, globalData));</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>assert说明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assert</span><span class="params">( <span class="type">int</span> expression )</span>;</span><br><span class="line"></span><br><span class="line">assert的作用是现计算表达式 expression ，如果其值为假（即为<span class="number">0</span>），那么它先向<span class="built_in">stderr</span>打印一条出错信息，然后通过调用 <span class="built_in">abort</span> 来终止程序运行。</span><br></pre></td></tr></table></figure>

<p>频繁的调用会极大的影响程序的性能，增加额外的开销。在调试结束后，可以通过在包含#include &lt;assert.h&gt;的语句之前插入 #define NDEBUG 来禁用assert调用，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define NDEBUG</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果使用makefile， 那么可以在make的时候添加 -DNDEBUG选项</span><br></pre></td></tr></table></figure>


<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
        <category>C基础</category>
      </categories>
  </entry>
  <entry>
    <title>关于【置顶】</title>
    <url>/2020/06/20/2020-20200620-about/</url>
    <content><![CDATA[<p>欢迎访问博客，我是IT工程师小明，网名：fishmwei，是一个奋斗在一线的老程序员。</p>
<span id="more"></span>

<p>工作涉及网络设备、iOS开发。 用过C&#x2F;C++&#x2F;JS&#x2F;OC&#x2F;python语言。</p>
<p>目前专注于网络安全领域，以后大概率就这么干下去了，感觉找到了工作方向！</p>
<p>我的个人博客，平常用来记录一些工作经验，对工作的灵感、思考以及学习的心得等文章。</p>
<p>欢迎交流！</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>关于</category>
      </categories>
  </entry>
  <entry>
    <title>程序员自我修养读后感(1)-计算机基础</title>
    <url>/2020/06/24/2020-20200624-reflection4self-1/</url>
    <content><![CDATA[<p>鉴于这本书是精读过的， 按章节来个读后感比较有效。</p>
<span id="more"></span>

<h1 id="计算机硬件结构"><a href="#计算机硬件结构" class="headerlink" title="计算机硬件结构"></a>计算机硬件结构</h1><p><img src="/images/202006/self1.jpeg"></p>
<p>计算机硬件结构主要就是CPU、内存、IO设备之间的通信结构。通过使用南北桥芯片架构，北桥芯片协调高速的CPU、内存、高速图形设备以及通过南桥芯片连接慢速的外接设备。</p>
<p>后来由于CPU的频率达到阶段性的瓶颈，发展多了多核处理技术，加快多个不相干程序的运行效率。</p>
<h1 id="计算机软件结构"><a href="#计算机软件结构" class="headerlink" title="计算机软件结构"></a>计算机软件结构</h1><p><img src="/images/202006/self2.jpeg"></p>
<p>复杂的东西都可以通过分层来简化。软件架构分为硬件层面、操作系统、运行时库、应用软件等。各层之间通过接口协调。只要接口不变，就可以达到不同平台的移植。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>操作系统就是用于为多个程序分配资源的，尽可能高效的利用资源。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存管理解决内存安全、利用率的问题。通过进程虚拟空间映射到物理内存，由软件进行内存隔离，保证内存安全。使用分段、分页的机制，实现程序运行时换入换出，提高内存的使用效率。</p>
<h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p>通过线程间空间的隔离，保障内存访问安全。</p>
<p>使用基于时间片和优先级的调度机制，保障线程的正常运行。 临界区的保护。 线程的状态： 运行、就绪、阻塞。</p>
<p>线程的内核态、用户态。 内核态不可抢占。</p>
<h1 id="编译器的工作"><a href="#编译器的工作" class="headerlink" title="编译器的工作"></a>编译器的工作</h1><p>源文件 –》 预处理  – 汇编  – 编译 – 链接 –》 目标文件</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《C程序设计语言》读后感</title>
    <url>/2020/06/22/2020-20200622-reflection4c/</url>
    <content><![CDATA[<img src="/images/202006/reflection4C.jpeg" alt="图片替换文本" width="200" height="313" align="bottom" />

<p>看这边书的初衷是要重新复习一下C语言基础的语法，毕竟很长一段的工作没有用到C语言(严格的说OC也算是类C的语言吧)的，这本书也很适合初学者入门C语言， 感觉比谭xx的好一点吧，虽然我大学入门C语言的时候也是用的谭xx的书。</p>
<p>原本以为自己会从中学到一些遗漏的知识，结果却没有，看来C语言的基础在脑海中还是比较记忆深刻。每个章节后面是带有习题的，前几年也买过这个书，习题也都做过了，这次只是过一下内容，没有花时间做习题。只是粗粗的浏览了一下这本书。毕竟不需要在基础上面花太多时间，没有太大的意义。这个阶段，主要看书的所得应该是思想架构这类的，而不是太具体的实现细节,主要还是时间有限，O(∩_∩)O哈哈~。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员自我修养读后感(2)-静态链接</title>
    <url>/2020/07/04/2020-20200704-reflection4self-2/</url>
    <content><![CDATA[<h1 id="静态链接1"><a href="#静态链接1" class="headerlink" title="静态链接1"></a>静态链接1</h1><h2 id="编译器的工作"><a href="#编译器的工作" class="headerlink" title="编译器的工作"></a>编译器的工作</h2><p>完整的程序编译包含以下流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">预编译 - 编译 - 汇编 - 链接</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<span id="more"></span>

<h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>主要就是一些宏展开, 预处理条件处理、删除注释、保存文件名及行号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -E file.c -o file.i</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成的file.i也是一个可读的文本文件， 具体可以查看里面的内容</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>对代码进行词法分析、语法分析、语义分析以及优化后产生对应的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -S file.i -o file.s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>file.s为编译后的汇编代码</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>这一步是把汇编代码转为机器指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c file.s -o a.o</span><br></pre></td></tr></table></figure>

<p>a.o为目标文件</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>目标文件只有单个文件的内容， 单个文件可能引用外部文件的变量或者函数，通过链接把多个文件的内容整合起来，最终输出可执行的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ld -static a.o b.o  -o a.out</span><br></pre></td></tr></table></figure>

<p>一个文件修改后，需要重新链接才能生效。</p>
<p>链接主要涉及了地址和空间的分配、符号决议和符号的重定位等流程。</p>
<h2 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h2><p>要把多个文件链接成一个独立的文件，中间少不了约定统一的文件格式，才能通过解析文件进行处理。</p>
<p>Linux下的目标文件格式主要是ELF格式， 包含可执行文件、目标文件、静态库、动态库都是用的一样的格式。</p>
<p>我们可以通过file命令查看文件的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Keep:programmer-up keep$ file a // mac下的显示， linux也差不多吧</span><br><span class="line">a: Mach-O 64-bit object x86_64</span><br></pre></td></tr></table></figure>
<p>mac的可执行文件与linux还是有差别的， mac下是mach-o的格式(苹果自家的格式)， 这里不细讲了。</p>
<p><img src="/images/202007/filecmd.jpeg"></p>
<h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><p>目标文件中包含机器码、数据、调试符号信息、字符串等信息，文件按信息的属性存放，分为不同的Section， 每个section都是一个定长的区域，可以通过一个段表的section查询各个段的信息， 段表的信息又可以在一个成为文件头的地方查找到。文件头是在文件开始区域的一段固定长度的区域，里面描述了文件的基本信息。</p>
<p>文件头的信息可以通过 命令查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -h filename</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="/images/202007/elfhdr.jpeg"></p>
<p>通过objdump命令可以查看文件包含的各个段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Keep:programmer-up keep$ objdump -h a</span><br><span class="line"></span><br><span class="line">a:      file format Mach-O 64-bit x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      Address          Type</span><br><span class="line">  0 __text        00000035 0000000000000000 TEXT </span><br><span class="line">  1 __compact_unwind 00000020 0000000000000038 DATA </span><br><span class="line">  2 __eh_frame    00000040 0000000000000058 DATA </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于我是在mac电脑上查看的， 会和在linux上显示的不一样，不过基本的信息是一样的</p>
<p>使用size可以查看到代码段、bss段、数据段的大小。</p>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>可以通过objdump、readelf查看文件的内容，具体的请查看命令行对应的选项。</p>
<p>主要的段：</p>
<ul>
<li>代码段：存放代码指令的</li>
<li>数据段：存放初始化后的全局变量、静态变量</li>
<li>只读数据段：存放只读变量、字符串常量</li>
<li>bss段： 存放未初始化的全局变量和局部静态变量</li>
<li>字符串表： 存储段名称、变量名称、函数名称的字符串表</li>
<li>符号表： 符号与地址的信息映射表</li>
</ul>
<p>还可以自定义段，把变量或者函数放到指定的段中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a __attribute__((section(<span class="string">&quot;custom&quot;</span>)));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/202007/section.jpeg"></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>由于符号的不一致性， 但又希望C可以被C++代码引用，一般把C语言的代码通过 extern “C”包含起来，这样编译处理的符号还是C语言格式的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// c statement</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="强符号与弱符号"><a href="#强符号与弱符号" class="headerlink" title="强符号与弱符号"></a>强符号与弱符号</h3><p><code>__attribute__(weak)</code></p>
<ul>
<li>不允许出现多个同名的强符号定义</li>
<li>既存在强符号、又存在弱符号， 链接时选择强符号</li>
<li>所有定义都是弱符号， 则选择占用空间最大的那个符号</li>
</ul>
<p>可以用来做插件，内容声明为弱符号， 外部声明为强符号，当外部实现了功能，则使用外部的功能。</p>
<p>之前的博客写过遇到过一个关于弱符号的问题 <a href="/2019/06/11/weak-attribute-C">点击查看</a></p>
<h3 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h3><p>编译时，添加 -g选项，则会往目标文件写入调试的信息。ELF采用一种DWARF的调试信息格式。一般调试信息会占用挺大的空间的，对空间敏感的场景下可以通过strip删掉目标文件中调试相关的段，减小文件的大小。这样的目标文件不会影响代码的正常运行，但是不好进行gdb调试了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strip filename</span><br></pre></td></tr></table></figure>

<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>




]]></content>
      <categories>
        <category>读后感</category>
      </categories>
  </entry>
  <entry>
    <title>代码洁癖</title>
    <url>/2020/07/08/2020-20200708-codeclean/</url>
    <content><![CDATA[<p>最近修改了同事写的一块算法处理代码，有一个地方看得很不舒服，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (likely(offset)) &#123;</span><br><span class="line">  offset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>本意是想着如果offset不为0的话，则赋值为0。 代码逻辑没有问题， 但是这个判断实在是多此一举。 既然用了likely，那么代码就是表示大部分情况offset是非0的，让编译器在编译的时候，把赋值指令紧跟在判断语句之后， 条件不成立时才作跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">offset = 0;</span><br></pre></td></tr></table></figure>

<p>既然大部分情况offset不为0， 那就是这个逻辑大部分情况要执行2条语句，干脆直接赋值算了，这样所有情况都执行一条语句。</p>
<p>一条语句明显执行的更快。&#x2F;&#x2F; 大概差1-2s的样子 500w次循环</p>
<p>顺带把原先代码中的tab全部替换为空格， 代码进行对齐，顿时清爽了许多。</p>
<p>这就是代码洁癖吧，我觉得挺好。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>程序员自我修养读后感(3)-静态链接</title>
    <url>/2020/07/14/2020-20200714-reflection4self-3-md/</url>
    <content><![CDATA[<h1 id="静态链接2"><a href="#静态链接2" class="headerlink" title="静态链接2"></a>静态链接2</h1><p>前面回顾了elf目标文件的结构，这里来讲一下静态链接的具体工作。</p>
<span id="more"></span>

<h2 id="空间与地址的分配"><a href="#空间与地址的分配" class="headerlink" title="空间与地址的分配"></a>空间与地址的分配</h2><p>链接的目的就是把多个文件加工合并成一个文件输出。输出文件的内容由多个文件的内容组成，这里就涉及文件的地址如何分配的问题。</p>
<p>由于各个段存在着地址对齐的问题， 不能简单的进行段的叠加，否则会有很多空间浪费。主要通过相同段的合并。虚拟空间的重新分配。主要分2步：</p>
<ol>
<li><p>空间与地址的分配<br>  扫描各个文件的段的长度、属性及位置。收集符号表的所有符号和符号的引用，统一存放到全局的符号表。合并相同的段，计算出合并后的长度及位置，保存关系。</p>
</li>
<li><p>符号的解析与重定位<br>  读取输入文件的段的数据、重定位信息，进行符号的解析与重定位，调整代码中的地址。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ld a.o b.o -e main -o ab</span><br></pre></td></tr></table></figure>

<p>ELF可执行文件默认从地址0x08048000开始分配。</p>
<h2 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h2><p>经过上一步，各个段的虚拟地址已经确定。由于各个符号在段内的偏移是固定的，很容易就可以得出各个符号的虚拟地址。链接器就可以更新全局符号表中的符号地址了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdum -t ab // 查看符号表</span><br></pre></td></tr></table></figure>

<h2 id="符号的解析与重定位"><a href="#符号的解析与重定位" class="headerlink" title="符号的解析与重定位"></a>符号的解析与重定位</h2><p>在编译成目标文件的时候，外部引用的地址或者函数在指令中使用了假的地址作了替换。</p>
<p>并且在对应段的重定位表中保存了哪些位置需要被重定位，当上一步的地址分配确定下来之后，根据重定位表的内容，一一替换段中的地址。</p>
<p>重定位表保存了段的偏移位置以及符号在符号表中的下标，从而可以找到符号的地址，替换对应段偏移位置的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Keep:programmer-up keep$ objdump -r a.o</span><br><span class="line"></span><br><span class="line">a.o:    file format Mach-O 64-bit x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [__text]:</span><br><span class="line">0000000000000024 X86_64_RELOC_BRANCH _swap</span><br><span class="line">000000000000000b X86_64_RELOC_GOT_LOAD _sharedInited@GOTPCREL</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [__compact_unwind]:</span><br><span class="line">0000000000000000 X86_64_RELOC_UNSIGNED __text</span><br><span class="line"></span><br><span class="line">Keep:programmer-up keep$ </span><br></pre></td></tr></table></figure>

<p>链接的过程中，涉及一个符号解析的过程。在引用外部符号的时候，外部符号在符号表中是UND的。链接的时候，会在全局符号表中查找是否存在对应的符号，如果不存在，就会报错。 undefine reference xxx。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a.o:    file format Mach-O 64-bit x86-64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 g     F __TEXT,__text  _main</span><br><span class="line">0000000000000000         *UND*  _sharedInited //外部变量</span><br><span class="line">0000000000000000         *UND*  _swap   // 外部函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Keep:programmer-up keep$ objdump -t ab</span><br><span class="line"></span><br><span class="line">ab:     file format Mach-O 64-bit x86-64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000001000 g     F __TEXT,__text  __mh_execute_header</span><br><span class="line">0000000000001f60 g     F __TEXT,__text  _main</span><br><span class="line">0000000000002000 g       __DATA,__data  _sharedInited   // 变量</span><br><span class="line">0000000000002004 g       __DATA,__common        _sharedUndef </span><br><span class="line">0000000000001fa0 g     F __TEXT,__text  _swap   // 函数</span><br><span class="line">0000000000000000         *UND*  dyld_stub_binder</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="函数级别的链接"><a href="#函数级别的链接" class="headerlink" title="函数级别的链接"></a>函数级别的链接</h3><p>链接的时候一般会把所有的函数和变量都进行链接，实际很多函数和变量是没有被调用到的，这样有点浪费空间了。GCC提供了选项 -ffunction-sections, -fdata-sections， 将每个函数和变量存在独立的段中， 这样就使得目标文件的段很多。编译时，需要计算依赖关系，编译速度也降低了。</p>
<h3 id="交叉编译链工具"><a href="#交叉编译链工具" class="headerlink" title="交叉编译链工具"></a>交叉编译链工具</h3><p>在开发嵌入式程序时，由于目标机器的环境限制(内存、空间、cpu速度)，无法在目标机器上对代码直接进行编译。需要在其他系统上进行编译，这就需要用到交叉编译工具。其实，就是目标机器程序的编译工具 ，类似gcc, g++，nm等一系列工具。 这些工具需要在编译系统上运行，也就是说， 他们需要是编译系统上的程序。通过调用这些编译工具编译的代码，不能在编译系统上运行，但是需要在嵌入式系统(目标机器)运行。</p>
<p>实际上，大部分嵌入式系统也是类unix的系统，其可执行文件也遵循elf文件格式。只要在编译系统上，可以编译出目标机器上运行的可执行文件就可以了。 不管是windows，还是linux上，只要编译工具链完整，都是可以拿来编译程序的。</p>
<p>现在，编译工具大多是开源了的，而且都支持编译出不同系统的程序，只需要在编译的时候指定目标机器，设置好相关的参数，就可以编译出对应的编译链工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configuare --host xxxlinux --prefix=/build/bin --target=arm-linux</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>具体的编译配置可以使用选项-v查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -v</span><br></pre></td></tr></table></figure>



<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>读后感</category>
      </categories>
  </entry>
  <entry>
    <title>gdbserver</title>
    <url>/2020/07/16/2020-20200716-gdbserver/</url>
    <content><![CDATA[<p>gdbserver是用于远程gdb的工具， 可以实现远程调试代码。很多嵌入式平台没有安装gdb，可以通过gdbserver启动，然后在网络可达的另一台主机起一个gdb进行远程代码调试。gdbserver占用空间比较小， 很适合在嵌入式系统里使用。</p>
<span id="more"></span>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>gdbserver是要在目标嵌入式系统运行的程序， 需要使用交叉工具链进行编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd gdb/gdbserver</span><br><span class="line">export CC=arm-linux-gcc CXX=arm-linux-gcc</span><br><span class="line">./configure  --host=arm-linux --target=arm-linux --prefix=path/to/output</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我在编译linux-arc-low.c的时候出现一个问题，提示 <code>initializer element is not constant</code></p>
<p>报错的是一个全局变量的赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const uint16_t arc_breakpoint = ntohs(0x3e78);</span><br></pre></td></tr></table></figure>

<p>我把 ntohs删掉了， 目标机器本来就是大端字节序，没必要转换。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>拷贝可执行文件和gdbserver到嵌入式系统， 可执行文件需要添加-g选项编译。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdbserver :1234 ./exec_file</span><br></pre></td></tr></table></figure>

<p>调试系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/arm-linux-gdb ./exec_file</span><br><span class="line">target remote 192.168.183.127:1234</span><br></pre></td></tr></table></figure>

<p>好了， 后面就是gdb调试了</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>程序员自我修养读后感(4)-可执行文件加载</title>
    <url>/2020/07/17/2020-20200717-reflection4self-4/</url>
    <content><![CDATA[<h1 id="可执行文件的装载与运行"><a href="#可执行文件的装载与运行" class="headerlink" title="可执行文件的装载与运行"></a>可执行文件的装载与运行</h1><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p>程序通过编译链接之后，各个变量及函数的虚拟地址就已经确定了。每个程序都拥有独立的内存空间，程序运行时使用的是虚拟地址，操作系统通过内存映射的方式，把虚拟地址映射到物理地址，程序只需要通过虚拟地址操作即可，不需要关心实际的物理内存地址。程序可访问的虚拟地址的大小与系统的总线位宽相关， 32位系统允许访问4GB的地址。操作系统通过页映射的方式，加载程序的数据和指令到内存，没有被使用的数据和指令就被替换到磁盘中。</p>
<span id="more"></span>

<h2 id="文件的装载"><a href="#文件的装载" class="headerlink" title="文件的装载"></a>文件的装载</h2><p>进程创建时，操作系统首先创建一个独立的虚拟地址空间，并建立一个页目录结构，用于后面保存页与物理地址的映射关系。然后读取可执行文件的文件头，建立虚拟地址空间与执行文件的映射关系。<br>然后cpu指令寄存器设置为可执行文件的入口地址，启动运行。 CPU在运行的过程中，去访问对应的虚拟地址，会发现对应的页内容是空的，即发生了页错误，转而由系统分配物理内容，然后建立映射关系，加载数据与指令，再由程序继续运行。</p>
<p>可执行文件  – 虚拟地址空间 – 物理内存空间</p>
<p><img src="/images/202007/vmaload.jpeg"></p>
<h2 id="虚拟地址空间的分配"><a href="#虚拟地址空间的分配" class="headerlink" title="虚拟地址空间的分配"></a>虚拟地址空间的分配</h2><p>由于页映射加载需要保证按页面大小对齐加载，那么每个段需要以页大小的倍数进行装载，不足一页也要占用一个页的大小，浪费了空间。系统通过合并多个相同属性的段进行加载。合并后的段，称为segment。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -l exec_file // 可以显示具体的地址及段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看实际执行的内存分布情况</span><br><span class="line">cat /proc/&#123;pid&#125;/maps</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Linux加载elf的简要步骤"><a href="#Linux加载elf的简要步骤" class="headerlink" title="Linux加载elf的简要步骤"></a>Linux加载elf的简要步骤</h2><ol>
<li>读取文件的前面128字节， 判断文件类型</li>
<li>查找不同文件的handler函数</li>
<li>根据程序表头，对文件进行映射</li>
<li>初始化进程环境， 修改入口地址</li>
<li>开始执行</li>
</ol>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>程序员自我修养读后感(5)-动态链接</title>
    <url>/2020/07/23/2020-20200718-reflection4self-5/</url>
    <content><![CDATA[<h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>经过前面一些列的学习，可以知道一个程序运行时，可执行文件映像是需要被载入到内存中的。为了复用，很多程序使用了相同的静态库，那么这些静态库都是需要被分别链接合并到各个程序的可执行文件的。那么在磁盘上，其实有很多同一个静态库的内容的副本。 各个程序同时运行时，内存中也存在多个同一个静态库的内容的副本。很显然，浪费了很多空间， 也增加了许多载入内存的时间。同一个静态库，比如是C语言的基础库的静态版本，还有许多自研的共享库。</p>
<span id="more"></span>

<p>因此，出现了动态链接的技术。 在编译时，不链接依赖模块的库，在运行时才进行链接。在程序运行的初期，系统对依赖的库进行链接，当所依赖的库都存在磁盘中的时候，链接完成。链接的整体过程和静态链接的过程相似， 都包含了符号解析，地址重定位等步骤。 完成动态链接主要工作的是一个称为动态链接器的程序。</p>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared -o common.so common.c // 命令行创建动态链接库</span><br><span class="line">gcc -o main main.c common.so // 链接产生main</span><br></pre></td></tr></table></figure>

<p>我们可以通过前面学习到的objdump命令查看可执行文件的符号表， 我们发现 common.c中的函数及变量依旧是 UND的。他们只有在动态库被加载之后才能确定地址，也就是装载时重定位。<br>装载时重定位，需要修改指令的地址，那么多个程序间的指令就不可以共享了，由于不同程序的数据部分是分开的则没有这个问题。</p>
<h2 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h2><p>为了使得共享库的指令部分可以共享，需要把可变的指令分离出来，放到一个全局偏移表中，即got段。got段放在数据部分， 各个程序都有一个副本。指定部分存储变量或者函数在got表中的偏移地址，然后找到got表中对应偏移的内容，即变量&#x2F;函数的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -d foo.so | grep TEXTREL // 没有输出就是地址无关的so</span><br></pre></td></tr></table></figure>


<h2 id="延迟加载技术"><a href="#延迟加载技术" class="headerlink" title="延迟加载技术"></a>延迟加载技术</h2><p>got段中的各个项， 只会在第一次调用的时候进行重定位填充。后面就不再加载。而不是一开始就计算好全部的重定位地址。 got段用于存储变量地址， got.plt段用于存储函数地址。</p>
<h2 id="动态链接相关结构"><a href="#动态链接相关结构" class="headerlink" title="动态链接相关结构"></a>动态链接相关结构</h2><h3 id="interp段"><a href="#interp段" class="headerlink" title=".interp段"></a>.interp段</h3><p>静态链接的文件在装载到内存之后，指令寄存器地址指向程序入口地址，控制权会转交给程序。而动态链接文件，需要先加载一个动态链接器，然后转交给动态链接器加载程序依赖的动态库，最后才转交给程序运行。</p>
<p>动态链接器的信息由elf中的.interp段保存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看各个段的内容</span><br><span class="line"></span><br><span class="line">objdump -s exec_file</span><br><span class="line"></span><br><span class="line">readelf -l exec_file | grep interpreter // 也会显示动态链接器的路径</span><br></pre></td></tr></table></figure>

<h3 id="dynamic段"><a href="#dynamic段" class="headerlink" title=".dynamic段"></a>.dynamic段</h3><p>保存动态链接器需要的基本信息， 依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、初始化代码的地址等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -d exec_file</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>动态符号表、动态符号字符串表、符号哈希表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdump -T exec_file // 动态符号表</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="显示加载动态库"><a href="#显示加载动态库" class="headerlink" title="显示加载动态库"></a>显示加载动态库</h2><p>动态库支持动态加载、删除。 </p>
<p>可以使用 dlopen&#x2F;dlclose&#x2F;dlsym函数操作。灵活的替换使用的库。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>撸了一个轻量级的C语言日志库</title>
    <url>/2022/05/01/2022-20220501-clog/</url>
    <content><![CDATA[<p>最近在写代码的时候，因为是一个全新的工程，也没有引入什么日志库，直接就printf输出调试了。</p>
<p>这个总归是有一点儿不雅，然后想到之前用的sysrepo这个开源库，他提供的那个日志功能挺简单的，支持向终端错误stderr输出日志，也支持向syslog输出日志，而且使用起来也比较简单，想着借鉴着写一个。</p>
<span id="more"></span>

<p>5月1日下午就着手整一个简单的C语言日志库出来，整体的功能逻辑跟sysrepo的log文件内容差不多，删掉了与sysrepo， libyang相关的依赖，然后通过前段时间刚学的cmake搭建起编译环境，编译生成一个动态库。<br>给这个库起了个简单的名字clog。</p>
<p>所有代码都放到了个人的gitee仓库中了，有需要的看官可以参考使用一下，有想法的话也可以一起来完善。</p>
<p>路径：<code>https://gitee.com/fishmwei/clog</code></p>
<p>使用起来也很简单，只要初始化的时候设置一下日志的等级，后面就可以使用了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clog/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* turn logging on */</span></span><br><span class="line">    clog_log_stderr(CLOG_LL_DBG);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CLOG_SYSLOG</span></span><br><span class="line">    clog_log_syslog(<span class="string">&quot;test-log&quot;</span>, CLOG_LL_WRN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    CLOG_LOG_WRN(<span class="string">&quot;This is warning message\r\n&quot;</span>);</span><br><span class="line">    CLOG_LOG_DBG(<span class="string">&quot;This is debug message\r\n&quot;</span>);</span><br><span class="line">    CLOG_LOG_INF(<span class="string">&quot;This is info message\r\n&quot;</span>);</span><br><span class="line">    CLOG_LOG_ERR(<span class="string">&quot;This is error message\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用效果图</p>
<p><img src="/images/202205/clog_test.png" alt="avatar"></p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io/</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>程序员自我修养读后感(6)-共享库的组织</title>
    <url>/2020/07/24/2020-20200724-reflection4self-6/</url>
    <content><![CDATA[<h1 id="共享库的组织"><a href="#共享库的组织" class="headerlink" title="共享库的组织"></a>共享库的组织</h1><h2 id="共享库的兼容"><a href="#共享库的兼容" class="headerlink" title="共享库的兼容"></a>共享库的兼容</h2><p>由于共享库的优点，许多程序都采用了共享库作为通用的库，而减少了静态库的使用。系统中，就会存在许多的共享库， 各个版本不一。在编译的时候，会在可执行文件的.dynamic段中写入程序依赖的动态库的SO_NAME。SO_NAME是一个类似libname.so.3的字符串，表示依赖名称为name的动态库， 动态库的版本为3.x.x。对于linux，动态库有其命名的规则，为libname.so.3.1.2。版本号的定义遵循<a href="https://semver.org/">semver</a>格式。在linux中，还会存在一个libname.so.3的软链接，指向name对应的主版本为3的最新的版本文件，这样就解决了版本的兼容问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o main -lname // -lname 表示需要链接libname.so.a.b.c, 具体的版本由编译环境决定</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这个方案无法解决依赖的次版本比实际运行次版本高的问题。次版本号只保证向后兼容， 不保证向前兼容， 可能出现某些接口找不到的问题，需要注意。</p>
<h2 id="共享库的查找路径"><a href="#共享库的查找路径" class="headerlink" title="共享库的查找路径"></a>共享库的查找路径</h2><p>程序依赖的共享库会被保存到.dynamic段中， 然后加载的时候由动态链接器进行加载，如果保存的是绝对路径，直接按路径加载；如果是相对路径或者纯文件名，则按&#x2F;lib, &#x2F;usr&#x2F;lib, 和&#x2F;etc&#x2F;ld.so.conf配置的路径查找。还有基于ldconfig的缓存优先查找。</p>
<p>还可以基于环境变量LD_LIBRARY_PATH设置优先查找路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LD_LIBRARY_PATH=/home/lib /bin/ld  ./exec_file</span><br></pre></td></tr></table></figure>


<p>查看共享库的查找过程可以设置环境变量 LD_DEBUG, 然后执行程序 会有具体的信息输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LD_DEBUG=files  ./exec_file</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>前段时间在12123App上申请的驾驶证到期换证，前几天就收到了新驾照，直接从南京邮寄到手，互联网+政务的应用的确使得广大公民收益匪浅，省去了许多繁杂的流程。相信IT技术在生活中的应用将越来越广阔，生活会越来越美好，科技发展很有前景。套用老东家的愿景，科技将会丰富人们的沟通与生活。科技在未来很长一段时间内，依旧会是一个好的，并且会越来越好的一个赛道。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>程序员自我修养读后感(7)-程序的内存布局</title>
    <url>/2020/07/27/2020-20200727-reflection4self-7/</url>
    <content><![CDATA[<h1 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h1><p>一个程序运行时的进程,都会被分配一块虚拟内存空间，虚拟内存空间再映射到内存中。程序可访问的虚拟内存空间的大小由CPU的位数决定，针对32位的系统最大可访问空间为4GB。 内存空间包含几个部分： 栈、堆、可执行文件映像、保留区。当然4GB不是全部分配给程序使用的，linux一般会把高1GB地址分配给系统内核，低3GB为用户进程空间。</p>
<span id="more"></span>

<ul>
<li>栈：用户进程空间的最高位， 用于维护函数调用的上下文，一般只有几MB大小， 从高往低增长</li>
<li>堆：用于存储应用程序动态分配的内存， 一般有几百MB大小， 从低往高分配</li>
<li>可执行文件映像： 用于加载可执行文件映射，可执行文件各个段就在这里， 包含代码段、全局变量等</li>
<li>保留区：一般是为了保护内存禁止访问的区域，比如很低的地址</li>
</ul>
<p>用户空间除了堆和栈，还存在一个动态链接库的映射区域。</p>
 <img src="/images/202007/memstruct.jpeg" width = "300" height = "600" alt="图片名称" align=center />


<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈用来保存函数运行期间使用的一些寄存器、变量和地址。维护函数调用顺序</p>
<p>栈的调用惯例，指的是约定的参数传递顺序、栈的维护方式、函数修饰、函数返回值的回传方式约定。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆用于程序中动态分配地址，栈在函数运行完毕后，地址会被释放，而全局变量不好动态的分配地址，所以有了堆。堆可以分配的地址为用户空间中剩余的大小。32位的话，一般不超过2.9GB吧， 可以自行计算一下， 堆需要连续的地址。</p>
<p>linux使用2种系统调用分配堆空间， brk、mmap。 brk的作用就是设置数据段终止地址。mmap申请一块虚拟地址，并且映射到文件。使用mmap的方式申请地址， 可申请大小还受到系统剩余可使用内存大小和剩余磁盘交换空间的大小限制。</p>
<p>内存分配算法：空闲链表法、位图法。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>换城市工作切换的感受</title>
    <url>/2020/06/03/2020-20200603-newjob-JOB/</url>
    <content><![CDATA[<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>很快，从去年11月份到现在已经半年多了，新工作的第一个项目也大抵结束了，近来有时间来说一说感想。</p>
<p>这次工作变动比较大，不仅仅更换了公司，还换了工作的城市。从做前端iOS转回到做网络设备安全， 从福建福州来到了湖南长沙，家庭成员也在长沙安顿下来了，福州的房子暂时还空闲着，一方面不舍得出租，另一个方面呢，疫情原因楼市不大景气，目前过着又还房贷、又租房的相对拮据的日子。</p>
<span id="more"></span>

<h2 id="聊聊工作"><a href="#聊聊工作" class="headerlink" title="聊聊工作"></a>聊聊工作</h2><p>当前的工作呢，工作内容上算是老本行吧，工作9年多以来，前面4年也都是做网络通信的，先是在锐捷网络，后面到南京华为。到现在的网络设备。工作还算是比较容易上手，C语言、网络知识的底子还在。公司及工作环境，嗯，毕竟只有几十人的公司，环境肯定没有之前好了。工作氛围上，基本上就是小公司有大公司的区别。工作流程少，需求来了就干，代码及软件文档、开发流程等存在很多需要改进的地方吧。这些就不多讲了，唯一的好处就是加班少吧，哈哈。管理上，算是扁平化管理吧，大小领导都可能来需求。工作安排不是很清晰，项目计划什么的比较欠缺点，当然也许我级别低了解不多。同事沟通合作上相对是很简单，老带新吧。同事水平算是参差不齐吧，有些经验老到，有些经验不足。 毕竟工作年限挺久了，有了相当的工作经验，从iOS切换过来感觉没有什么不适应。</p>
<h2 id="谈谈生活"><a href="#谈谈生活" class="headerlink" title="谈谈生活"></a>谈谈生活</h2><p>天气上呢，就觉得长沙天暗的晚吧，毕竟和福州差了2、3个时区.冬天阴冷，春夏雨水多，潮湿。饮食上，各种辣椒吧，自己煮饭还好。也许是我比较宅，没发现娱乐之都有多么的娱乐。长沙房价呢，相比较福州真是便宜了。5年前在福州买房，单价都1.6w多了。现在长沙，均价也就1w出头。目前长沙继续限购，我呢也没有资格购房，等个两年吧。先适应适应生活，听说长沙的教育不错，本人出生农村，对这个城市里的教育资源怎么个好坏真没有概念。</p>
<p>好了， 先这样。</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>近期工作回顾</title>
    <url>/2020/08/17/2020-20200817-layer/</url>
    <content><![CDATA[<h1 id="近期工作回顾"><a href="#近期工作回顾" class="headerlink" title="近期工作回顾"></a>近期工作回顾</h1><p>新项目红红火火的开展了，前一阵子也忙了一下，嗯，现在自己这部分的代码终于吭哧吭哧的完成的差不多了，其他同事的工作离完成还善待时日。可以抽出空来对这段时间的编程工作做个小小的回顾。</p>
<span id="more"></span>


<h2 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h2><p>项目还是基于老项目的代码开工的， 对旧的项目框架，总归是有一些感觉不合理的地方，抽时间梳理了一下，特别是这个代码架构。一个main.c文件包罗万象，各种代码参差在一起，总让人感觉到乱。对内对外的头文件没有区分，一股脑全部暴露出去。针对这个情况， 我采用了软件架构上的万金油 - 分层。 首先，根据业务把代码进行了分层， 理清楚各个模块之间的调用关系； 然后根据不同的层，把相关的代码分散到不同的文件。 第三， 把对内对外的接口分离开，分散到不同的文件中。具体实现如下：</p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>根据整理把代码分层不同的模块， 分别为 最上层进行逻辑组织的应用模块， 报文解析处理的报文模块， 业务相关的业务模块， 配置相关的配置模块，通用的工具模块，还有就是系统芯片的SDK模块。</p>
 <img src="/images/202008/layer.jpg" width = "400" height = "300" alt="图片名称" align=center />

<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>针对嵌入式系统，为了提高程序运行的效率， 减少不必要的函数出入栈操作，项目大部分的函数都是static inline类型的，整个模块除了一个main.c文件其他都是头文件。针对这种情况，从main.c文件剥离出来的各个模块的代码也都是以头文件的形式存在的。 如： packet.h, bus.h, common.h。 另外，由于配置模块一般都是在程序运行时进行调用处理的，性能要求不高，可以独立出一个config.c + config.h的文件。</p>
<p>然后根据调用关系， 在main.c文件中按顺序引用各个模块的头文件， 针对需要互相引用的地方， 使用函数声明的方式来保证调用的到。这样， 在预处理的时候，其实大部分模块的代码会直接展开到main.c文件， 可以正常使用。 为了保证模块间不互心依赖头文件， 我使用了宏判断，进行报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef _PACKET_H_</span><br><span class="line"></span><br><span class="line">#pragma message(__FILE__&quot; must be included in main.c, only once&quot;)</span><br><span class="line"></span><br><span class="line">&quot;packet.h 只能在main.c文件中包含&quot;</span><br><span class="line">#else</span><br><span class="line">#define _PACKET_H_</span><br><span class="line"></span><br><span class="line">// ... code statememts ...</span><br><span class="line"></span><br><span class="line">#endif </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>头文件只要多次被引用了， 编译时就会报错。</p>
<p>同理，其他的内部头文件也进行同样的处理， 保证在main.c中唯一引用头文件即可。各个模块的文件不需要再引用任何头文件， 由main.c组织依赖关系。</p>
<p>这样逻辑就清晰多了， 代码也不会混杂在一起。</p>
<h2 id="sizeof-宏替换"><a href="#sizeof-宏替换" class="headerlink" title="sizeof 宏替换"></a>sizeof 宏替换</h2><p>代码中充斥着许多对结构体进行sizeof求大小的代码，实际上这些都是可以节省下来的，使用宏进行统一定义与处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define UDP_HEADER_LEN (8) // udp头部长度为8   sizeof(udp_header_t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 代码启动时进行assert</span><br><span class="line">assert(UDP_HEADER_LEN==sizeof(udp_header_t));</span><br></pre></td></tr></table></figure>

<p>使用了UDP_HEADER_LEN替换了 <code>sizeof(udp_header_t)</code> 的地方， 同时在编译debug的程序时， 进行了assert断言。</p>
<p>还有一种使用宏的方法， 调试过程中， 我们把结构体大小以及对应的宏常量打印出来, 人工看一下大小对不对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define SHOWSTRUCTSIZE(type)  printf(&quot;%s, size %d\r\n&quot;, #type, (int)sizeof(type))</span><br><span class="line"></span><br><span class="line">#define SHOWMACROVALUE(macro) printf(&quot;%s = %d\r\n&quot;, #macro, macro)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void showStructInfo()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  SHOWSTRUCTSIZE(udp_header_t);</span><br><span class="line">  SHOWMACROVALUE(UDP_HEADER_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"></span><br><span class="line">  showStructInfo();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>学以致用</title>
    <url>/2020/08/28/2020-20200828-skills/</url>
    <content><![CDATA[<p>最近工作使用了几个小skill，优化了代码，还帮团队的小伙子搞定了插入排序的功能。现在有些年轻人技术有点不足啊， 一个二分查找插入搞了快一周还没完成， 汗！！！</p>
<span id="more"></span>

<h2 id="弱类型作为开关的妙用"><a href="#弱类型作为开关的妙用" class="headerlink" title="弱类型作为开关的妙用"></a>弱类型作为开关的妙用</h2><p>程序存在多个模块，每个模块都是一个单独的库，且每个模块都存在日志的打印。 希望可以通过一个地方统一控制不同模块的日志开关。通过在main.c的强符号变量，替换各个模块内的弱符号变量，控制各个不同模块的日志打印。主函数内，通过执行不同的命令变更强符号变量的值， 动态控制不同模块的日志打印。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module_a</span></span><br><span class="line">__attribute__(weak) <span class="type">bool</span> module_a_log_enable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_A_LOG(...)  do &#123;\</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (module_a_log_enable) &#123;\</span></span><br><span class="line"><span class="meta">		logFunc(__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">	&#125;\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module_b</span></span><br><span class="line">__attribute__(weak) <span class="type">bool</span> module_b_log_enable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_B_LOG(...)  do &#123;\</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (module_b_log_enable) &#123;\</span></span><br><span class="line"><span class="meta">		logFunc(__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">	&#125;\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> module_a_log_enable = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> module_b_log_enable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="二分查找与插入算法的运用"><a href="#二分查找与插入算法的运用" class="headerlink" title="二分查找与插入算法的运用"></a>二分查找与插入算法的运用</h2><p>接收配置，依据id从小到大保存配置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return 0 exist , insert fail. 1 insert success</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertData</span><span class="params">(<span class="type">int</span> *datas, <span class="type">int</span> curDataCount, <span class="type">int</span> newData)</span> &#123;</span><br><span class="line">	<span class="type">int</span> min = <span class="number">0</span>, max = curDataCount - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> middle, i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find position</span></span><br><span class="line">	<span class="keyword">while</span> (min &lt; max) &#123;</span><br><span class="line">		middle = (max - min)/<span class="number">2</span> + min;</span><br><span class="line">		<span class="keyword">if</span> (datas[middle] &lt; newData) &#123;</span><br><span class="line">			min = middle + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (datas[middle] == newData) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			max = middle - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert </span></span><br><span class="line">	<span class="keyword">if</span> (min &gt;= curDataCount) &#123;</span><br><span class="line">		datas[curDataCount] = newData;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (datas[min] &lt; newData) &#123;</span><br><span class="line">			min++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = count; i &gt; min; i--) &#123;</span><br><span class="line">			datas[i] = datas[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		datas[min] = newData;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="穷举二维数组的排列组合"><a href="#穷举二维数组的排列组合" class="headerlink" title="穷举二维数组的排列组合"></a>穷举二维数组的排列组合</h2><p>有一个二维数组 a[n][m], 0 &lt; n, m &lt;&#x3D; 8.每行的有效元素个数不固定，且单行内的元素不重复。 要求从每一行取一个有效数字，组成一个一维数组result[n]。 计算出所有可能的组合。</p>
<p>算法： 使用递归， 依次选取第0，1, … n行的元素，直到第n+1行结束， 每行都有column[n]个选择方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> *a[<span class="number">8</span>], <span class="type">int</span> rowCount, <span class="type">int</span> *column, <span class="type">int</span> curRow, <span class="type">int</span> *output)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (curRow &gt; rowCount - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> resultCount = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		resultCount++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;r\r\nesult %d: &quot;</span>, resultCount);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rowCount; i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, output[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; column[curRow]; i++) &#123;</span><br><span class="line">		output[curRow] = a[curRow][i];</span><br><span class="line">		select(a, rowCount, column, curRow+<span class="number">1</span>, output);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>程序员自我修养读后感(8)-运行时库</title>
    <url>/2020/07/29/2020-20200729-reflection4self-8/</url>
    <content><![CDATA[<h1 id="运行库"><a href="#运行库" class="headerlink" title="运行库"></a>运行库</h1><p>每种语言的程序运行都需要其运行库的支持， java需要java虚拟机、JavaScript需要js引擎， C语言也需要glibc(Linux上)的支持。所谓运行库，就类似于语言的框架，编写语言时，需要根据框架的定义进行编程。比如，我们约定程序都是从main函数开始执行，用户就必须编写main函数，运行库在准备好运行环境之后，再调用main函数开始运行。</p>
<span id="more"></span>

<p>运行库glibc的入库为_start， 由链接器设置。</p>
<p>运行库功能包含</p>
<ul>
<li>程序的启动与退出</li>
<li>标准函数库</li>
<li>IO库封装</li>
<li>堆的实现</li>
<li>语言实现，语言功能</li>
<li>调试</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>运行库提供IO文件的操作，存在fd、FILE指针、内核对象等概念。</p>
 <img src="/images/202007/IOrelation.jpeg" width = "400" height = "300" alt="图片名称" align=center />

<p>运行库在调用用户代码之前， 会进行IO初始化，创建fd与FILE等的对应关系， 这样就可以在用户代码中调用printf, scanf等函数。</p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>所谓系统调用，就是用户程序为了访问系统资源而调用的系统提供的API接口。系统调用会对系统资源进行保护和调度，对用户程序屏蔽了具体的细节。很多资源用户程序本身是没有权限、或者没有途径直接进行访问，需要通过系统调用来实现。系统调用提供文件的读写、网络通信、终端输出、进程的创建与退出等功能。</p>
<p>系统调用的接口比较原始，直接使用系统调用可能需要相关的知识。 运行库作为用户程序与系统调用的中间层，屏蔽了一些细节，对不同平台的系统调用进行了整合。</p>
<p>现代CPU存在特权级， 分为用户模式和内核模式。用户程序处于用户态， 系统调用处于内核态。用户态代码对访问设备、开关终端等操作是受限的。系统通过中断切换运行的模式。当CPU接收到中断的时候，会暂停当前的处理流程，然后 根据中断向量表找到对应的中断处理程序进行处理，处理结束后再继续处理之前的流程。由于中断号是有限的， 因此，一般多个系统调用共用一个中断号，然后根据系统调用号来区分不同的系统调用。linux的系统调用中断一般是0x80, 然后通过eax寄存器存储系统调用号。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>grep命令使用</title>
    <url>/2020/09/19/2020-20200919-grep/</url>
    <content><![CDATA[<p>无论使用什么产品，照着使用指南进行一番操作是学习它最便捷快速的方法。使用指南都是给用户看的， 一般都是简单易懂，有示例。linux命令行也是一样。</p>
<span id="more"></span>

<p>linux 命令行的使用指南有两种方法查看， 一种是命令行后面添加 –help选项，查看最基础的使用概要。 另一种是使用man 命令查看详细的命令使用指南。第一种适合快捷查询，但是信息不够详细。 第二种，适合深入详细的查询，可以了解各个选项的意义。通过这两种方式基本上可以搞懂linux的命令使用，然后再结合网络上的一些博客、百科什么的示例，就基本可以掌握该linux命令了。对于不懂的概念，再深入扩展学习一下，再加上日积月累的使用，对该linux命令就可以更加熟练、信手拈来了。这个方法也是我学习的主要套路。不知道大家是否也一样？。</p>
<p>不唠叨了。今年还有一个todo是掌握linux命令三剑客grep&#x2F;awk&#x2F;sed，下面整理一下比较简单的grep命令使用(基本上就是手册的翻译及使用举例)。</p>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>用于文件内容的模式匹配搜索</p>
<h2 id="使用概要"><a href="#使用概要" class="headerlink" title="使用概要"></a>使用概要</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [-abcdDEFGHhIiJLlmnOopqRSsUVvwxZ] [-A num] [-B num] [-C[num]]</span><br><span class="line">     [-e pattern] [-f file] [--binary-files=value] [--color[=when]]</span><br><span class="line">     [--colour[=when]] [--context[=num]] [--label] [--line-buffered]</span><br><span class="line">     [--null] [pattern] [file ...]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p> grep会搜索给定的文件，获取符号指定匹配模式(pattern)的行并输出。默认的，pattern只会一行行的进行匹配，不包含结尾的换行。空的pattern则匹配每一行。</p>
<p> grep用来作简单的模式匹配和基础的正则表达式匹配。 egrep可以处理扩展的正则表达式。fgrep处理的效率比grep和egrep更好，但是只能处理固定的pattern。pattern可以包含多行。</p>
<p> zgrep, zegrep和zfgrep的功能和grep、egrep、fgrep的功能一样，但是处理之前会对文件进行解压， 也就是用来处理压缩文件的版本。</p>
<h2 id="命令选项："><a href="#命令选项：" class="headerlink" title="命令选项："></a>命令选项：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-A num， 显示匹配行之后的num行</span><br><span class="line"></span><br><span class="line">-a, --text 把所有文件当作ASCII文本处理。</span><br><span class="line"></span><br><span class="line">-B num, 显示匹配行之前的num行</span><br><span class="line"></span><br><span class="line">-b ， 显示匹配pattern的行首在文件的偏移</span><br><span class="line"></span><br><span class="line">-C 包含-A, -B的功能</span><br><span class="line"></span><br><span class="line">-c num 输出前面num行的匹配结果</span><br><span class="line"></span><br><span class="line">--colour=when   高亮匹配pattern的字符串， 可以为never， always 和 auto</span><br><span class="line"></span><br><span class="line">-D action ， --devices=action 指定处理设备、FIFOs和sockets的动作。默认动作是`read`，当作普通文件进行匹配， 可以设置成`skip`，不作匹配</span><br><span class="line"></span><br><span class="line">-d action, --direcotries=action, 指定处理目录的动作， 默认动作是`read`， 当作普通文件进行匹配。可以设置成`skip`， 递归地进入处理，同`-R`/`-r`</span><br><span class="line"></span><br><span class="line">-E 指定扩展正则表达式， 作用同egrep</span><br><span class="line"></span><br><span class="line">-e pattern, --regexp=pattern 指定一个正则表达式， 一般使用-e来指定多个正则表达式， 只要匹配到任一正则表达式就会选中该行输出</span><br><span class="line"></span><br><span class="line">--exclude 如果指定了，那么符合给定pattern的文件名的文件将不会被查找。--exclude的优先级高于--include的优先级。pattern匹配的是全路径，不仅仅是文件名。</span><br><span class="line">		grep -i -e &#x27;^Hello*&#x27; -e &#x27;^aa&#x27;  -b --color --exclude hello.* *.md</span><br><span class="line">		grep keep$ grep -i -e &#x27;^Hello*&#x27; -e &#x27;^aa&#x27;  -b --color --exclude hello.* ./* -R</span><br><span class="line"></span><br><span class="line">--exclude-dir 如果指定了-R选项，那么就不会查找符合给定pattern的目录。--exclude-dir的优先级高于--include-dir</span><br><span class="line"></span><br><span class="line">-F, --fixed-strings 给定的pattern当作一个固定的字符串， 作用同fgrep</span><br><span class="line"></span><br><span class="line">-f file, --file=file 从file文件中读取多行的pattern。如果文件内容为空，将不匹配任何东西</span><br><span class="line">		grep -i -f pattern  -b --color --exclude &#x27;*.md&#x27;  -R &#x27;./&#x27; --exclude-dir &#x27;2&#x27; </span><br><span class="line"></span><br><span class="line">-G, --basic-regexp 给定的pattern当作基础的正则表达式。 </span><br><span class="line"></span><br><span class="line">-H 输出结果时，前面显示文件名</span><br><span class="line"></span><br><span class="line">-h, --no-filename 输出结果时，前面不显示文件名</span><br><span class="line"></span><br><span class="line">--help 显示帮助</span><br><span class="line"></span><br><span class="line">-I 忽略二进制文件， 就是不对二进制文件匹配处理</span><br><span class="line"></span><br><span class="line">-i, --ignore-case 对pattern忽略大小写</span><br><span class="line"></span><br><span class="line">--include 只有符合给定pattern的文件名的文件才进行搜索。pattern针对的是全路径，而不仅仅是文件名.</span><br><span class="line">	grep -i -f pattern  -b --color --include &#x27;*.md&#x27; ~/Documents/code/GitHub/blog_code/grep/* -R</span><br><span class="line"></span><br><span class="line">--include-dir 如果设置了`-R`，只有目录符合给定pattern的文件名的文件才进行搜索。</span><br><span class="line"></span><br><span class="line">-J, --bz2decompress 解压缩bzip2的文件再进行搜索</span><br><span class="line"></span><br><span class="line">-L, --files-without-match 只显示文件内容不符合pattern的， 文件名符合-L值的文件的文件名</span><br><span class="line">	grep -i &#x27;hello&#x27; -L *.md ./ -r</span><br><span class="line"></span><br><span class="line">-l, --files-with-matches 只显示文件内容符合pattern的，文件名符合-l值的文件的文件名</span><br><span class="line"></span><br><span class="line">--mmap 使用mmap而不是read来读取输入的内容。可以获取更好的性能， 但有时候行为不确定。</span><br><span class="line"></span><br><span class="line">-m num, --max-count=num 获取num个结果后，不再读取文件</span><br><span class="line"></span><br><span class="line">-n, --line-number 输出结果显示行号</span><br><span class="line"></span><br><span class="line">--null Prints a zero-byte after the file name.</span><br><span class="line"></span><br><span class="line">-O 如果给定了-R选项， 而且命令行显式的写出了符号链接， 则进行处理， 否则跳过。 就不处理符号连接的内容</span><br><span class="line"></span><br><span class="line">-o 只显示匹配patter的部分。</span><br><span class="line"></span><br><span class="line">-p 如果给定了-R选项，默认不处理符号连接</span><br><span class="line"></span><br><span class="line">-q, --quiet, --silent 静默搜索，直到搜索到一个匹配的项，不会输出。 可以用在shell中， 仅仅判断有没有找到内容。</span><br><span class="line"></span><br><span class="line">-R, -r, --recursive  递归的查找子目录</span><br><span class="line"></span><br><span class="line">-S 如果指定了-R选项，所有符号连接都处理</span><br><span class="line"></span><br><span class="line">-s, --no-messages Silent mode . 不存在或者不可读的文件 信息不会被显示</span><br><span class="line">	grep -i &#x27;hello&#x27; -n --mmap --null  *.json -s</span><br><span class="line"></span><br><span class="line">-U, --binary 搜索二进制文件，但是不打印结果</span><br><span class="line"></span><br><span class="line">-V, --version 显示grep的版本信息</span><br><span class="line"></span><br><span class="line">-v, --invert-match 显示不匹配pattern的行</span><br><span class="line"></span><br><span class="line">-w, --word-regexp pattern被当做一个word来匹配查询</span><br><span class="line"></span><br><span class="line">-x, --line-regexp 只有输入行全部匹配字符串或者regular expression才算匹配上</span><br><span class="line"></span><br><span class="line">-y, 同-i  废弃了</span><br><span class="line"></span><br><span class="line">-Z, -z, --decompress 先解压，动作同 zgrep</span><br><span class="line"></span><br><span class="line">--binary-files=value  value为binary， 则默认搜索二进制文件，但是不输出。value为without-match,则不处理二进制文件， </span><br><span class="line"> 	value为text ， 二进制文件当做text文件进行查找 输出</span><br><span class="line"></span><br><span class="line">--context=num 输出匹配行的前后num行内容， 和 -C 一样, 默认值为2</span><br><span class="line"></span><br><span class="line">--line-buffered 强制输出为line buffered， 默认标准输出为terminal时，使用line-buffered， 其他使用block buffered</span><br><span class="line"></span><br><span class="line">如果没有指定输入文件， 则输入为标准输入。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>GREP_OPTIONS 变量可以设置默认的选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GREP_OPTIONS=&#x27;-i -n -H&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Keep:grep keep$ grep &#x27;hello&#x27; hello.md </span><br><span class="line">hello.md:3:啊啊啊   Hello, World!!</span><br><span class="line">hello.md:5:hello world</span><br><span class="line">hello.md:7:helloool man.</span><br><span class="line">hello.md:9:boy helloM</span><br><span class="line">hello.md:15:heLLO+</span><br><span class="line">Keep:grep keep$ </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="命令退出值"><a href="#命令退出值" class="headerlink" title="命令退出值"></a>命令退出值</h2><p>grep命令执行完后，会根据不同情况返回不同的值。</p>
<pre><code>0  有匹配的行
1  没有任何行匹配
&gt;1  命令执行错误
</code></pre>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;patricia&#x27; file_name</span><br><span class="line"></span><br><span class="line">grep &#x27;^\.Pp&#x27; file_name // 查找以.Pp开头的行</span><br><span class="line"></span><br><span class="line">grep -v -e &#x27;foo&#x27; -e &#x27;bar&#x27; filename // 查找没有foo和bar的行 -v </span><br><span class="line"></span><br><span class="line">egrep &#x27;19|20|25&#x27; file_name // 在文件中查找 19， 20， 25</span><br><span class="line"></span><br><span class="line">grep -E &#x27;[0-9]\&#123;1,3\&#125;&#x27; sed.md --color</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p>grep符合 IEEE Std 1003.1-2008 标准。</p>
<h2 id="HISTORY"><a href="#HISTORY" class="headerlink" title="HISTORY"></a>HISTORY</h2><pre><code> The grep command first appeared in Version 6 AT&amp;T UNIX.
</code></pre>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>sed命令使用</title>
    <url>/2020/09/24/2020-20200924-sed/</url>
    <content><![CDATA[<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>stream editor 顾名思义为流编辑工具。通过正则表达式匹配到行，并进行相应处理，输出新行。用于自动编辑文件。</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed 【OPTION】 ... &#123;script-only-if-no-other-script&#125; &#123;input-file&#125; ...</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="sed如何工作"><a href="#sed如何工作" class="headerlink" title="sed如何工作"></a>sed如何工作</h2><p>sed维护两块内存空间，_pattern space 和 _hold space 初始都为空。</p>
<p>sed从输入流中读取一行，删除掉换行，然后把他放到_pattern space。然后执行各个命令。把_pattern space中的内容输出到输出流中，并添加换行符号，继续处理下一行，直到文件末尾。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>sed工具读取给定的文件，如果没有给定文件，读取标准输入。然后根据给定的一系列命令修改输入的内容。最后把修改内容输出到标准输出中。</p>
<p>一个单独的命令可以通过第一个参数传递给sed。 多个命令的话， 可以通过制定-e 或者-f选项设置。所有命令按顺序应用到输入。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>支持如下选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-n, --quit, --silent 静默, 只输出匹配正则表达式的行，默认的所有行都会输出</span><br><span class="line"></span><br><span class="line">-e script , --expression=script 添加一个脚本执行命令</span><br><span class="line"></span><br><span class="line">-f script-file  从文件中读取命令添加到执行命令</span><br><span class="line"></span><br><span class="line">--follow-symlinks 处理符号链接指向的文件，默认不处理</span><br><span class="line"></span><br><span class="line">-i[SUFFIX] --inplace=SUFFIX 直接修改文件的内容，如果指定了后缀， 会把源文件重命名为以后缀结尾的文件，原始文件用来保存结果。</span><br><span class="line">   sed -e &#x27;s/123/xxx &amp;/&#x27; -ib sed.md // 直接修改sed.md 同时备份内容到sed.mdb文件</span><br><span class="line"></span><br><span class="line">-c 指定-i时，使用copy而不是重命名。</span><br><span class="line"></span><br><span class="line">--posix disable all GNU extensions</span><br><span class="line"></span><br><span class="line">-l N, --line-length=N 指定长行的换行， 0 表示从不为长行换行， 默认70</span><br><span class="line"></span><br><span class="line">   -r 指定正则表达式属于扩展正则表达式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Address-Range"><a href="#Address-Range" class="headerlink" title="Address Range"></a>Address Range</h3><p>执行命令可以指定行，[address] commands</p>
<p>指定行的格式可以如下：</p>
<ul>
<li>‘NUMBER’, 指定特定行号<br>  sed ‘$p’ sed.md</li>
<li>‘First~Step’，从第几行开始，每次跳跃Step行</li>
<li>‘$’, 文件最后一行</li>
<li>‘&#x2F;REGEXP&#x2F;‘, 匹配REGEX的行</li>
<li>‘%REGEXP%’，匹配REGEX的行  %是分隔符</li>
<li>‘Start， end’ 指定范围<br>  sed -ne ‘3,5p’ sed.md<br>  sed -ne ‘1,&#x2F;888&#x2F;p’ sed.md &#x2F;&#x2F; 1-匹配888</li>
</ul>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul>
<li>‘CHAR’ 匹配普通字符 ‘CHAR’</li>
<li><ul>
<li>   匹配前一个字符0到多个</li>
</ul>
</li>
<li>. 匹配任一字符</li>
<li>^ 以什么开头</li>
<li>$ 以什么结尾</li>
<li>[LIST] 匹配LIST中的任一字符</li>
<li>[^LIST] 不属于LIST中的任一字符</li>
<li>REGEXP1|REGEXP2 匹配REGEXP1或者REGEXP2</li>
<li>REGEXP1REGEXP2 整串连续匹配REGEXP1, REGEXP2</li>
<li>\n 匹配换行</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li><p>‘#’ 用来做注释的， 把命令写在文件中时使用， 用来注释</p>
</li>
<li><p>d 删除匹配的行  sed ‘&#x2F;^$&#x2F;d’ file</p>
</li>
<li><p>p 打印匹配的行  sed  ‘3p’ file</p>
</li>
<li><p>{COMMANDS} 多个命令，使用分号分割</p>
</li>
<li><p>s 替换命令  s&#x2F;REGEX&#x2F;REPLACEMENT&#x2F;FLAGS<br>  sed s&#x2F;2&#x2F;II&#x2F; sed.md<br>  sed s&#x2F;1&#x2F;I&#x2F;1 sed.md<br>  sed s&#x2F;1\2&#x2F;I&#x2F; sed.md<br>  FLAGS：<br>  - g 替换所有匹配行<br>  - NUMBER 替换指定第几次匹配的行<br>  - p print new pattern space<br>  - w FILE_NAME 匹配的结果写入文件<br>  - r FILE_NAME 读取文件插入到匹配的行<br>  - &amp; 前面匹配的字符  sed ‘s&#x2F;222&#x2F;xxx &amp;&#x2F;‘ sed.md</p>
</li>
<li><p>! 表示命令对不匹配的行生效</p>
</li>
</ul>
<p><strong>命令最好使用单引号包含起来</strong></p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>执行成功返回0， 出错返回 &gt;0 </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sed -n  &#x27;/[0-9]\&#123;1,3\&#125;/p&#x27; sed.md  // 显示含有数字的行</span><br><span class="line">sed -n -e &#x27;/.*inux/p&#x27; sed.md		// 输出包含inux的行</span><br><span class="line">sed -ne  &#x27;/2\&#123;1,3\&#125;/p&#x27; sed.md</span><br><span class="line">sed ‘s/^ *//‘  删除前导空格</span><br><span class="line">sed ’s/ *$//’ 删除行尾空格</span><br></pre></td></tr></table></figure>

<p>以上是常用的一些命令， 还有许多其他命令，更多内容建议参考’man sed’</p>
<p>网络上有一篇博客写的挺详细的， <a href="https://www.cnblogs.com/maxincai/p/5146338.html">链接</a></p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>位域左移溢出问题</title>
    <url>/2020/09/14/2020-20200914-overflow/</url>
    <content><![CDATA[<p>上一周，我在调试项目性能指标时遇到了一个问题，支持的节点数在到达60718644时，程序就出错了。由于节点索引是一个27位的结构体位域，当值为60718644时，最高位为1，此时，代码中有一个转换函数，作了对位域的左移操作并赋给一个更大空间类型的变量，使得最后的结果不是预期的。show u code:</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef union src_s &#123;</span><br><span class="line">    unsigned int rawdata;</span><br><span class="line">    struct &#123;</span><br><span class="line">        unsigned int  type: 1,                    </span><br><span class="line">                    id: 4,</span><br><span class="line">                    index: 27;</span><br><span class="line">                    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125; src_t;</span><br><span class="line"></span><br><span class="line">typedef union dst_s &#123;</span><br><span class="line">    unsigned int rawdata[2];</span><br><span class="line">    struct &#123;</span><br><span class="line">        unsigned : 28;</span><br><span class="line">        unsigned high: 4;</span><br><span class="line">        unsigned int data;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; dst_t;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    src_t data;</span><br><span class="line">    data.type = 0;</span><br><span class="line">    data.id = 0;</span><br><span class="line">    data.index = 67108869; // 最高位当作符号位了?</span><br><span class="line"></span><br><span class="line">    printf(&quot;base rawdata 0x%x index %x\r\n&quot;, data.rawdata, data.index);</span><br><span class="line">    //unsigned long long result = ((unsigned long long)data.index &lt;&lt; 5) + 9;</span><br><span class="line">    unsigned long long result = (data.index &lt;&lt; 5) + 9;</span><br><span class="line">    printf(&quot;result  %llx %llu high32 %llx \r\n&quot;, result, result, result&gt;&gt;32);</span><br><span class="line"></span><br><span class="line">    dst_t dst;</span><br><span class="line">    dst.data = result;</span><br><span class="line">    dst.high = result&gt;&gt;32;</span><br><span class="line">    printf(&quot;result [0] 0x%x [1] 0x%x\r\n&quot;, dst.rawdata[0], dst.rawdata[1]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Keep:test keep$ ./a</span><br><span class="line">base rawdata 0x80000000 index 4000000</span><br><span class="line">result  ffffffff80000009 18446744071562067977 high32 ffffffff </span><br><span class="line">result [0] 0xf0000000 [1] 0x80000009</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>(data.index &lt;&lt; 5) + 9;</code>运算的结果 并不是预期的 80000009，而是高位全为f的ffffffff80000009。 此时如果对data.index进行强转，再左移则结果正确.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Keep:test keep$ ./a</span><br><span class="line">base rawdata 0x80000000 index 4000000</span><br><span class="line">result  80000009 2147483657 high32 0 </span><br><span class="line">result [0] 0x0 [1] 0x80000009</span><br></pre></td></tr></table></figure>

<p>可见，编译器把位域的值强转为了一个有符号的数进行左移，然后赋值给一个更大地址空间的类型。</p>
<p>通过代码汇编可以看出具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">unsigned long a = data.index &lt;&lt; 5;</span><br><span class="line">      2f:       8b 45 f8        movl    -8(%rbp), %eax</span><br><span class="line">      32:       c1 e8 05        shrl    $5, %eax</span><br><span class="line">      35:       c1 e0 05        shll    $5, %eax</span><br><span class="line">      38:       48 63 c8        movslq  %eax, %rcx   // 高位符号扩展 赋值</span><br><span class="line">      3b:       48 89 4d f0     movq    %rcx, -16(%rbp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ; unsigned  a = data.index &lt;&lt; 5;</span><br><span class="line">      2f:       8b 45 f8        movl    -8(%rbp), %eax</span><br><span class="line">      32:       c1 e8 05        shrl    $5, %eax</span><br><span class="line">      35:       c1 e0 05        shll    $5, %eax</span><br><span class="line">      38:       89 45 f4        movl    %eax, -12(%rbp) // 直接赋值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; unsigned long a = (unsigned long)data.index &lt;&lt; 5;</span><br><span class="line">      2f:       8b 45 f8        movl    -8(%rbp), %eax</span><br><span class="line">      32:       c1 e8 05        shrl    $5, %eax</span><br><span class="line">      35:       89 c0   movl    %eax, %eax</span><br><span class="line">      37:       89 c1   movl    %eax, %ecx</span><br><span class="line">      39:       48 c1 e1 05     shlq    $5, %rcx		// 逻辑左移</span><br><span class="line">      3d:       48 89 4d f0     movq    %rcx, -16(%rbp) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>针对位域左移，赋值给更大地址空间的情况，最好进行类型强转一下再左移。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(一)-感悟及简介</title>
    <url>/2020/10/20/2020-20201020-linux1/</url>
    <content><![CDATA[<p>这个月有时间刷完了一遍极客时间上面订阅的《趣谈linux操作系统》这个专栏， 可以说比较系统的梳理了一下操作系统相关的基础知识。这个专栏是去年12.04号订阅的了， 订阅这个专栏的初衷是当时在准备换工作，发现工作后操作系统的知识只剩大学操作系统课程学习后的遗留映像，很多东西都模糊了，想着要好好全面的补一把相关知识，陆陆续续的学习了近10个月了，里面的内容应该还算是干货满满， 从原理到代码的讲解还是比较细节的。刷完一遍感觉收获多多，不论是复习巩固，还是温故而知新，都有所得。后面还需要安排二刷、三刷。里面有一个很好的观点， 读书先把书读厚，再把书读薄，又把书读厚。。。 其实，一直以来我学习也是按照这个套路来学习，一万小时定律嘛。</p>
<span id="more"></span>

<p>照例学习完了，做一个小结。</p>
<h2 id="学习指南"><a href="#学习指南" class="headerlink" title="学习指南"></a>学习指南</h2><ul>
<li>学习linux命令行</li>
<li>系统调用的学习</li>
<li>Linux内核机制了解</li>
<li>Linux源码学习， 场景分析</li>
<li>真实开发, 动手巩固</li>
<li>持续学习</li>
</ul>
<h2 id="Linux系统综述"><a href="#Linux系统综述" class="headerlink" title="Linux系统综述"></a>Linux系统综述</h2><p>计算机实体由多种硬件组成， 操作系统是控制系统的灵魂与核心。</p>
<img src="/images/202010/pchd.jpeg" alt="图片替换文本" width="600" height="313" align="bottom" />

<p>操作系统还是一个软件平台， 控制多个软件的运行。内核是操作系统的核心。通过驱动对接输入输出设备，系统调用提供内核接口。中断响应事件等。文件管理系统保存二进制程序，进程管理子系统管理软件运行时调度，内存管理子系统分配资源。还有网络子系统，设备子系统等。</p>
<img src="/images/202010/osystem.jpeg" alt="图片替换文本" width="600" height="313" align="bottom" />

<img src="/images/202010/kernalcode.jpg" alt="图片替换文本" width="600" height="313" align="bottom" />


<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p>计算机各个组件通过总线相连：<br><img src="/images/202010/osconnect.jpeg" alt="图片替换文本" width="600" height="313" align="bottom" /></p>
<p>CPU分为运算单元、数据单元和控制单元。</p>
<p>统一开放的硬件平台， x86。</p>
<p>计算机断电重置地址 –》 ROM 开始运行BIOS –》Grub Linxu启动管理器</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>awk命令使用</title>
    <url>/2020/09/30/2020-20200930-awk/</url>
    <content><![CDATA[<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>awk是一个用于模式匹配和处理的语言，有相应的语法。</p>
<span id="more"></span>

<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk OPTIONS PATTERN_ACTION files</span><br></pre></td></tr></table></figure>

<p>和grep、sed差不多都是这样的格式。 指定awk通过文件读取内容，每一行都根据模式作匹配，然后作相应的动作。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Ffs 指定分隔符为fs， 默认是空格/tab</span><br><span class="line">	awk -F&quot;:&quot; &#x27;&#123; print $1 &#125;&#x27; /etc/passwd</span><br><span class="line">-v val=value 设置变量val的值</span><br><span class="line">	awk -v count=10 &#x27;BEGIN&#123;print &quot;start &quot;, count&#125; /this/ &#123;count++;print $1 $2 $3&#125; END&#123;print count&quot;lines&quot;&#125;&#x27; aw</span><br><span class="line">-f file 指定命令的来源文件</span><br></pre></td></tr></table></figure>

<h2 id="模式动作"><a href="#模式动作" class="headerlink" title="模式动作"></a>模式动作</h2><p>格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#x27;pattern &#123; action &#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>A  missing  {  action  } means print the line; a missing pattern always matches.</p>
<p>action是一系列的语句， 类似C语言的语法。 可以调用内置的函数 比如 length， 还有条件语句、循环语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27; &#123; if(length &gt; 10) print NR&#125;&#x27; file // 输出满足条件的行</span><br></pre></td></tr></table></figure>

<p>可能的语句形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if( expression ) statement [ else statement ]</span><br><span class="line">while( expression ) statement</span><br><span class="line">for( expression ; expression ; expression ) statement</span><br><span class="line">for( var in array ) statement</span><br><span class="line">do statement while( expression )</span><br><span class="line">break</span><br><span class="line">continue</span><br><span class="line">&#123; [ statement ... ] &#125;</span><br><span class="line">expression              # commonly var = expression</span><br><span class="line">print [ expression-list ] [ &gt; expression ]</span><br><span class="line">printf format [ , expression-list ] [ &gt; expression ]</span><br><span class="line">return [ expression ]</span><br><span class="line">next                    # skip remaining patterns on this input line</span><br><span class="line">nextfile                # skip rest of this file, open next, start at top</span><br><span class="line">delete array[ expression ]# delete an array element</span><br><span class="line">delete array            # delete all elements of array</span><br><span class="line">exit [ expression ]     # exit immediately; status is expression</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>语句指定由分号、换行符或者括号分隔。</p>
<p>一个空的语句，代表整行 $0。字符串用双引号包含着。</p>
<p>还支持运算符运算。</p>
<p>变量可以为常量、数组或者域。 默认被初始化为null 字符串。数组元素可以是字符串，而不必须是数字。数组还指出多维下标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo | awk &#x27;BEGIN&#123;s[3,2,5]=100; &#123;print  s[3,2,5]&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>print函数可以输出内容到标准输出， 也可以输出到文件 &gt; &#x2F; &gt;&gt; 或者管道。</p>
<p>有些全局的，而不是针对行的动作， 可以通过BEGIN和END块来执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">netstat | awk &#x27;/^tcp.*keep/&#x27;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>网络上的博客挺完整的 <a href="https://www.cnblogs.com/ginvip/p/6352157.html">链接</a></p>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>至此， 终于把linux命令三剑客粗略的过了一遍。使用的时候再查一下，达到会基本使用的地步了。Great!</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(二)-系统内核体系结构</title>
    <url>/2020/11/18/2020-20201118-linux2/</url>
    <content><![CDATA[<h2 id="系统内核体系结构"><a href="#系统内核体系结构" class="headerlink" title="系统内核体系结构"></a>系统内核体系结构</h2><p>操作系统是一个挺复杂的软件平台， 运行在其上的程序本身需要存储，涉及到文件管理子系统；运行时需要资源，涉及到内存管理子系统、进程管理子系统、系统调用子系统；如果程序与其他机器通信， 涉及网络子系统。运行时需要与用户交互，如显示 涉及设备子系统。 操作系统的内核主要就包含了这些子系统。</p>
<span id="more"></span>

<img src="/images/202011/linux2_system.png" alt="图片替换文本" width="600" height="313" align="bottom" />

<h2 id="Linux-命令行"><a href="#Linux-命令行" class="headerlink" title="Linux 命令行"></a>Linux 命令行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd // 更新密码</span><br><span class="line"></span><br><span class="line">useradd sovran // 添加用户sovran, 可以到/etc/passwd 查看</span><br><span class="line"></span><br><span class="line">passwd sovran //为sovran设置密码</span><br><span class="line"></span><br><span class="line">ls 查看文件目录</span><br><span class="line"></span><br><span class="line">chmod +x file //修改文件属性 添加可执行</span><br><span class="line"></span><br><span class="line">chown 更新用户 </span><br><span class="line"></span><br><span class="line">rpm -i jdk-XXX_linux-x64_bin.rpm  // centos 进行安装  下载的rpm软件包</span><br><span class="line">dpkg -i jdk-XXX_linux-x64_bin.deb  // centos 进行安装 下载的deb软件包</span><br><span class="line"></span><br><span class="line">ps -ef | grep program-name | awk `&#123;print $2&#125;` | xargs kill -9 // kill 指定名称的进程</span><br><span class="line"></span><br><span class="line">nohub command </span><br></pre></td></tr></table></figure>

<p>如果需要了解具体命令行的详细使用， 可以使用 <code>man command</code> 查看</p>
<p>Linux 命令行</p>
<img src="/images/202011/linux2_cmd.jpg" alt="图片替换文本" width="600" height="350" align="bottom" />






<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(三)-系统调用</title>
    <url>/2020/11/21/2020-20201121-linux3/</url>
    <content><![CDATA[<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>操作系统内核给软件提供接口的方式主要就是系统调用。系统调用提供了许多功能，这里只讲一些开发常用的。</p>
<span id="more"></span>

<h3 id="进程创建-fork"><a href="#进程创建-fork" class="headerlink" title="进程创建 fork"></a>进程创建 fork</h3><p>当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。通过fork函数的返回值判断当前线程是父进程、还是子进程。子进程返回0， 父进程返回创建的子进程id。根据进程号，后续进行不同的处理流程。</p>
<p>系统调用waitpid，父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>分配内存的系统调用，brk和mmap。当分配的内存数量比较小的时候，使用 brk，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。当分配的内存数量比较大的时候，使用 mmap，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>对于已经有的文件，可以使用open打开这个文件，close关闭这个文件；<br>对于没有的文件，可以使用creat创建文件；<br>打开文件以后，可以使用lseek跳到文件的某个位置；<br>可以对文件的内容进行读写，读的系统调用是read，写是write</p>
<p>Linux一切皆是文件。</p>
<h3 id="异常与信号"><a href="#异常与信号" class="headerlink" title="异常与信号"></a>异常与信号</h3><p>当程序运行时，遇到外部或者内部的异常，需要作对应的处理。</p>
<p>经常遇到的信号有以下几种：</p>
<ul>
<li>在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出；</li>
<li>如果非法访问内存，例如你跑到别人的会议室，可能会看到不该看的东西；</li>
<li>硬件故障，设备出了问题，当然要通知项目组；</li>
<li>用户进程通过kill函数，将一个用户信号发送给另一个进程。</li>
</ul>
<p>当项目组收到信号的时候，项目组需要决定如何处理这些异常情况。对于一些不严重的信号，可以忽略，该干啥干啥，但是像 SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）是不能忽略的，可以执行对于该信号的默认动作。每种信号都定义了默认的动作，例如硬件故障，默认终止；也可以提供信号处理函数，可以通过sigaction系统调用，注册一个信号处理函数。提供了信号处理服务，项目执行过程中一旦有变动，就可以及时处理了。</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>主要有消息队列、共享内存、信号量等机制相关系统调用。</p>
<p>进程间通信，主要用于不同进程间的信息传递。</p>
<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>不同机器间进行通信的唯一手段。不同进程间也可以使用网络通信实现进程间的通信。主要就是socket的系统调用。</p>
<h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><p>Glibc是linux系统下的一个C标准库，Glibc封装了许多系统调用，屏蔽了一些底层的细节，更便于开发者调用。</p>
<p>有时候，Glibc 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用。也有时候，多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 malloc、calloc、free 等函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用。</p>
<h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>strace命令可以跟着程序的系统调用情况。显示系统调用的记录，还是比较详细的。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(四)-工作模式</title>
    <url>/2020/12/08/2020-20201208-linux4/</url>
    <content><![CDATA[<h2 id="计算机的工作模式"><a href="#计算机的工作模式" class="headerlink" title="计算机的工作模式"></a>计算机的工作模式</h2><p>计算机由CPU、内存、硬盘以及其它各种硬件组成。CPU与内存、硬盘等设备通过总线来交互。</p>
<span id="more"></span>

<img src="/images/202012/linux_connect.png" alt="图片替换文本" width="600" height="313" align="bottom" />


<p>CPU包含运算单元、数据单元和控制单元。运算单元用于计算、数据单元保存数据， 控制单元存放指令地址。</p>
<img src="/images/202012/linux_cpu.png" alt="图片替换文本" width="600" height="313" align="bottom" />

<p>同样的，总线上主要有两类数据，一个是地址数据，也就是我想拿内存中哪个位置的数据，这类总线叫地址总线（Address Bus）；另一类是真正的数据，这类总线叫数据总线（Data Bus）。</p>
<h2 id="X86历史"><a href="#X86历史" class="headerlink" title="X86历史"></a>X86历史</h2><p>最早地址总线设计成20位， 可以访问的地址大小为 起始地址&lt;&lt;4+偏移</p>
<img src="/images/202012/linux_cpu2.png" alt="图片替换文本" width="600" height="313" align="bottom" />

<p>数据单元，CPU内部包含了8个通用寄存器，用于保存数据。这些寄存器比较灵活，其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。</p>
<p>控制单元，IP地址指令寄存器。有四个 16 位的段寄存器，分别是 CS、DS、SS、ES。</p>
<p>16位的处理器大概就是这样子的。</p>
<h3 id="32位处理器"><a href="#32位处理器" class="headerlink" title="32位处理器"></a>32位处理器</h3><p>大部分寄存器扩展为32位，栈寄存器保存为段选择子，用于选择段起始地址。</p>
<img src="/images/202012/linux_cpu3.png" alt="图片替换文本" width="600" height="313" align="bottom" />


<p>到了 32 位的系统架构下，我们将前一种模式称为实模式（Real Pattern），后一种模式称为保护模式（Protected Pattern）。</p>
<p>直接操作寄存器可以通过汇编指令，大学时用汇编代码编写过跑马灯小程序，感觉还是挺cool的。操作系统或者许多嵌入式的系统使用了许多汇编代码直接操作寄存器，可以显著的提高程序执行的效率，只是不大可读。需要辅助注释。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(六)-内核启动</title>
    <url>/2020/12/09/2020-20201209-linux6/</url>
    <content><![CDATA[<h2 id="内核的启动代码流程"><a href="#内核的启动代码流程" class="headerlink" title="内核的启动代码流程"></a>内核的启动代码流程</h2><p>内核启动代码位于 init&#x2F;main.c中的start_kernel函数。start_kernel函数初始化内核的多个模块。</p>
<span id="more"></span>

<img src="/images/202012/linux_kernel.png" alt="图片替换文本" width="600" height="313" align="bottom" />

<p>这里还创建了0号、1号、2号进程。0号进程是第一个进程，唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个。1号进程是第一个用户进程，也是所有用户态进程的祖先。</p>
<p>进程之间需要隔离资源，因此系统有了权限分层的机制。</p>
<img src="/images/202012/linux_layer.jpg" alt="图片替换文本" width="600" height="313" align="bottom" />


<p>当一个用户态的程序运行到一半，要访问一个核心资源，例如访问网卡发一个网络包，就需要暂停当前的运行，调用系统调用，接下来就轮到内核中的代码运行了。</p>
<p>首先，内核将从系统调用传过来的包，在网卡上排队，轮到的时候就发送。发送完了，系统调用就结束了，返回用户态，让暂停运行的程序接着运行。</p>
<p>系统调用资源需要保存，调用之后再恢复。</p>
<img src="/images/202012/linux_save.jpeg" alt="图片替换文本" width="600" height="313" align="bottom" />

<p>创建1号进程的时候，需要访问1号进程的程序，这个程序是保存在ramdisk系统中的， ramdisk系统是一个内存文件系统， 因为我们访问设备的时候需要驱动，不同的设备驱动又不一样，不可能在内核里面内置所有的驱动，因此我们默认加载了ramdisk文件系统， 1号进程的文件 init就放在ramdisk中，从而可以快速的读取执行并运行init。1号进程是所有用户态进程的祖先。</p>
<p>同理，2号进程 kthreadd，是所有内核态进程的祖先。</p>
<img src="/images/202012/linux_init.jpeg" alt="图片替换文本" width="600" height="313" align="bottom" />



<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(七)-系统调用流程</title>
    <url>/2020/12/10/2020-20201210-linux7/</url>
    <content><![CDATA[<h2 id="系统调用流程"><a href="#系统调用流程" class="headerlink" title="系统调用流程"></a>系统调用流程</h2><p>32位的系统调用的过程，首先保存参数、系统调用号到寄存器，然后触发中断int80 ，调用中断处理服务函数，然后取到寄存器里的参数，根据系统调用号获取执行函数，传入参数执行。执行完成后，iret恢复用户态执行上下文，继续执行。</p>
<span id="more"></span>

<img src="/images/202012/linux_syscall32.jpg" alt="图片替换文本" width="600" height="513" align="bottom" />


<p>64位系统调用流程和32位的有区别，他是通过syscall指令，而不是中断来触发调用的，相应的寄存器也不相同了。syscall使用了特殊的模块寄存器MSR，用来保存64位系统调用函数的地址。syscall指令会从MSR中读取函数地址来执行系统调用号对应的函数， 地址是在初始化的时候写入的start_kernel–&gt;cpu_init–&gt;syscall_init。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wrmsrl(MSR_LSTAR, (unsigned long)entry_SYSCALL_64);</span><br></pre></td></tr></table></figure>

<p>最后调用sysiretq 恢复用户态执行上下文，继续执行。</p>
<img src="/images/202012/linux_syscall64.jpg" alt="图片替换文本" width="600" height="513" align="bottom" />

<h2 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h2><p>系统调用函数都是从系统调用表中根据系统调用号找到的。那么系统调用表sys_call_table是个什么鬼呢？</p>
<p>32 位的系统调用表定义在 arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_32.tbl 文件里。64 位的系统调用定义在另一个文件 arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_64.tbl 里。</p>
<p>系统调用在内核中的实现函数要有一个声明。声明往往在 include&#x2F;linux&#x2F;syscalls.h 文件中。例如 sys_open 是这样声明的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user *filename,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> flags, <span class="type">umode_t</span> mode)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般程序调用glibc封装的系统调用， 比如open函数的一个调用流程如图：</p>
<img src="/images/202012/linux_syscall_open.jpg" alt="图片替换文本" width="600" height="913" align="bottom" />



<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>ps命令使用小结</title>
    <url>/2020/12/15/2020-20201215-ps/</url>
    <content><![CDATA[<p>ps命令大家最熟悉不过了，经常用来查看系统资源及进程的基础信息。 使用管道导出结果到grep， xarg等命令，实现一些定位的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps --help</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<img src="/images/202012/ps_help.jpg" alt="图片替换文本" width="600" height="513" align="bottom" />

<p>可以看到<code>ps</code>命令后面的选项大概分为5种， 简单选择项，指定选择项，输出格式项，指定长选项和混合选项。正常情况下，前面的4种选项，只能选择其中的一个选项参数，不同的种类间可以混合设置。基于兼容处理，如果有选项不能混合的话， 会显示一行warning，然后再继续显示。</p>
<p>具体的还可以看一下 <code>man ps</code></p>
<p><code>ps</code>显示当前进程的一个快照信息。可以通过选项设置显示的进程，如果希望持续更新显示进程信息可以使用<code>top</code>命令。</p>
<p>不同版本的<code>ps</code>可以支持多种种类的选项。</p>
<ul>
<li>UNIX选项格式， 必须使用<code>-</code>连接，可以组合多个选项</li>
<li>BSD选项格式，不能使用<code>-</code>连接，可以组合多个选项</li>
<li>GNU类型长选项，需要两个<code>-</code>作为前导符号</li>
</ul>
<p>不同种类的选项可能一起出现，但是可能会出现冲突。不同格式的有些选项功能是相同的，ps也会作兼容处理。</p>
<p>默认的，ps会显示相同用户id下的所有进程(euid&#x3D;EUID)和当前终端启动的进程，输出的进程一般是未作排序的。ps会显示PID、关联的终端名TTY、累积的CPU运行时间(实际的还是总的？)TIME、可执行文件名(CMD)。</p>
<p>BSD格式的选项，还会显示进程的状态STAT, 使用进程名加参数的形式替换可执行文件名，当然这是可以设置的，可以设置环境变量PS_FORMAT(没试过，后面补充看看)。</p>
<p>默认的许多进程是不被显示的，只有通过设置了选项，符合选项设置的进程信息才能显示出来。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看每个进程的信息，标准格式</span><br><span class="line">ps -e</span><br><span class="line">ps -ef</span><br><span class="line">ps -eF</span><br><span class="line">ps -ely</span><br><span class="line"></span><br><span class="line">查看每个进程的信息， BSD格式</span><br><span class="line">ps ax</span><br><span class="line">ps axu</span><br><span class="line"></span><br><span class="line">查看进程树</span><br><span class="line">ps -ejH</span><br><span class="line">ps axjf</span><br><span class="line"></span><br><span class="line">获取线程的信息</span><br><span class="line">ps -eLf</span><br><span class="line">ps axms</span><br><span class="line"></span><br><span class="line">显示安全信息? // TODO需要了解一下 内核中进程的结构</span><br><span class="line">ps -axZ</span><br><span class="line">ps -eM</span><br><span class="line"></span><br><span class="line">作为root用户运行的进程，用户格式</span><br><span class="line">ps -U root -u root u</span><br><span class="line"></span><br><span class="line">使用用户自定义的格式查看每个进程</span><br><span class="line">ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wcha:14,comm </span><br><span class="line">ps axo stat,euid,ruid,tty,comm</span><br><span class="line">ps -eopid,tt,user,fname,tmout,f,wchan</span><br><span class="line"></span><br><span class="line">只查看指定进程名的pid的信息</span><br><span class="line">ps -C init -o pid=</span><br><span class="line"></span><br><span class="line">只查看进程id为42的进程名</span><br><span class="line">ps -p 42 -o comm=</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多的功能，可以组合选项尝试输出一下。</p>
<h2 id="CPU运行时间"><a href="#CPU运行时间" class="headerlink" title="CPU运行时间"></a>CPU运行时间</h2><p>运行时间分几种，一种是程序结束的时间减去程序开始的时间，即自然时间 Wall Clock Time. 还有一种是实际占用CPU的运行时间，因为CPU同时需要运行多个程序，不断的在程序间切换。可以使用time命令查看某个程序的运行时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Keep:~ keep$ time ps</span><br><span class="line">  PID TTY           TIME CMD</span><br><span class="line">  455 ttys000    0:00.01 /bin/bash -l</span><br><span class="line">  456 ttys001    0:00.01 /bin/bash -l</span><br><span class="line">  906 ttys002    0:00.03 -bash</span><br><span class="line"></span><br><span class="line">real	0m0.017s</span><br><span class="line">user	0m0.002s</span><br><span class="line">sys	0m0.011s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个是 real time，也就是我们说的 Wall Clock Time，也就是运行程序整个过程中流逝掉的时间；第二个是 user time，也就是 CPU 在运行你的程序，在用户态运行指令的时间；第三个是 sys time，是 CPU 在运行你的程序，在操作系统内核里运行指令的时间。而程序实际花费的 CPU 执行时间（CPU Time），就是 user time 加上 sys time, ps中显示的就是这个时间。</p>
<h2 id="小常识"><a href="#小常识" class="headerlink" title="小常识"></a>小常识</h2><p>近期项目在测试过程中，经常出现一些包解析错误的问题。主要是通过测试仪构造了一些mac、ip或者端口递增的报文。由于某一些ip或者端口是有特殊用途的，导致在报文解析的过程中，由于这些报文的格式不符合规范而被解析成错误报文。</p>
<p>主要有这几个问题：</p>
<ul>
<li>源mac为组播mac</li>
<li>源ip为组播ip</li>
<li>源ip为回环口ip， ipv4 127.0.0.1 ipv6 ::1</li>
<li>源目ip相同</li>
<li>端口号为2152 信令隧道报文，实际报文错误</li>
<li>ip报文长度错误</li>
<li>ip报文checksum错误</li>
</ul>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(五)-BIOS启动</title>
    <url>/2020/12/08/2020-20201208-linux5/</url>
    <content><![CDATA[<h2 id="BIOS到bootloader"><a href="#BIOS到bootloader" class="headerlink" title="BIOS到bootloader"></a>BIOS到bootloader</h2><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>在主板的ROM上保存有BIOS程序，计算机启动首先读取BIOS（Basic Input and Output System，基本输入输出系统）程序进行运行。此时，计算机运行在实模式下，只能访问1MB的空间。这个1MB的空间也有一个标准的约定。</p>
<span id="more"></span>

<img src="/images/202012/linux_bios.png" alt="图片替换文本" width="600" height="313" align="bottom" />


<p>在 x86 系统中，将 1M 空间最上面的 0xF0000 到 0xFFFFF 这 64K 映射给 ROM，也就是说，到这部分地址访问的时候，会访问 ROM。当电脑刚加电的时候，会做一些重置的工作，将 CS 设置为 0xFFFF，将 IP 设置为 0x0000，所以第一条指令就会指向 0xFFFF0，正是在 ROM 的范围内。在这里，有一个 JMP 命令会跳到 ROM 中做初始化工作的代码，于是，BIOS 开始进行初始化的工作。</p>
<p>BIOS的主要工作就是：检查硬件状态是否完好， 建立一个中断向量表和中断服务程序，接收输入指令处理并显示交互。</p>
<h3 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h3><p>启动盘的前512字节用于保存主引导记录MBR，保存启动程序boot.img。boot.img加载 grub2 的另一个镜像 core.img。core.img 由 lzma_decompress.img、diskboot.img、kernel.img 和一系列的模块组成，功能比较丰富，能做很多事情。</p>
<img src="/images/202012/linux_bootloader.png" alt="图片替换文本" width="600" height="313" align="bottom" />


<p>boot.img 加载diskboot.img，diskboot.img 的任务就是将 core.img 的其他部分加载进来，先是解压缩程序 lzma_decompress.img，再往下是 kernel.img，最后是各个模块 module 对应的映像。这里需要注意，它不是 Linux 的内核，而是 grub 的内核。</p>
<p>解压lzma_decompress.img的时候会调用real_to_prot，切换到保护模式，这样就能在更大的寻址空间里面，加载更多的东西。</p>
<h3 id="从实模式切换到保护模式"><a href="#从实模式切换到保护模式" class="headerlink" title="从实模式切换到保护模式"></a>从实模式切换到保护模式</h3><p>切换到保护模式的工作：</p>
<ul>
<li>第一项是启用分段，就是在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。</li>
<li>第二项是启动分页。能够管理的内存变大了，就需要将内存分成相等大小的块，这些我们放到内存那一节详细再讲。</li>
</ul>
<p>切换到保护模式后，访问的地址空间就大了。继续运行grub启动程序，选择启动的操作系统。装载启动的内核文件，启动内核。</p>
<img src="/images/202012/linux_startup.jpeg" alt="图片替换文本" width="600" height="913" align="bottom" />




<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(九)-进程数据结构</title>
    <url>/2020/12/16/2020-20201216-linux9/</url>
    <content><![CDATA[<h2 id="进程数据结构"><a href="#进程数据结构" class="headerlink" title="进程数据结构"></a>进程数据结构</h2><p>进程在linux内核中管理，使用了一个统一的结构体 <strong>task_struct</strong></p>
<span id="more"></span>

<img src="/images/202012/linux_task.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<p>内核由一个链表用来存储<strong>task_struct</strong></p>
<h2 id="task-struct内容"><a href="#task-struct内容" class="headerlink" title="task_struct内容"></a>task_struct内容</h2><h3 id="任务ID"><a href="#任务ID" class="headerlink" title="任务ID"></a>任务ID</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">pid_t</span> tgid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span> </span><br></pre></td></tr></table></figure>

<p>任何一个进程，如果只有主线程，那 pid 是自己，tgid 是自己，group_leader 指向的还是自己。但是，如果一个进程创建了其他线程，那就会有所变化了。线程有自己的 pid，tgid 就是进程的主线程的 pid，group_leader 指向的就是进程的主线程。</p>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>结构体中包含了许多信号处理相关的字段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Signal handlers: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>    *<span class="title">signal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span>    *<span class="title">sighand</span>;</span></span><br><span class="line"><span class="type">sigset_t</span>      blocked;</span><br><span class="line"><span class="type">sigset_t</span>      real_blocked;</span><br><span class="line"><span class="type">sigset_t</span>      saved_sigmask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>    <span class="title">pending</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>      sas_ss_sp;</span><br><span class="line"><span class="type">size_t</span>        sas_ss_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>      sas_ss_flags;</span><br></pre></td></tr></table></figure>

<p>定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。</p>
<p>信号处理函数默认使用用户态的函数栈，当然也可以开辟新的栈专门用于信号处理，这就是 sas_ss_xxx 这三个变量的作用。</p>
<p>task_struct 里面有一个 struct sigpending pending。如果我们进入 struct signal_struct *signal 去看的话，还有一个 struct sigpending shared_pending。它们一个是本任务的，一个是线程组共享的。</p>
<h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p>状态相关的变量有3个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">volatile</span> <span class="type">long</span> state;    <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"> <span class="type">int</span> exit_state;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING                    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE              1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE            2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED                  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_TRACED                   8</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;exit_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_DEAD                       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_ZOMBIE                     32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_TRACE                      (EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state again: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_DEAD                       64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL                   128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKING                     256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_PARKED                     512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NOLOAD                     1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NEW                        2048</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STATE_MAX                  4096</span></span><br></pre></td></tr></table></figure>

<p>任务的切换流程</p>
<img src="/images/202012/linux_task_state.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//是否在运行队列上</span></span><br><span class="line"><span class="type">int</span>        on_rq;</span><br><span class="line"><span class="comment">//优先级</span></span><br><span class="line"><span class="type">int</span>        prio;</span><br><span class="line"><span class="type">int</span>        static_prio;</span><br><span class="line"><span class="type">int</span>        normal_prio;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>      rt_priority;</span><br><span class="line"><span class="comment">//调度器类</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span>  *<span class="title">sched_class</span>;</span></span><br><span class="line"><span class="comment">//调度实体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>    <span class="title">se</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span>    <span class="title">rt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span>    <span class="title">dl</span>;</span></span><br><span class="line"><span class="comment">//调度策略</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>      policy;</span><br><span class="line"><span class="comment">//可以使用哪些CPU</span></span><br><span class="line"><span class="type">int</span>        nr_cpus_allowed;</span><br><span class="line"><span class="type">cpumask_t</span>      cpus_allowed;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span>    <span class="title">sched_info</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="结构体内容概览"><a href="#结构体内容概览" class="headerlink" title="结构体内容概览"></a>结构体内容概览</h3><img src="/images/202012/linux_task_content.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />

<h3 id="运行统计信息"><a href="#运行统计信息" class="headerlink" title="运行统计信息"></a>运行统计信息</h3><p>在进程的运行过程中，会有一些统计量，具体你可以看下面的列表。这里面有进程在用户态和内核态消耗的时间、上下文切换的次数等等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">u64        utime;<span class="comment">//用户态消耗的CPU时间</span></span><br><span class="line">u64        stime;<span class="comment">//内核态消耗的CPU时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>      nvcsw;<span class="comment">//自愿(voluntary)上下文切换计数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>      nivcsw;<span class="comment">//非自愿(involuntary)上下文切换计数</span></span><br><span class="line">u64        start_time;<span class="comment">//进程启动时间，不包含睡眠时间</span></span><br><span class="line">u64        real_start_time;<span class="comment">//进程启动时间，包含睡眠时间</span></span><br></pre></td></tr></table></figure>

<h3 id="进程亲缘关系"><a href="#进程亲缘关系" class="headerlink" title="进程亲缘关系"></a>进程亲缘关系</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">real_parent</span>;</span> <span class="comment">/* real parent process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span> <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>      <span class="comment">/* list of my children */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>       <span class="comment">/* linkage in my parent&#x27;s children list */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>保存了父进程、子进程、兄弟进程的信息。</p>
<img src="/images/202012/linux_task_parent.jpeg" alt="图片替换文本" width="600" height="813" align="bottom" />

<p>real_parent 和 parent 是一样的，但是也会有另外的情况存在。例如，bash 创建一个进程，那进程的 parent 和 real_parent 就都是 bash。如果在 bash 上使用 GDB 来 debug 一个进程，这个时候 GDB 是 parent，bash 是这个进程的 real_parent。 具体如何实现的， 还需要深入了解代码后才能清楚。</p>
<h3 id="进程权限"><a href="#进程权限" class="headerlink" title="进程权限"></a>进程权限</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>         *<span class="title">real_cred</span>;</span></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>         *<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure>

<p>real_cred 就是说明谁能操作我这个进程，而 cred 就是说明我这个进程能够操作谁。</p>
<p>cred结构保存的基本上就是一些用户或者组的id， 权限控制时，通过比较这些id来确定是否拥有权限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">        <span class="type">kuid_t</span>          uid;            <span class="comment">/* real UID of the task */</span></span><br><span class="line">        <span class="type">kgid_t</span>          gid;            <span class="comment">/* real GID of the task */</span></span><br><span class="line">        <span class="type">kuid_t</span>          suid;           <span class="comment">/* saved UID of the task */</span></span><br><span class="line">        <span class="type">kgid_t</span>          sgid;           <span class="comment">/* saved GID of the task */</span></span><br><span class="line">        <span class="type">kuid_t</span>          euid;           <span class="comment">/* effective UID of the task */</span></span><br><span class="line">        <span class="type">kgid_t</span>          egid;           <span class="comment">/* effective GID of the task */</span></span><br><span class="line">        <span class="type">kuid_t</span>          fsuid;          <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">        <span class="type">kgid_t</span>          fsgid;          <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">......</span><br><span class="line">        <span class="type">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">        <span class="type">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">        <span class="type">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">        <span class="type">kernel_cap_t</span>    cap_bset;       <span class="comment">/* capability bounding set */</span></span><br><span class="line">        <span class="type">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line">......</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个是 uid 和 gid，注释是 real user&#x2F;group id。一般情况下，谁启动的进程，就是谁的 ID。但是权限审核的时候，往往不比较这两个，也就是说不大起作用。</p>
<p>第二个是 euid 和 egid，注释是 effective user&#x2F;group id。一看这个名字，就知道这个是起“作用”的。当这个进程要操作消息队列、共享内存、信号量等对象的时候，其实就是在比较这个用户和组是否有权限。</p>
<p>第三个是 fsuid 和 fsgid，也就是 filesystem user&#x2F;group id。这个是对文件操作会审核的权限。一般说来，fsuid、euid，和 uid 是一样的，fsgid、egid，和 gid 也是一样的。因为谁启动的进程，就应该审核启动的用户到底有没有这个权限。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>每个进程都有自己独立的虚拟内存空间，这需要有一个数据结构来表示，就是 mm_struct。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>                *<span class="title">mm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>                *<span class="title">active_mm</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="文件与文件系统"><a href="#文件与文件系统" class="headerlink" title="文件与文件系统"></a>文件与文件系统</h3><p>每个进程有一个文件系统的数据结构，还有一个打开文件的数据结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Filesystem information: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>                *<span class="title">fs</span>;</span></span><br><span class="line"><span class="comment">/* Open file information: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>             *<span class="title">files</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<img src="/images/202012/linux_task_content2.jpeg" alt="图片替换文本" width="600" height="813" align="bottom" />



<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>关于工作经验</title>
    <url>/2020/12/22/2020-20201222-experience/</url>
    <content><![CDATA[<p>自从工作以来，渐渐的已经有大概十个年头了。时间真的是很快。自身也在不经意间不断的成长。在程序员这个行当里，有一个广为流传的35岁危机。在我看来，实际只是那些没有成长的人才需要担心。一年的经验用十年和扎扎实实地积累十年工作经验完全是两回事。</p>
<span id="more"></span>

<p>注重自身成长的程序员，即使没有混上个管理者而转型，我觉得也不是什么事，干一行爱一行，喜好在一线编码，走技术路线也是不错的事。国外许多程序员都是过了半百的，依旧在一线挥洒着自己的才华，为改变世界而编码。 哈哈， 有一点儿夸大了。 只是有感而发罢了。</p>
<p>最近现在的公司要切换版本管理工具了， 之前使用svn，后续要更换为git了。用惯svn的员工会觉得多此一举，有点儿抵触的情绪。 而我呢，工作了这么久， svn和git都用过了， 明显感觉git好用嘛。 虽然自己对git的掌握没有达到炉火纯青的地步， 但是应付日常工作还是绰绰有余的。git针对特性开发，多人协作的优势十分明显。 使用git于我而言，这也算是一种工作经验的积累。在他人为了解git的使用而忙碌时，瞬间感觉经验真是个好东西。就像骑单车、开汽车这种经验一样，平常看着没什么，大家想用的时候就去学嘛，挺简单的。但是，实际在需要的时候，是没有那么多的时间给你学习的，而是希望你立马上手。这就解释了，为什么企业希望招那种有工作经验的人，并且某些岗位经验越久越吃香。</p>
<p>同样的，学历也是一种经验的体现。科班出生的，经过完整的系统的学科培养的，基础往往更加扎实。由于有系统的学习经验，尽管当时可能是为了应付考试而学习，终究对课程涉及的理论还是有一定的理解。至于学校的好坏，也很大程度上可以方便的为用人单位提供证明自己比大部分同龄人优秀或者是理解力更好。所以，大部分公司招聘岗位都会要求专业对口，211或者985大学毕业。</p>
<p>另外，在经验的不断累积过程中，善于思考的人大概率会总结出自己的一套做事情的方法，许多未知的领域，只要按自己的方法，花时间认真学习一下，也是可以快速上手的。这就是为什么工作久的人，悟性比较高，容易适应新的工作岗位的原因。</p>
<p>当然，我想说工作经验不仅仅是工作上累积的经验， 还包括自身业余时间学习获得的经验。通过学习，我们可以快速吸收前人的经验，避免走许多弯路。对自身职业生涯有了一定的规划之后， 就制定计划，按步骤步步为营的去实现。时间花在哪儿，你的成就就在哪儿，一万小时定律。如果知道自己的弱项，却不去加强，那么总有一天栽在这里，墨菲定律。正是因为如此，这两年我也不断的在捡起书本学习，扩展自身的知识面。同样一个知识点，懂得的人和不懂的人看事情的角度就是不一样。有经验的人，正是因为经验所以知道哪些坑可以避开，正是因为经验所以知道怎么做事情效果更好，遇到新事物的时候，有自己的一套做事方法，不至于抓瞎。</p>
<p>哦了，不瞎唠叨了。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(十)-进程数据结构</title>
    <url>/2020/12/21/2020-20201221-linux10/</url>
    <content><![CDATA[<h2 id="进程数据结构"><a href="#进程数据结构" class="headerlink" title="进程数据结构"></a>进程数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>    <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="type">void</span>  *<span class="built_in">stack</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="用户态函数栈"><a href="#用户态函数栈" class="headerlink" title="用户态函数栈"></a>用户态函数栈</h3><p>32位函数调用涉及到2个寄存器，ESP（Extended Stack Pointer）是栈顶指针寄存器；另外有一个寄存器 EBP（Extended Base Pointer），是栈基地址指针寄存器，指向当前栈帧的最底部。</p>
<p>A调用B的时候，A的栈中除了存储自身的局部变量，还存储传给B的参数，以及返回A的地址，这样B才知道返回到哪里。B返回的时候，结果存储在eax寄存器中，从栈中弹出A的地址以及给B的参数。</p>
<img src="/images/202012/linux_stack.jpg" alt="图片替换文本" width="600" height="813" align="bottom" />

<p>64位系统，寄存器多一些，rax 用于保存函数调用的返回结果。栈顶指针寄存器变成了 rsp，指向栈顶位置。堆栈的 Pop 和 Push 操作会自动调整 rsp，栈基指针寄存器变成了 rbp，指向当前栈帧的起始位置。还有专门用来传递参数的寄存器，rdi、rsi、rdx、rcx、r8、r9 这 6 个寄存器，用于传递存储函数调用时的 6 个参数。如果超过 6 的时候，还是需要放到栈里面。然而，前 6 个参数有时候需要进行寻址，但是如果在寄存器里面，是没有地址的，因而还是会放到栈里面，只不过放到栈里面的操作是被调用函数做的，就是参数最终是还会放在B的栈里面。</p>
<img src="/images/202012/linux_stack1.jpg" alt="图片替换文本" width="600" height="813" align="bottom" />

<h3 id="内核态函数栈"><a href="#内核态函数栈" class="headerlink" title="内核态函数栈"></a>内核态函数栈</h3><p>Linux 给每个 task 都分配了内核栈，使用的就是stack这个成员变量。</p>
<p>32位系统，内核栈大小为8K， 64位系统，大小为16K。</p>
<p>内核栈的结构：</p>
<img src="/images/202012/linux_stack2.jpeg" alt="图片替换文本" width="600" height="813" align="bottom" />


<p>内核栈里面保存了当前寄存器的内容，调用返回后，再恢复寄存器的值。</p>
<p>在内核态里的调用都有和用户态相似的过程。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(十二) - 主动进程调度/抢占式调度</title>
    <url>/2020/12/23/2020-20201223-linux-schedule-active/</url>
    <content><![CDATA[<p>CPU切换主要有两种方式， 一种是主动释放CPU， 另外一种就是其他进程抢占CPU。</p>
<span id="more"></span>

<h1 id="主动调度"><a href="#主动调度" class="headerlink" title="主动调度"></a>主动调度</h1><p>在操作外部设备的时候，一般需要让出CPU。</p>
<p>主动调度，在linux源码内部调用的schedule函数来主动让出cpu</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">asmlinkage __visible <span class="type">void</span> __sched <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  sched_submit_work(tsk);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">    __schedule(<span class="literal">false</span>);</span><br><span class="line">    sched_preempt_enable_no_resched();</span><br><span class="line">  &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要调动逻辑在__schedule函数，步骤：</p>
<ul>
<li>取出当前cpu的任务队列rq,rq里面有不同的任务队列 cfs, rt, dl等。</li>
<li>获取下一个执行任务</li>
<li>如果下一个执行任务和当前任务不一致，进行上下文切换</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>上下文切换主要干两件事情，一是切换进程空间，也即虚拟内存；二是切换寄存器和 CPU 上下文。</p>
<p>寄存器和栈的切换，它调用到了 __switch_to_asm。这是一段汇编代码，主要用于栈的切换。<br>对于 32 位操作系统来讲，切换的是栈顶指针 esp。<br>对于 64 位操作系统来讲，切换的是栈顶指针 rsp。</p>
<p>在 x86 体系结构中，提供了一种以硬件的方式进行进程切换的模式，对于每个进程，x86 希望在内存里面维护一个 TSS（Task State Segment，任务状态段）结构。这里面有所有的寄存器。</p>
<p>另外，还有一个特殊的寄存器 TR（Task Register，任务寄存器），指向某个进程的 TSS。更改 TR 的值，将会触发硬件保存 CPU 所有寄存器的值到当前进程的 TSS 中，然后从新进程的 TSS 中读出所有寄存器值，加载到 CPU 对应的寄存器中。</p>
<p>所谓的进程切换，就是将某个进程的 thread_struct 里面的寄存器的值，写入到 CPU 的 TR 指向的 tss_struct，对于 CPU 来讲，这就算是完成了切换。</p>
<h2 id="指令指针的保存与恢复"><a href="#指令指针的保存与恢复" class="headerlink" title="指令指针的保存与恢复"></a>指令指针的保存与恢复</h2><p>实际在切换的过程中，指令指针寄存器的值没有改变，只是其他寄存器切成了新进程的值，这样指令指针寄存器运行时，用的全部都是新进程相关的值，也就理所当然的成为新进程的指令指针寄存器。挺绕的，实际就是人还是同一个人，在不同环境下他的地位不一样了，是父亲，是儿子，是丈夫。。。 </p>
<h1 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h1><p>常见的现象就是一个进程执行时间太长了，是时候切换到另一个进程了。在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统，时间又过去一个时钟周期，这是个很好的方式，可以查看是否是需要抢占的时间点。</p>
<p>时钟中断处理函数会调用 scheduler_tick()。函数先取出当前 CPU 的运行队列，然后得到这个队列上当前正在运行中的进程的 task_struct，然后调用这个 task_struct 的调度类的 task_tick 函数。先是调用 sched_slice 函数计算出的 ideal_runtime。判断在这个时间周期内，当前进程占用的时间是否超过了idealtime，超过就需要被抢占了。这个条件之外，还会通过 __pick_first_entity 取出红黑树中最小的进程。如果当前进程的 vruntime 大于红黑树中最小的进程的 vruntime，且差值大于 ideal_runtime，也应该被抢占了。这里只是给任务置了一个标志。</p>
<p>另外一种现象是当一个进程被唤醒的时候。当 I&#x2F;O 到来的时候，进程往往会被唤醒。这个时候是一个时机。当被唤醒的进程优先级高于 CPU 上的当前进程，就会触发抢占。这里也只是给当前运行的任务置了一个标志。</p>
<h2 id="抢占的时机"><a href="#抢占的时机" class="headerlink" title="抢占的时机"></a>抢占的时机</h2><p>真正的抢占还需要时机，也就是需要那么一个时刻，让正在运行中的进程有机会调用一下 __schedule。</p>
<p>不可能某个进程代码运行着，突然要去调用 __schedule，代码里面不可能这么写，所以一定要规划几个时机，这个时机分为用户态和内核态。</p>
<h3 id="用户态的抢占时机"><a href="#用户态的抢占时机" class="headerlink" title="用户态的抢占时机"></a>用户态的抢占时机</h3><p>主要是在系统调用返回和中断处理函数返回的时候，如果有标志位，则进行调用 schedule函数进行调度。可以查看函数exit_to_usermode_loop的实现。</p>
<h3 id="内核态的抢占时机"><a href="#内核态的抢占时机" class="headerlink" title="内核态的抢占时机"></a>内核态的抢占时机</h3><p>对内核态的执行中，被抢占的时机一般发生在 preempt_enable() 中。在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用 preempt_disable() 关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。</p>
<p>同样的，内核态处理中断返回时，也可以触发检查抢占，进行schedule调度。</p>
<p>实际工作中，也用了许多这种设置标记的情况。比如，相同配置连续下发的时候，处理耗时又比较长，每个处理都是不可被中断的。那么，就只能保存最新的那条配置，然后设置标记为需要更新。当配置更新完成后，检查标志位，如果需要更新，再启动新一轮的处理流程。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(十一) - 进程调度</title>
    <url>/2020/12/23/2020-20201223-linux-schedule/</url>
    <content><![CDATA[<p>进程分为实时进程和普通进程。 实时进程需要立刻执行返回结果，普通进程没有这个需求。</p>
<span id="more"></span>

<p>task_struct中有策略信息和优先级信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> policy;</span><br><span class="line"><span class="type">int</span> prio, static_prio, normal_prio;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rt_priority;</span><br><span class="line"></span><br><span class="line"><span class="comment">// policy 取值如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_NORMAL    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_FIFO    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_RR    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_BATCH    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_IDLE    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_DEADLINE    6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于实时进程，优先级的范围是 0～99；对于普通进程，优先级的范围是 100～139。数值越小，优先级越高。</p>
<h2 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h2><p>对于调度策略，其中 SCHED_FIFO、SCHED_RR、SCHED_DEADLINE 是实时进程的调度策略。</p>
<ul>
<li>SCHED_FIFO 就是交了相同钱的，先来先服务，但是有的加钱多，可以分配更高的优先级，也就是说，高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，我们遵循先来先得。</li>
<li>SCHED_RR 轮流调度算法，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务。</li>
<li>SCHED_DEADLINE，是按照任务的 deadline 进行调度的。当产生一个调度点的时候，DL 调度器总是选择其 deadline 距离当前时间点最近的那个任务，并调度它执行。</li>
</ul>
<h2 id="普通调度策略"><a href="#普通调度策略" class="headerlink" title="普通调度策略"></a>普通调度策略</h2><ul>
<li>SCHED_NORMAL 是普通的进程</li>
<li>SCHED_BATCH 是后台进程，几乎不需要和前端进行交互。这类项目可以默默执行，不要影响需要交互的进程，可以降低它的优先级。</li>
<li>SCHED_IDLE 是特别空闲的时候才跑的进程</li>
</ul>
<h2 id="调度策略的实现者，-调度类"><a href="#调度策略的实现者，-调度类" class="headerlink" title="调度策略的实现者， 调度类"></a>调度策略的实现者， 调度类</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br></pre></td></tr></table></figure>

<p>sched_class 有几种实现：</p>
<ul>
<li>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li>
<li>dl_sched_class 就对应上面的 deadline 调度策略；</li>
<li>rt_sched_class 就对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由进程的 task_struct-&gt;policy 指定；</li>
<li>fair_sched_class 就是普通进程的调度策略；</li>
<li>idle_sched_class 就是空闲进程的调度策略。</li>
</ul>
<p>下面是普通进程的调度</p>
<h2 id="完全公平调度算法-CFS"><a href="#完全公平调度算法-CFS" class="headerlink" title="完全公平调度算法 CFS"></a>完全公平调度算法 CFS</h2><p>计算根据进程的优先级分配不同的权重，然后计算每个进程的运行时间值。 对比运行的实际值，小的就优先运行。保证每个进程都可以运行到。</p>
<h2 id="调度队列与调度实体"><a href="#调度队列与调度实体" class="headerlink" title="调度队列与调度实体"></a>调度队列与调度实体</h2><p>进程调度实体涉及的成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span> <span class="title">dl</span>;</span></span><br></pre></td></tr></table></figure>

<p>CFS不同的进程通过把调度的实体挂在红黑树上实现快速的调度。所有可运行的进程通过不断地插入操作最终都存储在以运行时间vruntime为顺序的红黑树中，vruntime 最小的在树的左侧，vruntime 最多的在树的右侧。 CFS 调度策略会选择红黑树最左边的叶子节点作为下一个将获得 CPU 的任务。</p>
<p>每个cpu都有自己的 struct rq 结构，其用于描述在此 CPU 上所运行的所有进程，其包括一个实时进程队列 rt_rq 和一个 CFS 运行队列 cfs_rq。在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去 CFS 运行队列找是否有进程需要运行。</p>
<img src="/images/202012/linux_task_rq.jpeg" alt="图片替换文本" width="800" height="513" align="bottom" />

<p>实现不同进程的调度，是通过按优先级从高到低来遍历调度类的方法来实现的。为了确保进程不被饿死，还需要动态更新进程的优先级，保证长时间未运行的进程随着时间变长而提升优先级，使之可以更快的被调用到。rt_sched_class 先被调用，它会在 rt_rq 上找下一个任务，只有找不到的时候，才轮到 fair_sched_class 被调用，它会在 cfs_rq 上找下一个任务。这样保证了实时任务的优先级永远大于普通任务。</p>
<img src="/images/202012/linux_scedule_q.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />








<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(八)-进程与线程</title>
    <url>/2020/12/16/2020-20201216-linux8/</url>
    <content><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是系统资源调度和分配的基本单位，实现了操作系统的并发； 线程是CPU资源调度与分配的基本单位，实现进程内部的并发。线程属于进程的一部分，是进程的子任务。一个进程至少包含一个线程，相同进程下的线程共享地址空间等资源。每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p>
<span id="more"></span>

<p>线程的创建：</p>
<img src="/images/202012/linux_thread.jpg" alt="图片替换文本" width="600" height="513" align="bottom" />

<h2 id="线程的数据"><a href="#线程的数据" class="headerlink" title="线程的数据"></a>线程的数据</h2><p>线程就是有一个好处，使得一个进程可以并行做多件事。线程间需要共享数据，需要做好数据的同步与互斥。我们称共享的数据为临界区，临界区需要作保护。线程自身也有私有的数据，保存在线程的栈空间内,比如局部变量，默认栈空间为8MB，可以使用ulimit -a查看具体的配置，当然也可以通过设置修改栈的空间大小。还有一种独立的私有数据，通过key设置，不同的线程通过key获取到的值是可能不一样的，各个线程独立保存。</p>
<img src="/images/202012/linux_thread_data.jpg" alt="图片替换文本" width="600" height="513" align="bottom" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);</span><br></pre></td></tr></table></figure>

<h2 id="线程的数据保护"><a href="#线程的数据保护" class="headerlink" title="线程的数据保护"></a>线程的数据保护</h2><p>数据保护一般通过互斥量处理。pthread_mutex_t<br><img src="/images/202012/linux_thread_mutex.jpg" alt="图片替换文本" width="600" height="513" align="bottom" /></p>
<p>互斥量和条件变量结合使用，可以提高cpu处理性能。不用一直条件判断，而是等待条件触发再判断条件。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(十三) - fork进程创建</title>
    <url>/2020/12/28/2020-20201228-linux13-processnew/</url>
    <content><![CDATA[<h1 id="fork进程创建"><a href="#fork进程创建" class="headerlink" title="fork进程创建"></a>fork进程创建</h1><p>第一步就是复制task_struct, 调用copy_process。</p>
<span id="more"></span>

<ul>
<li>申请新的task_struct， 申请新的内核栈空间，赋值给 task_struct 的 void *stack 成员变量；拷贝task_struct的内容， 调用 setup_thread_stack 设置 thread_info。</li>
<li>调用copy_creds，设置权限相关的配置</li>
<li>重新设置进程运行的统计量</li>
<li>设置调度相关的变量 sched_fork， 设置状态、优先级、运行量，调度类等。是否可抢占。</li>
<li>初始化与文件和文件系统相关的变量。复制一个进程打开的文件信息。复制一个进程的目录信息。</li>
<li>初始化与信号相关的变量。 拷贝信号处理函数</li>
<li>复制进程内存空间</li>
<li>分配 pid，设置 tid，group_leader，并且建立进程之间的亲缘关系。</li>
</ul>
<p>第二步，唤醒新的进程wake_up_new_task。</p>
<ul>
<li>将进程的状态设置为 TASK_RUNNING</li>
<li>将 sched_entity 加入到红黑树里面，然后将 se-&gt;on_rq &#x3D; 1 设置在队列上。</li>
<li>调用 check_preempt_curr，看是否能够抢占当前进程。如果可以抢占，给当前进程设置标志。</li>
</ul>
<p>OK， fork系统调用结束后，触发抢占。</p>
<img src="/images/202012/linux13_fork.jpeg" alt="图片替换文本" width="600" height="513" align="bottom" />





<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>《趣谈linux操作系统》小结(十四) - thread_create线程创建</title>
    <url>/2020/12/28/2020-20201228-linux14-thread/</url>
    <content><![CDATA[<h1 id="thread-create线程创建"><a href="#thread-create线程创建" class="headerlink" title="thread_create线程创建"></a>thread_create线程创建</h1><p>线程不是一个完全由内核实现的机制，它是由内核态和用户态合作完成的。pthread_create 不是一个系统调用，是 Glibc 库的一个函数。</p>
<span id="more"></span>

<h2 id="用户态创建线程"><a href="#用户态创建线程" class="headerlink" title="用户态创建线程"></a>用户态创建线程</h2><p>创建线程首先就是要设置线程的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">int</span>                       detachstate;     线程的分离状态</span><br><span class="line">        <span class="type">int</span>                       schedpolicy;     线程调度策略</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>        <span class="title">schedparam</span>;</span>      线程的调度参数</span><br><span class="line">        <span class="type">int</span>                       inheritsched;    线程的继承性</span><br><span class="line">        <span class="type">int</span>                       scope;           线程的作用域</span><br><span class="line">        <span class="type">size_t</span>                    guardsize;       线程栈末尾的警戒缓冲区大小</span><br><span class="line">        <span class="type">int</span>                       stackaddr_set;</span><br><span class="line">        <span class="type">void</span> *                    stackaddr;       线程栈的位置</span><br><span class="line">        <span class="type">size_t</span>                    stacksize;       线程栈的大小</span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>

<p>就像在内核里一样，每一个进程或者线程都有一个 task_struct 结构，在用户态也有一个用于维护线程的结构，就是这个 pthread 结构。</p>
<p>然后就是创建一个线程栈。获取设置的栈大小，申请一段后面添加guard_size大小的空间，作为栈空间，当访问到后面guard_size的空间时报错。栈空间在线程退出后加入到缓存中get_cached_stack，新建线程首先会从缓存中获取适合的空间，否则新建。保存线程的pthread结构到栈空间里面，并且获取guard空间的大小，setup_stack_prot设置其为受保护的。然后就是初始化pthread内对应的值。最后将线程栈添加到stack_used 链表。也就是这个栈正被使用；另一个是 stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。线程栈的管理就是这2个链表来管理的。这个就是用户态栈的创建与管理。</p>
<h2 id="内核态创建任务"><a href="#内核态创建任务" class="headerlink" title="内核态创建任务"></a>内核态创建任务</h2><p>继续上面的逻辑，然后是调用clone系统调用。</p>
<p>如果在进程的主线程里面调用其他系统调用，当前用户态的栈是指向整个进程的栈，栈顶指针也是指向进程的栈，指令指针也是指向进程的主线程的代码。此时此刻执行到这里，调用 clone 的时候，用户态的栈、栈顶指针、指令指针和其他系统调用一样，都是指向主线程的。</p>
<p>但是对于线程来说，这些都要变。因为我们希望当 clone 这个系统调用成功的时候，除了内核里面有这个线程对应的 task_struct，当系统调用返回到用户态的时候，用户态的栈应该是线程的栈，栈顶指针应该指向线程的栈，指令指针应该指向线程将要执行的那个函数。所以这些都需要我们自己做，将线程要执行的函数的参数和指令的位置都压到栈里面，当从内核返回，从栈里弹出来的时候，就从这个函数开始，带着这些参数执行下去。</p>
<h3 id="资源赋值-x2F-设置"><a href="#资源赋值-x2F-设置" class="headerlink" title="资源赋值&#x2F;设置"></a>资源赋值&#x2F;设置</h3><p>clone最终是调用到了do_fork函数。由于创建线程时，设置了clone_flags。所以在具体的流程中，资源不再是创建拷贝一份数据，而是对应的用户数&#x2F;引用加一，内存指向原本的内存。</p>
<ul>
<li>files_struct 引用计数加一</li>
<li>fs_struct 的用户数加一</li>
<li>sighand_struct 引用计数加一</li>
<li>mm直接指向了原来的 mm_struct</li>
</ul>
<h3 id="亲缘关系设置"><a href="#亲缘关系设置" class="headerlink" title="亲缘关系设置"></a>亲缘关系设置</h3><p>使用了 CLONE_THREAD 标识位之后，使得亲缘关系有了一定的变化。如果是新进程，那这个进程的 group_leader 就是它自己，tgid 是它自己的 pid，这就完全重打锣鼓另开张了，自己是线程组的头。如果是新线程，group_leader 是当前进程的，group_leader，tgid 是当前进程的 tgid，也就是当前进程的 pid，这个时候还是拜原来进程为老大。如果是新进程，新进程的 real_parent 是当前的进程，在进程树里面又见一辈人；如果是新线程，线程的 real_parent 是当前的进程的 real_parent，其实是平辈的。</p>
<h3 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h3><p>每个 task_struct，都会有这样一个成员变量，struct sigpending pending。这就是一个信号列表。如果这个 task_struct 是一个线程，这里面的信号就是发给这个线程的；如果这个 task_struct 是一个进程，这里面的信号是发给主线程的。整个进程里的所有线程共享一个 shared_pending，这也是一个信号列表，是发给整个进程的，哪个线程处理都一样。 子线程自己是没有独立的信号处理的？</p>
<h2 id="用户态执行线程"><a href="#用户态执行线程" class="headerlink" title="用户态执行线程"></a>用户态执行线程</h2><p>clone系统调用返回后，会调用start_thread函数，里面调用传入的线程函数。在用户的函数执行完毕之后，会释放这个线程相关的数据。例如，线程本地数据 thread_local variables，线程数目也减一。如果这是最后一个线程了，就直接退出进程，另外 __free_tcb 用于释放 pthread。</p>
<img src="/images/202012/linux14_thread.jpeg" alt="图片替换文本" width="600" height="813" align="bottom" />


<p>fork和clone的区别， fork对资源的复制是深拷贝， 全部重新申请一份新的， 拷贝内容。 clone呢，只是增加引用计数，浅拷贝，共享已有的资源， 线程共享进程的数据结构。五大结构：files_struct、fs_struct、sighand_struct、signal_struct、mm_struct。</p>
<blockquote><p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
</blockquote>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>arm64指令学习1-加载存储指令</title>
    <url>/2025/01/13/2025-20250113-arm64/</url>
    <content><![CDATA[<h1 id="加载存储指令"><a href="#加载存储指令" class="headerlink" title="加载存储指令"></a>加载存储指令</h1><h2 id="加载指令ldr"><a href="#加载指令ldr" class="headerlink" title="加载指令ldr"></a>加载指令ldr</h2><p>把存储器中的数据加载到目标寄存器中。一次操作8个字节。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指令格式：</span><br><span class="line">ldr 目标寄存器， &lt;存储器地址&gt;</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line"></span><br><span class="line">mov x2, 0x8000  # 设置x2 = 0x8000</span><br><span class="line">ldr x1, [x2, #8]! # 前变基模式, x2值先 +8， 再作为地址，x1取该地址的值</span><br><span class="line">ldr x5, [x1, x3, lsl #3] # 读取 x1 + (x3&lt;&lt;3)的地址内容到x5</span><br><span class="line">ldr x1, [x2], #8  # 后变基模式，先以x2值为地址，取值赋值到x1， x2值再加8</span><br><span class="line"></span><br><span class="line">#define LABEL 0x20</span><br><span class="line">ldr x1, LABEL # 取pc + LABEL值为地址，取值赋值给x1</span><br><span class="line">ldr x1, =LABEL # x1 = 0x20 // 伪指令</span><br><span class="line"></span><br><span class="line">.global string1</span><br><span class="line">string1:</span><br><span class="line">  .string &quot;boot el&quot;</span><br><span class="line"></span><br><span class="line">ldr x1, string1 # 加载 boot el的ASCII码到x1寄存器</span><br><span class="line">ldr x1, =string1 # 加载string1的地址到x1寄存器</span><br><span class="line"></span><br><span class="line">.global my_data </span><br><span class="line">my_data:</span><br><span class="line">  .word 0x44</span><br><span class="line"></span><br><span class="line">ldr x1, my_data # 加载my_data的值0x44 到x1</span><br><span class="line">ldr x1, =mydata # 加载my_data的地址到x1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="存储指令str"><a href="#存储指令str" class="headerlink" title="存储指令str"></a>存储指令str</h2><p>把寄存器中的数据保存到存储器中。一次操作8个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指令格式：</span><br><span class="line">str 源寄存器， &lt;存储器地址&gt;</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line"></span><br><span class="line">mov x2, 0x8000  # 设置x2 = 0x8000</span><br><span class="line">mov x1, =0x30</span><br><span class="line">str x1, [x2, #8]! # 前变基模式, x2值先 +8， 再作为地址，将x1的值存储到该地址</span><br><span class="line">str x1, [x2, x3, lsl #3] # 存储x1值到 x2 + (x3&lt;&lt;3)的地址内容</span><br><span class="line">str x1, [x2], #8  # 后变基模式，先以x2值为地址，x1的值存储到该地址， x2值再加8</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h2><p>可以加载一个16位的立即数到寄存器。或者16位立即数并左移16,32,48位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov xd, 0x8000 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多字节的加载和存储指令ldp和stp指令"><a href="#多字节的加载和存储指令ldp和stp指令" class="headerlink" title="多字节的加载和存储指令ldp和stp指令"></a>多字节的加载和存储指令ldp和stp指令</h2><p>ldp和stp可以一条指令加载和存储16个字节，效率比ldr、str提高一倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldp x3, x7, [x0] // x0 ==&gt; x3, x0+8 ==&gt; x7 </span><br><span class="line"></span><br><span class="line">stp x1, x2, [x3] // x1 ==&gt; x3, x2 ==&gt; x3+8</span><br><span class="line"></span><br><span class="line">stp x1, x1, [x2], #16 // 把x1 ==&gt; x2, x1 ==&gt; x2+8， 然后x2=x2+16</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="汇编函数编写"><a href="#汇编函数编写" class="headerlink" title="汇编函数编写"></a>汇编函数编写</h1><p>在C语言调用汇编函数，可以是用extern声明，函数的参数存储在X0~X7。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern void mem_test();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 把0x8000 存储到0x8008中</span><br><span class="line">.global mem_test</span><br><span class="line">mem_test:</span><br><span class="line">  mov x2, 0x8000</span><br><span class="line">  mov x1, 0x8008</span><br><span class="line">  str x2, [x1]</span><br></pre></td></tr></table></figure>

<p>cmp x1, x2<br>b.cc lb  # 如果x1 &lt; x2 ,跳转到1标签</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>crypto系列1-密码体制算法</title>
    <url>/2025/09/26/2025-20250926-crypto-001/</url>
    <content><![CDATA[<h1 id="密码体制算法介绍"><a href="#密码体制算法介绍" class="headerlink" title="密码体制算法介绍"></a>密码体制算法介绍</h1><p>密码体制算法是实现信息加密、解密、签名、验证等安全功能的核心技术，主要用于保障数据的机密性、完整性、认证性和不可否认性。根据加密密钥与解密密钥的关系，密码体制可分为<strong>对称密码体制</strong>、<strong>非对称密码体制</strong>和<strong>混合密码体制</strong>三大类，每类包含多种经典算法。</p>
<span id="more"></span>

<h2 id="一、对称密码体制（Symmetric-Cryptography）"><a href="#一、对称密码体制（Symmetric-Cryptography）" class="headerlink" title="一、对称密码体制（Symmetric Cryptography）"></a>一、对称密码体制（Symmetric Cryptography）</h2><p>对称密码体制又称“单钥密码体制”，其核心特点是<strong>加密和解密使用相同的密钥</strong>（或加密密钥与解密密钥可相互推导）。由于密钥需要共享，因此密钥的安全分发是该体制的主要挑战。</p>
<h3 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h3><ul>
<li>加密&#x2F;解密速度快，适合处理大量数据（如文件、流媒体）。</li>
<li>密钥长度较短（通常128位、256位），但需严格保密。</li>
<li>密钥管理复杂：n个用户间通信需n(n-1)&#x2F;2个密钥。</li>
</ul>
<h3 id="典型算法"><a href="#典型算法" class="headerlink" title="典型算法"></a>典型算法</h3><ol>
<li><p><strong>DES（Data Encryption Standard）</strong>  </p>
<ul>
<li>分组密码，1977年成为美国联邦标准，分组长度64位，有效密钥长度56位（含8位校验位）。  </li>
<li>缺点：密钥过短（56位），安全性不足，已被淘汰。</li>
</ul>
</li>
<li><p><strong>3DES（Triple DES）</strong>  </p>
<ul>
<li>DES的改进版，通过对数据执行三次DES加密（加密-解密-加密）增强安全性，密钥长度168位（56位×3）。  </li>
<li>兼容性好，但速度较慢，逐渐被AES取代。</li>
</ul>
</li>
<li><p><strong>AES（Advanced Encryption Standard）</strong>  </p>
<ul>
<li>2001年取代DES成为新国际标准，分组长度128位，支持128&#x2F;192&#x2F;256位密钥。  </li>
<li>采用SP网络结构（替代-置换），安全性高、效率优异，是目前应用最广泛的对称算法（如HTTPS、WiFi加密）。</li>
</ul>
</li>
<li><p><strong>RC4（Rivest Cipher 4）</strong>  </p>
<ul>
<li>流密码，生成伪随机密钥流与明文异或加密，密钥长度可变（1-256位）。  </li>
<li>实现简单、速度快，但存在安全漏洞（如WEP协议被破解），逐渐被淘汰。</li>
</ul>
</li>
<li><p><strong>ChaCha20</strong>  </p>
<ul>
<li>流密码，由Google设计，无需硬件加速即可高效运行，抗攻击性强。  </li>
<li>广泛用于移动端和嵌入式设备（如HTTPS的TLS 1.3、SSH）。</li>
</ul>
</li>
</ol>
<h2 id="二、非对称密码体制（Asymmetric-Cryptography）"><a href="#二、非对称密码体制（Asymmetric-Cryptography）" class="headerlink" title="二、非对称密码体制（Asymmetric Cryptography）"></a>二、非对称密码体制（Asymmetric Cryptography）</h2><p>非对称密码体制又称“公钥密码体制”，其核心特点是<strong>加密和解密使用不同的密钥</strong>：一个是公开的“公钥”（用于加密或验证签名），一个是保密的“私钥”（用于解密或生成签名），且从公钥无法推导出私钥。</p>
<h3 id="核心特点-1"><a href="#核心特点-1" class="headerlink" title="核心特点"></a>核心特点</h3><ul>
<li>无需共享密钥，解决了对称密码的密钥分发问题。</li>
<li>加密速度较慢，适合处理少量数据（如密钥加密、数字签名）。</li>
<li>密钥长度较长（通常1024位以上），安全性依赖数学难题。</li>
</ul>
<h3 id="典型算法-1"><a href="#典型算法-1" class="headerlink" title="典型算法"></a>典型算法</h3><ol>
<li><p><strong>RSA（Rivest-Shamir-Adleman）</strong>  </p>
<ul>
<li>基于“大整数分解”难题：将两个大质数相乘容易，但分解乘积得到原始质数极难。  </li>
<li>支持加密和签名，应用广泛（如HTTPS证书、数字签名、SSH密钥）。  </li>
<li>推荐密钥长度：2048位（安全）、4096位（高安全场景）。</li>
</ul>
</li>
<li><p><strong>ECC（Elliptic Curve Cryptography，椭圆曲线密码）</strong>  </p>
<ul>
<li>基于“椭圆曲线离散对数”难题：在椭圆曲线上的点群中，求解离散对数比大整数分解更困难。  </li>
<li>同等安全强度下，密钥长度远短于RSA（如256位ECC≈3072位RSA），计算效率更高。  </li>
<li>适合资源受限场景（如移动设备、物联网），是未来主流（如比特币、5G安全）。</li>
</ul>
</li>
<li><p><strong>DSA（Digital Signature Algorithm）</strong>  </p>
<ul>
<li>基于“离散对数”难题，仅用于数字签名（不支持加密），美国联邦标准。  </li>
<li>改进版为ECDSA（椭圆曲线DSA），结合ECC优势，签名效率更高。</li>
</ul>
</li>
<li><p><strong>ElGamal</strong>  </p>
<ul>
<li>基于“离散对数”难题，支持加密和签名，但签名结果不唯一（概率性算法）。  </li>
<li>应用较少，被RSA和ECC替代。</li>
</ul>
</li>
</ol>
<h2 id="三、混合密码体制（Hybrid-Cryptography）"><a href="#三、混合密码体制（Hybrid-Cryptography）" class="headerlink" title="三、混合密码体制（Hybrid Cryptography）"></a>三、混合密码体制（Hybrid Cryptography）</h2><p>混合密码体制结合了对称密码和非对称密码的优势：<strong>用非对称密码加密对称密钥，用对称密码加密实际数据</strong>，既解决了密钥分发问题，又保证了加密效率。</p>
<h3 id="典型应用流程（如HTTPS）"><a href="#典型应用流程（如HTTPS）" class="headerlink" title="典型应用流程（如HTTPS）"></a>典型应用流程（如HTTPS）</h3><ol>
<li>发送方生成一个临时对称密钥（会话密钥，如AES密钥）。  </li>
<li>用接收方的公钥（RSA&#x2F;ECC）加密会话密钥，确保只有接收方能解密。  </li>
<li>用会话密钥加密大量原始数据（如网页内容），效率极高。  </li>
<li>接收方用私钥解密得到会话密钥，再用会话密钥解密原始数据。</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>兼顾安全性（非对称密钥分发）和效率（对称加密大数据），是互联网安全的主流方案（如HTTPS、VPN、邮件加密）。</li>
</ul>
<h2 id="四、其他重要密码技术"><a href="#四、其他重要密码技术" class="headerlink" title="四、其他重要密码技术"></a>四、其他重要密码技术</h2><h3 id="1-哈希函数（Hash-Function）"><a href="#1-哈希函数（Hash-Function）" class="headerlink" title="1. 哈希函数（Hash Function）"></a>1. 哈希函数（Hash Function）</h3><ul>
<li>不属于加密算法，但与密码体制紧密配合，用于生成数据摘要（固定长度哈希值），确保完整性。  </li>
<li>特点：单向性（无法从哈希值反推原文）、抗碰撞性（不同原文难生成相同哈希值）。  </li>
<li>典型算法：SHA-256（应用最广）、SHA-3、MD5（已不安全，淘汰）。</li>
</ul>
<h3 id="2-数字签名（Digital-Signature）"><a href="#2-数字签名（Digital-Signature）" class="headerlink" title="2. 数字签名（Digital Signature）"></a>2. 数字签名（Digital Signature）</h3><ul>
<li>基于非对称密码和哈希函数，发送方用私钥对数据哈希值加密生成签名，接收方用公钥验证，确保数据未篡改且来源可信。  </li>
<li>核心算法：RSA签名、ECDSA签名。</li>
</ul>
<h2 id="五、总结：密码体制的选择依据"><a href="#五、总结：密码体制的选择依据" class="headerlink" title="五、总结：密码体制的选择依据"></a>五、总结：密码体制的选择依据</h2><table>
<thead>
<tr>
<th>场景需求</th>
<th>推荐体制&#x2F;算法</th>
<th>理由</th>
</tr>
</thead>
<tbody><tr>
<td>加密大量数据（文件、流）</td>
<td>对称密码（AES-256、ChaCha20）</td>
<td>速度快，适合大数据量</td>
</tr>
<tr>
<td>密钥分发、数字签名</td>
<td>非对称密码（ECC、RSA-2048+）</td>
<td>无需共享密钥，保障身份认证</td>
</tr>
<tr>
<td>互联网通信（如HTTPS）</td>
<td>混合密码（AES+RSA&#x2F;ECC）</td>
<td>兼顾密钥安全分发和数据加密效率</td>
</tr>
<tr>
<td>资源受限设备（物联网）</td>
<td>ECC+轻量级对称算法（如AES-128）</td>
<td>密钥短、计算量小，适合低功耗设备</td>
</tr>
</tbody></table>
<p>密码体制的安全性不仅依赖算法本身，还取决于密钥管理（如密钥生成、存储、销毁）和实现细节（如抗侧信道攻击）。随着量子计算的发展，抗量子密码（如格基密码）正成为新的研究热点。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>好久没写博客了，或者是有些忙，终归是懒。</p>
<p>希望重新搞起来，就像跑步那样，每周一次，坚持下来，锻炼脑力！</p>
<p>得有八九个月了，其实也攒了挺多素材了，趁着即将到来的国庆，一股脑全给他倒出来。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title>crypto系列2-数字信封技术</title>
    <url>/2025/09/26/2025-20250926-crypto-002/</url>
    <content><![CDATA[<h1 id="数字信封技术：原理、流程与应用"><a href="#数字信封技术：原理、流程与应用" class="headerlink" title="数字信封技术：原理、流程与应用"></a>数字信封技术：原理、流程与应用</h1><p>数字信封技术是一种结合<strong>对称加密</strong>与<strong>非对称加密</strong>优势的复合加密技术，主要用于在不安全的网络环境中安全传输敏感数据，解决了“数据加密效率”与“密钥安全分发”两大核心难题。其本质是用对称加密保护数据本身，再用非对称加密保护对称密钥，如同将“机密文件”装入“密码信封”，既保证文件安全，又确保信封能准确、安全地交给接收方。</p>
<span id="more"></span>


<h2 id="一、核心技术基础：对称加密与非对称加密"><a href="#一、核心技术基础：对称加密与非对称加密" class="headerlink" title="一、核心技术基础：对称加密与非对称加密"></a>一、核心技术基础：对称加密与非对称加密</h2><p>数字信封技术的核心是扬长避短——对称加密速度快但密钥难传输，非对称加密密钥易传输但速度慢。二者的特性对比是理解数字信封的前提：</p>
<table>
<thead>
<tr>
<th>特性维度</th>
<th>对称加密（如AES、DES）</th>
<th>非对称加密（如RSA、ECC）</th>
</tr>
</thead>
<tbody><tr>
<td>密钥特点</td>
<td>加密、解密使用<strong>同一把密钥</strong>（共享密钥）</td>
<td>加密、解密使用<strong>不同密钥</strong>（公钥加密，私钥解密）</td>
</tr>
<tr>
<td>运算效率</td>
<td>速度极快，适合加密<strong>大量数据</strong>（如文件、流数据）</td>
<td>速度较慢，适合加密<strong>少量数据</strong>（如密钥）</td>
</tr>
<tr>
<td>密钥分发</td>
<td>密钥需双方共享，传输过程易被窃取，安全性低</td>
<td>公钥可公开传播，私钥仅个人持有，分发安全</td>
</tr>
<tr>
<td>核心用途</td>
<td>加密实际传输的“明文数据”</td>
<td>加密对称加密中使用的“会话密钥”</td>
</tr>
</tbody></table>
<h2 id="二、数字信封技术的核心原理"><a href="#二、数字信封技术的核心原理" class="headerlink" title="二、数字信封技术的核心原理"></a>二、数字信封技术的核心原理</h2><p>数字信封技术的逻辑可概括为“<strong>对称加密数据，非对称加密密钥</strong>”，具体包含两个关键概念：</p>
<ol>
<li><strong>会话密钥（Symmetric Key）</strong>：临时生成的对称密钥，仅用于本次数据传输，加密完明文后即失效（“一次一密”），避免长期使用同一密钥带来的安全风险。</li>
<li><strong>数字信封（Digital Envelope）</strong>：将“用会话密钥加密后的密文数据”与“用接收方公钥加密后的会话密钥”打包在一起形成的数据包，即“密文+加密密钥”的组合。</li>
</ol>
<p>接收方拿到数字信封后，需先用自己的私钥解密出会话密钥，再用会话密钥解密出原始明文，整个过程中<strong>会话密钥从未以明文形式传输</strong>，彻底解决了密钥分发的安全问题。</p>
<h2 id="三、完整工作流程（发送方→接收方）"><a href="#三、完整工作流程（发送方→接收方）" class="headerlink" title="三、完整工作流程（发送方→接收方）"></a>三、完整工作流程（发送方→接收方）</h2><p>数字信封的传输过程可分为“加密阶段”（发送方操作）和“解密阶段”（接收方操作），共6个关键步骤：</p>
<h3 id="1-加密阶段（发送方处理）"><a href="#1-加密阶段（发送方处理）" class="headerlink" title="1. 加密阶段（发送方处理）"></a>1. 加密阶段（发送方处理）</h3><ul>
<li><strong>步骤1：生成会话密钥</strong><br>发送方随机生成一把临时的对称密钥（如AES密钥），作为本次传输的“会话密钥”，仅用于加密当前需要发送的明文数据。</li>
<li><strong>步骤2：对称加密明文</strong><br>发送方使用会话密钥对原始明文数据（如合同文档、支付信息）进行对称加密，得到“加密后的密文数据”。</li>
<li><strong>步骤3：获取接收方公钥</strong><br>发送方从公开渠道（如数字证书、密钥服务器）获取接收方的<strong>公钥</strong>（非对称加密中的公开密钥，可自由传播）。</li>
<li><strong>步骤4：非对称加密会话密钥</strong><br>发送方使用接收方的公钥对“会话密钥”进行非对称加密，得到“加密后的会话密钥”。</li>
<li><strong>步骤5：打包数字信封</strong><br>发送方将“加密后的密文数据”与“加密后的会话密钥”合并打包，形成最终的“数字信封”，并通过网络发送给接收方。</li>
</ul>
<h3 id="2-解密阶段（接收方处理）"><a href="#2-解密阶段（接收方处理）" class="headerlink" title="2. 解密阶段（接收方处理）"></a>2. 解密阶段（接收方处理）</h3><ul>
<li><strong>步骤6：解密会话密钥与明文</strong>  <ol>
<li>接收方收到数字信封后，先分离出“加密后的会话密钥”和“加密后的密文数据”；  </li>
<li>接收方使用自己的<strong>私钥</strong>（非对称加密中的私有密钥，仅本人持有，绝对保密）对“加密后的会话密钥”进行解密，还原出原始的会话密钥；  </li>
<li>接收方使用还原后的会话密钥对“加密后的密文数据”进行对称解密，最终得到发送方的原始明文数据。</li>
</ol>
</li>
</ul>
<p><img src="/images/2025/DigitalEnvelope.png" alt="DigitalEnvelope"></p>
<h2 id="四、关键优势"><a href="#四、关键优势" class="headerlink" title="四、关键优势"></a>四、关键优势</h2><ol>
<li><strong>安全性高</strong></li>
</ol>
<ul>
<li>会话密钥仅临时存在，且从未以明文传输，即使被截获，没有接收方私钥也无法解密；  </li>
<li>非对称加密保证了密钥分发的安全性，对称加密保证了数据加密的可靠性。</li>
</ul>
<ol start="2">
<li><strong>传输效率高</strong><br>   仅对“少量的会话密钥”使用慢速度的非对称加密，对“大量的明文数据”使用快速度的对称加密，兼顾安全与效率。</li>
<li><strong>实用性强</strong><br>   解决了“一对一”“一对多”等多种场景的加密需求，无需提前协商共享密钥，降低了密钥管理成本。</li>
</ol>
<h2 id="五、典型应用场景"><a href="#五、典型应用场景" class="headerlink" title="五、典型应用场景"></a>五、典型应用场景</h2><p>数字信封技术是网络安全领域的基础技术之一，广泛应用于需要“数据机密性”的场景：</p>
<ul>
<li><strong>电子商务</strong>：支付信息（银行卡号、密码）的加密传输，如网银、第三方支付平台。</li>
<li><strong>企业通信</strong>：内部敏感文档（财务数据、商业机密）的跨网络传输，避免数据泄露。</li>
<li><strong>电子政务</strong>：公民隐私信息（身份证号、社保数据）或政务机密的加密交换。</li>
<li><strong>VPN（虚拟专用网络）</strong>：部分VPN协议（如IPsec）使用数字信封技术加密隧道中的数据，保证远程访问的安全性。</li>
<li><strong>区块链</strong>：部分区块链项目中，用户之间的私密消息传输会采用数字信封技术，确保消息仅接收方可见。</li>
</ul>
<h2 id="六、与相关技术的区别"><a href="#六、与相关技术的区别" class="headerlink" title="六、与相关技术的区别"></a>六、与相关技术的区别</h2><h3 id="1-数字信封-vs-数字签名"><a href="#1-数字信封-vs-数字签名" class="headerlink" title="1. 数字信封 vs 数字签名"></a>1. 数字信封 vs 数字签名</h3><p>二者常被混淆，但核心目标完全不同：</p>
<ul>
<li><strong>数字信封</strong>：核心是<strong>保证数据机密性</strong>，防止数据在传输中被窃取或篡改后无法察觉（加密为主）；  </li>
<li><strong>数字签名</strong>：核心是<strong>保证数据完整性与发送方身份真实性</strong>（如防止发送方抵赖），需用发送方私钥签名、接收方公钥验证（签名为主）。<br>实际场景中，二者常结合使用（如“数字信封+数字签名”），同时实现“机密性、完整性、身份认证”三大目标。</li>
</ul>
<h3 id="2-数字信封-vs-单纯对称加密"><a href="#2-数字信封-vs-单纯对称加密" class="headerlink" title="2. 数字信封 vs 单纯对称加密"></a>2. 数字信封 vs 单纯对称加密</h3><p>单纯对称加密需提前通过安全渠道分发共享密钥，一旦密钥泄露，所有加密数据都会失效；而数字信封无需提前分发密钥，通过非对称加密动态保护会话密钥，安全性更高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数字信封技术通过“对称加密+非对称加密”的组合，完美平衡了“加密效率”与“密钥安全”，是解决网络数据传输机密性的核心方案。从日常的手机支付到企业的商业机密保护，其底层逻辑都离不开这一技术的支撑，是现代网络安全体系的重要基石。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title>crypto系列3-数字签名技术</title>
    <url>/2025/09/27/2025-20250927-crypto-003-digitalsign/</url>
    <content><![CDATA[<h1 id="数字签名技术：原理、流程与核心价值"><a href="#数字签名技术：原理、流程与核心价值" class="headerlink" title="数字签名技术：原理、流程与核心价值"></a>数字签名技术：原理、流程与核心价值</h1><p>数字签名技术是一种基于<strong>非对称加密算法</strong>的安全技术，主要用于验证电子数据的<strong>完整性</strong>、确认发送方的<strong>身份真实性</strong>，并防止发送方事后<strong>抵赖</strong>行为。其核心逻辑可类比为“电子世界的手写签名”——但比手写签名更安全、更难伪造，是保障网络信息可信传输的核心技术之一。</p>
<span id="more"></span>

<h2 id="一、核心技术基础：非对称加密与哈希算法"><a href="#一、核心技术基础：非对称加密与哈希算法" class="headerlink" title="一、核心技术基础：非对称加密与哈希算法"></a>一、核心技术基础：非对称加密与哈希算法</h2><p>数字签名技术并非单一算法，而是<strong>非对称加密</strong>与<strong>哈希算法</strong>的有机结合，二者的特性共同支撑起签名的安全性：</p>
<table>
<thead>
<tr>
<th>技术组件</th>
<th>核心作用</th>
<th>典型算法示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>非对称加密</strong></td>
<td>实现“私钥签名、公钥验证”，绑定签名者身份（私钥唯一归属个人&#x2F;机构）。</td>
<td>RSA、ECC（椭圆曲线加密）</td>
</tr>
<tr>
<td><strong>哈希算法</strong></td>
<td>将任意长度的原始数据压缩为固定长度的“哈希值”（摘要），用于校验数据完整性。</td>
<td>SHA-256、SHA-3</td>
</tr>
</tbody></table>
<h3 id="关键概念补充："><a href="#关键概念补充：" class="headerlink" title="关键概念补充："></a>关键概念补充：</h3><ul>
<li><strong>哈希值（Hash Value）</strong>：又称“消息摘要”，是原始数据经过哈希算法计算后的唯一“数字指纹”。其核心特性是：<ol>
<li><strong>唯一性</strong>：不同原始数据几乎不可能生成相同哈希值（“抗碰撞性”）；</li>
<li><strong>不可逆性</strong>：无法通过哈希值反推原始数据；</li>
<li><strong>固定长度</strong>：无论原始数据是1KB的文档还是1GB的视频，哈希值长度固定（如SHA-256生成256位哈希值）。</li>
</ol>
</li>
<li><strong>公钥与私钥</strong>：非对称加密的一对密钥，公钥可公开传播，私钥仅签名者本人持有且绝对保密。</li>
</ul>
<h2 id="二、数字签名的核心原理"><a href="#二、数字签名的核心原理" class="headerlink" title="二、数字签名的核心原理"></a>二、数字签名的核心原理</h2><p>数字签名的本质是“<strong>用签名者私钥对数据的哈希值加密</strong>”，验证则是“<strong>用签名者公钥解密哈希值并与原始数据的哈希值比对</strong>”。其逻辑可概括为3点：</p>
<ol>
<li>哈希算法确保“数据一旦被篡改，哈希值立即变化”，解决<strong>完整性</strong>问题；</li>
<li>非对称加密的“私钥唯一归属”特性确保“只有签名者能生成有效签名”，解决<strong>身份真实性</strong>问题；</li>
<li>公开可验证的公钥确保“任何人都能验证签名有效性”，解决<strong>防抵赖</strong>问题。</li>
</ol>
<h2 id="三、完整工作流程（签名阶段→验证阶段）"><a href="#三、完整工作流程（签名阶段→验证阶段）" class="headerlink" title="三、完整工作流程（签名阶段→验证阶段）"></a>三、完整工作流程（签名阶段→验证阶段）</h2><p>数字签名的全流程分为“签名生成”（发送方操作）和“签名验证”（接收方&#x2F;验证方操作），共5个关键步骤：</p>
<h3 id="1-签名生成阶段（发送方操作）"><a href="#1-签名生成阶段（发送方操作）" class="headerlink" title="1. 签名生成阶段（发送方操作）"></a>1. 签名生成阶段（发送方操作）</h3><ul>
<li><p><strong>步骤1：计算原始数据的哈希值</strong><br>发送方对需要签名的原始数据（如合同文档、邮件、交易记录等）使用哈希算法（如SHA-256）进行计算，生成固定长度的<strong>数据哈希值</strong>（摘要）。这一步的目的是将“长数据”压缩为“短数据”，提升后续加密效率。</p>
</li>
<li><p><strong>步骤2：用私钥加密哈希值</strong><br>发送方使用自己的<strong>私钥</strong>（非对称加密中的私有密钥）对第一步生成的“数据哈希值”进行加密，得到的加密结果即为“<strong>数字签名</strong>”。</p>
</li>
<li><p><strong>步骤3：发送数据与签名</strong><br>发送方将“原始数据”与“数字签名”打包在一起，通过网络发送给接收方（或公开传播，如区块链交易）。</p>
</li>
</ul>
<h3 id="2-签名验证阶段（接收方-x2F-验证方操作）"><a href="#2-签名验证阶段（接收方-x2F-验证方操作）" class="headerlink" title="2. 签名验证阶段（接收方&#x2F;验证方操作）"></a>2. 签名验证阶段（接收方&#x2F;验证方操作）</h3><ul>
<li><p><strong>步骤4：分离数据与签名，计算原始数据的哈希值</strong><br>接收方收到数据包后，先分离出“原始数据”和“数字签名”；然后使用<strong>与发送方相同的哈希算法</strong>对“原始数据”重新计算，得到一个新的“验证用哈希值”。</p>
</li>
<li><p><strong>步骤5：用公钥解密签名并比对哈希值</strong>  </p>
<ol>
<li>接收方从公开渠道（如数字证书、密钥服务器）获取发送方的<strong>公钥</strong>；  </li>
<li>使用该公钥对“数字签名”进行解密，得到发送方在签名阶段生成的“原始哈希值”；  </li>
<li>对比“验证用哈希值”与“原始哈希值”：  <ul>
<li>若两者<strong>完全一致</strong>：说明原始数据未被篡改，且签名确实由持有对应私钥的发送方生成，签名有效；  </li>
<li>若两者<strong>不一致</strong>：说明数据在传输中被篡改，或签名为伪造，验证失败。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/images/2025/DigitalSign.png" alt="DigitalSign"></p>
<h2 id="四、关键特性与核心价值"><a href="#四、关键特性与核心价值" class="headerlink" title="四、关键特性与核心价值"></a>四、关键特性与核心价值</h2><p>数字签名技术通过算法逻辑实现了传统手写签名无法企及的安全强度，其核心价值体现在3个维度：</p>
<table>
<thead>
<tr>
<th>核心特性</th>
<th>具体说明</th>
<th>解决的问题</th>
</tr>
</thead>
<tbody><tr>
<td><strong>身份认证</strong></td>
<td>只有持有对应私钥的主体才能生成有效签名，公钥验证可确认“谁是数据发送者”。</td>
<td>防止他人冒充发送方身份</td>
</tr>
<tr>
<td><strong>数据完整性</strong></td>
<td>数据篡改会导致哈希值变化，验证时可立即识别，确保数据从发送到接收未被修改。</td>
<td>防止数据在传输中被篡改</td>
</tr>
<tr>
<td><strong>防抵赖</strong></td>
<td>签名由发送方私钥生成，且公钥可公开验证，发送方无法否认自己发送过该数据。</td>
<td>防止发送方事后否认发送行为</td>
</tr>
</tbody></table>
<h2 id="五、典型应用场景"><a href="#五、典型应用场景" class="headerlink" title="五、典型应用场景"></a>五、典型应用场景</h2><p>数字签名技术已深度融入金融、政务、互联网等领域，成为电子数据可信化的“基础设施”：</p>
<ul>
<li><strong>电子商务与电子支付</strong>：用于订单确认、支付指令授权（如银行网银的“U盾签名”），防止支付指令被篡改或冒充。</li>
<li><strong>电子合同与法律文书</strong>：通过第三方电子签名平台（如契约锁、e签宝）生成的数字签名，具备《电子签名法》认可的法律效力，替代传统纸质合同的手写签名。</li>
<li><strong>电子政务</strong>：公民办理社保、工商注册等业务时，通过数字签名确认申请信息的真实性，减少线下材料提交。</li>
<li><strong>区块链技术</strong>：区块链中的每一笔交易都包含发起者的数字签名，节点通过验证签名确认交易合法性，确保交易不可篡改、不可抵赖。</li>
<li><strong>软件发布与代码校验</strong>：软件开发商对发布的安装包生成数字签名，用户下载后验证签名，确认软件未被恶意篡改（如植入病毒）。</li>
<li><strong>电子邮件安全</strong>：通过S&#x2F;MIME协议为邮件添加数字签名，验证发件人身份并确保邮件内容未被篡改。</li>
</ul>
<h2 id="六、与相关技术的区别"><a href="#六、与相关技术的区别" class="headerlink" title="六、与相关技术的区别"></a>六、与相关技术的区别</h2><h3 id="1-数字签名-vs-数字信封"><a href="#1-数字签名-vs-数字信封" class="headerlink" title="1. 数字签名 vs 数字信封"></a>1. 数字签名 vs 数字信封</h3><p>二者常被混淆，但核心目标与技术逻辑完全不同，实际场景中常结合使用（“签名+加密”实现完整安全）：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>数字签名</th>
<th>数字信封</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心目标</strong></td>
<td>保证<strong>身份真实性、数据完整性、防抵赖</strong>（“可信”）</td>
<td>保证<strong>数据机密性</strong>（“保密”）</td>
</tr>
<tr>
<td><strong>技术逻辑</strong></td>
<td>私钥签名（加密哈希值），公钥验证（解密哈希值）</td>
<td>对称密钥加密数据，公钥加密对称密钥，私钥解密对称密钥</td>
</tr>
<tr>
<td><strong>密钥使用</strong></td>
<td>签名用<strong>发送方私钥</strong>，验证用<strong>发送方公钥</strong></td>
<td>加密用<strong>接收方公钥</strong>，解密用<strong>接收方私钥</strong></td>
</tr>
</tbody></table>
<h3 id="2-数字签名-vs-手写签名"><a href="#2-数字签名-vs-手写签名" class="headerlink" title="2. 数字签名 vs 手写签名"></a>2. 数字签名 vs 手写签名</h3><p>数字签名在安全性和实用性上全面超越传统手写签名：</p>
<ul>
<li><strong>伪造难度</strong>：手写签名易模仿，数字签名依赖数学算法，伪造等同于破解非对称加密（目前技术下几乎不可能）；</li>
<li><strong>验证效率</strong>：手写签名需人工肉眼比对，数字签名可通过程序自动验证，效率极高；</li>
<li><strong>绑定性</strong>：手写签名仅与纸张绑定，数字签名与具体数据的哈希值绑定，无法剥离数据单独复用。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数字签名技术通过“哈希算法+非对称加密”的组合，为电子数据赋予了“身份标识”和“完整性凭证”，解决了虚拟网络环境中“如何相信数据来源”“如何确认数据未被篡改”的核心难题。从日常的手机支付到企业的电子合同，数字签名已成为连接物理世界与数字世界“信任”的桥梁，是数字化时代不可或缺的安全基石。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title>crypto系列4-PKI公钥体制</title>
    <url>/2025/09/27/2025-20250927-crypto-004-pki/</url>
    <content><![CDATA[<h1 id="PKI公钥体制：构建数字世界信任的基础设施"><a href="#PKI公钥体制：构建数字世界信任的基础设施" class="headerlink" title="PKI公钥体制：构建数字世界信任的基础设施"></a>PKI公钥体制：构建数字世界信任的基础设施</h1><p>PKI（Public Key Infrastructure，公钥基础设施）是一套基于<strong>非对称加密技术</strong>的安全体系，通过标准化的流程和组件，解决了公钥的“可信分发”“身份绑定”和“生命周期管理”等核心问题，为数字签名、加密通信、身份认证等安全应用提供底层支撑。简单来说，PKI是数字世界的“信任体系框架”，如同现实世界的身份证管理系统——确保“公钥的持有者确实是其声称的身份”，从而让非对称加密技术能够安全、可靠地落地应用。</p>
<span id="more"></span>

<h2 id="一、PKI的核心问题：为何需要公钥基础设施？"><a href="#一、PKI的核心问题：为何需要公钥基础设施？" class="headerlink" title="一、PKI的核心问题：为何需要公钥基础设施？"></a>一、PKI的核心问题：为何需要公钥基础设施？</h2><p>非对称加密技术（公钥加密、私钥解密；私钥签名、公钥验证）本身具备安全性，但在实际应用中存在一个致命漏洞：<strong>如何确认“公开的公钥”确实归属某个特定主体</strong>？</p>
<p>举个例子：你收到“银行”发来的公钥，并用其加密了银行卡密码发送过去，但如果这个“银行公钥”实际是黑客伪造的，你的密码就会被黑客截获。这一问题被称为“公钥认证问题”，而PKI的核心价值就是通过系统化的机制，为每个公钥绑定真实身份，形成“可信的公钥-身份对应关系”。</p>
<h2 id="二、PKI的核心组成组件"><a href="#二、PKI的核心组成组件" class="headerlink" title="二、PKI的核心组成组件"></a>二、PKI的核心组成组件</h2><p>PKI是一个“硬件+软件+流程+人员”的综合体系，其核心功能由以下组件协同实现：</p>
<table>
<thead>
<tr>
<th>核心组件</th>
<th>英文全称</th>
<th>核心作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CA（认证中心）</strong></td>
<td>Certificate Authority</td>
<td>PKI的核心，负责签发、吊销数字证书，验证申请者身份，是“信任的源头”。</td>
</tr>
<tr>
<td><strong>数字证书</strong></td>
<td>Digital Certificate</td>
<td>公钥与身份信息的“绑定凭证”，类似“数字身份证”，包含公钥、持有者信息、CA签名等。</td>
</tr>
<tr>
<td><strong>RA（注册中心）</strong></td>
<td>Registration Authority</td>
<td>CA的“前端窗口”，负责接收用户证书申请、审核身份真实性（如核验营业执照、身份证），减轻CA负担。</td>
</tr>
<tr>
<td><strong>CRL（证书吊销列表）</strong></td>
<td>Certificate Revocation List</td>
<td>记录已失效（如私钥泄露、身份变更）但未到期的证书，供验证方查询，避免失效证书被滥用。</td>
</tr>
<tr>
<td><strong>密钥管理系统</strong></td>
<td>Key Management System (KMS)</td>
<td>负责用户公钥&#x2F;私钥对的生成、存储、备份、更新和销毁，保障密钥全生命周期安全。</td>
</tr>
<tr>
<td><strong>PKI应用接口</strong></td>
<td>PKI Application Interface</td>
<td>提供标准化接口（如API），供第三方应用（如网银、电子合同平台）调用PKI服务（如签名、验证、加密）。</td>
</tr>
</tbody></table>
<h3 id="关键组件详解：CA与数字证书"><a href="#关键组件详解：CA与数字证书" class="headerlink" title="关键组件详解：CA与数字证书"></a>关键组件详解：CA与数字证书</h3><p>CA和数字证书是PKI的“灵魂”，二者共同解决了“公钥可信性”问题。</p>
<h4 id="1-数字证书：公钥的“数字身份证”"><a href="#1-数字证书：公钥的“数字身份证”" class="headerlink" title="1. 数字证书：公钥的“数字身份证”"></a>1. 数字证书：公钥的“数字身份证”</h4><p>数字证书是一个符合国际标准（如X.509）的结构化数据文件，核心内容包括：</p>
<ul>
<li>证书持有者的身份信息（个人：姓名、身份证号；机构：企业名称、统一社会信用代码）；</li>
<li>证书持有者的<strong>公钥</strong>；</li>
<li>签发该证书的CA名称；</li>
<li>证书的有效期（起始时间、到期时间）；</li>
<li>CA对上述信息的<strong>数字签名</strong>（用CA的私钥签名，确保证书内容不可篡改）。</li>
</ul>
<p>数字证书的本质：用CA的“权威信任”背书“公钥与身份的对应关系”——因为CA可信，所以其签发的证书也可信，证书中的公钥自然属于证书上标注的身份主体。</p>
<h4 id="2-CA（认证中心）：信任的“根节点”"><a href="#2-CA（认证中心）：信任的“根节点”" class="headerlink" title="2. CA（认证中心）：信任的“根节点”"></a>2. CA（认证中心）：信任的“根节点”</h4><p>CA是PKI体系中的“信任锚点”，相当于数字世界的“公安局”，负责给用户颁发“数字身份证”（数字证书）。其核心职责包括：</p>
<ul>
<li><strong>身份审核</strong>：通过RA提交的材料，验证申请者身份的真实性（如企业申请需核验营业执照，个人申请需核验身份证）；</li>
<li><strong>证书签发</strong>：审核通过后，生成包含“身份+公钥”的证书，并用CA自身的私钥对证书签名；</li>
<li><strong>证书吊销</strong>：当证书持有者私钥泄露、身份注销等情况发生时，将该证书加入CRL，宣告其失效；</li>
<li><strong>维护信任</strong>：CA自身也有“根证书”（自签名证书），根证书的公钥预装在操作系统、浏览器中（如Windows、Chrome内置的知名CA根证书），作为用户信任CA的起点。</li>
</ul>
<h2 id="三、PKI的信任模型：如何构建“信任链”？"><a href="#三、PKI的信任模型：如何构建“信任链”？" class="headerlink" title="三、PKI的信任模型：如何构建“信任链”？"></a>三、PKI的信任模型：如何构建“信任链”？</h2><p>由于全球不可能只有一个CA，PKI通过“层级信任模型”构建跨CA的信任关系，最典型的是<strong>层级式信任模型</strong>（类似政府机构层级）：</p>
<ol>
<li><strong>根CA（Root CA）</strong>：位于信任链顶端，是“绝对可信”的起点，其根证书由自身签名（“自签名证书”），并预装在各类终端设备中。</li>
<li><strong>中间CA（Intermediate CA）</strong>：由根CA签发证书，负责向下级CA或终端用户签发证书，起到“信任传递”和“分散风险”的作用（根CA私钥通常离线存储，避免直接暴露）。</li>
<li><strong>终端CA（End Entity CA）</strong>：直接面向个人、企业等终端用户，签发用户证书。</li>
<li><strong>信任链验证</strong>：当验证者收到一份终端用户证书时，会通过“终端CA证书→中间CA证书→根CA证书”的链条向上追溯，直到验证到预装的根证书——若整个链条的签名均有效，则认为终端用户的证书可信。</li>
</ol>
<p>例如：你在浏览器中访问HTTPS网站时，浏览器会自动验证网站的SSL证书：先查网站证书由哪个中间CA签发，再查中间CA证书由哪个根CA签发，最终匹配到浏览器内置的根证书，确认网站身份可信，从而建立加密连接。</p>
<h2 id="四、PKI的核心工作流程（以“证书申请与使用”为例）"><a href="#四、PKI的核心工作流程（以“证书申请与使用”为例）" class="headerlink" title="四、PKI的核心工作流程（以“证书申请与使用”为例）"></a>四、PKI的核心工作流程（以“证书申请与使用”为例）</h2><p>PKI的完整运作流程围绕“证书的生命周期”展开，以企业申请证书用于电子合同签名为例：</p>
<h3 id="1-证书申请与签发阶段"><a href="#1-证书申请与签发阶段" class="headerlink" title="1. 证书申请与签发阶段"></a>1. 证书申请与签发阶段</h3><ul>
<li><strong>步骤1：提交申请</strong><br>企业通过RA系统提交证书申请，同时提供身份证明材料（如营业执照、法人身份证、授权委托书等）。</li>
<li><strong>步骤2：身份审核</strong><br>RA对企业提交的材料进行人工或自动化审核（如对接工商系统核验企业信息），确认身份真实有效。</li>
<li><strong>步骤3：生成密钥对</strong><br>审核通过后，企业端（或由KMS）生成一对公钥和私钥，私钥由企业自行安全存储（如加密U盘、硬件密钥设备），公钥提交给CA。</li>
<li><strong>步骤4：签发证书</strong><br>CA用自身的私钥对“企业身份信息+公钥”进行签名，生成数字证书，并将证书发送给企业。</li>
<li><strong>步骤5：证书发布</strong><br>CA可将证书存入公开的“证书数据库”，供其他用户查询获取。</li>
</ul>
<p><img src="/images/2025/cert_apply.png" alt="cert_apply"></p>
<h3 id="2-证书使用阶段（以数字签名为例）"><a href="#2-证书使用阶段（以数字签名为例）" class="headerlink" title="2. 证书使用阶段（以数字签名为例）"></a>2. 证书使用阶段（以数字签名为例）</h3><ul>
<li><strong>步骤6：签名操作</strong><br>企业签署电子合同时，先用哈希算法计算合同的哈希值，再用自己的<strong>私钥</strong>对哈希值加密，生成数字签名；同时附上自己的数字证书，一起发送给合同接收方。</li>
<li><strong>步骤7：验证操作</strong><br>接收方收到合同、数字签名和证书后：<ol>
<li>用CA的公钥（从证书中提取或预装）验证证书上的CA签名，确认证书本身可信；</li>
<li>从证书中提取企业的公钥，用该公钥解密数字签名，得到原始哈希值；</li>
<li>对收到的合同重新计算哈希值，与解密得到的原始哈希值比对——一致则签名有效，反之无效。</li>
</ol>
</li>
</ul>
<p><img src="/images/2025/cert_use.png" alt="cert_use"></p>
<h3 id="3-证书吊销与注销阶段"><a href="#3-证书吊销与注销阶段" class="headerlink" title="3. 证书吊销与注销阶段"></a>3. 证书吊销与注销阶段</h3><ul>
<li><strong>步骤8：申请吊销</strong><br>若企业私钥泄露，需立即向CA提交证书吊销申请。</li>
<li><strong>步骤9：更新CRL</strong><br>CA审核后，将该证书的序列号加入CRL，并定期更新公开的CRL列表。</li>
<li><strong>步骤10：验证吊销状态</strong><br>其他用户验证该企业证书时，会查询CRL——若证书在CRL中，则即使证书未到期，也视为失效。</li>
</ul>
<p><img src="/images/2025/cert_del.png" alt="cert_del"></p>
<h2 id="五、PKI的核心安全价值"><a href="#五、PKI的核心安全价值" class="headerlink" title="五、PKI的核心安全价值"></a>五、PKI的核心安全价值</h2><p>PKI通过系统化的信任机制，为数字世界提供了三大核心安全能力：</p>
<ol>
<li><p><strong>可信的身份认证</strong><br>   数字证书绑定“身份与公钥”，结合非对称加密的“私钥唯一归属”特性，可准确验证主体身份（如确认网站是真实银行、发送方是真实企业），解决“你是谁”的问题。</p>
</li>
<li><p><strong>数据的机密性与完整性</strong></p>
</li>
</ol>
<ul>
<li>机密性：用接收方证书中的公钥加密数据（或结合数字信封），确保只有接收方的私钥能解密，防止数据泄露；  </li>
<li>完整性：用发送方私钥签名，接收方通过公钥验证，确保数据未被篡改。</li>
</ul>
<ol start="3">
<li><strong>不可抵赖性</strong><br>   数字签名基于发送方私钥生成，且证书可追溯到签名者身份，发送方无法否认自己的操作（如签署合同、发起交易），解决“事后抵赖”问题。</li>
</ol>
<h2 id="六、典型应用场景"><a href="#六、典型应用场景" class="headerlink" title="六、典型应用场景"></a>六、典型应用场景</h2><p>PKI是信息安全的“底层基础设施”，几乎所有需要“信任”的数字场景都依赖其支撑：</p>
<table>
<thead>
<tr>
<th>应用领域</th>
<th>具体场景</th>
<th>PKI的作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>网络通信安全</strong></td>
<td>HTTPS协议（网站加密）、VPN（虚拟专用网络）</td>
<td>签发SSL&#x2F;TLS证书，验证网站身份，建立加密通信通道，防止数据被窃听、篡改。</td>
</tr>
<tr>
<td><strong>电子政务</strong></td>
<td>政务系统登录、电子公文流转、企业&#x2F;个人政务申报</td>
<td>签发政务证书，实现工作人员身份认证、公文签名盖章，确保政务数据可信。</td>
</tr>
<tr>
<td><strong>电子商务与支付</strong></td>
<td>网银交易、第三方支付（如支付宝、微信支付）、电子订单签署</td>
<td>签发支付证书，验证用户&#x2F;商户身份，加密支付信息，防止支付欺诈和抵赖。</td>
</tr>
<tr>
<td><strong>电子合同与法律</strong></td>
<td>第三方电子签名平台（如契约锁、e签宝）、电子发票、电子病历</td>
<td>签发个人&#x2F;企业签名证书，使电子签名具备《电子签名法》认可的法律效力。</td>
</tr>
<tr>
<td><strong>物联网（IoT）</strong></td>
<td>智能设备身份认证（如智能家居、工业传感器）</td>
<td>为设备签发证书，验证设备身份，防止恶意设备接入网络或伪造设备数据。</td>
</tr>
<tr>
<td><strong>代码与软件安全</strong></td>
<td>软件发布签名、驱动程序签名、固件更新</td>
<td>签发开发者证书，验证软件来源可信，防止恶意软件冒充正版软件传播。</td>
</tr>
</tbody></table>
<h2 id="七、PKI的局限性与发展趋势"><a href="#七、PKI的局限性与发展趋势" class="headerlink" title="七、PKI的局限性与发展趋势"></a>七、PKI的局限性与发展趋势</h2><h3 id="1-主要局限性"><a href="#1-主要局限性" class="headerlink" title="1. 主要局限性"></a>1. 主要局限性</h3><ul>
<li><strong>根信任风险</strong>：若根CA的私钥泄露，整个信任链会彻底崩塌；</li>
<li><strong>CRL查询延迟</strong>：CRL更新有周期，可能存在“证书已吊销但验证方未及时查询到”的窗口期；</li>
<li><strong>部署成本高</strong>：自建PKI系统需要CA、RA、KMS等硬件和软件，维护成本较高，中小企业通常依赖第三方CA服务。</li>
</ul>
<h3 id="2-发展趋势"><a href="#2-发展趋势" class="headerlink" title="2. 发展趋势"></a>2. 发展趋势</h3><ul>
<li><strong>轻量化PKI</strong>：针对物联网设备资源有限的特点，推出轻量化证书格式（如ECC椭圆曲线证书）和简化流程；</li>
<li><strong>区块链与PKI结合</strong>：用区块链的“去中心化”特性替代传统层级CA，将证书信息上链，实现更透明、抗篡改的信任机制（如“去中心化身份DID”）；</li>
<li><strong>自动化密钥管理</strong>：结合AI和云技术，实现密钥的自动生成、备份、更新和销毁，降低人工维护成本。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PKI公钥体制通过“CA背书+数字证书+信任链”的逻辑，将非对称加密技术从“理论安全”落地为“实际可用”，构建了数字世界的“信任基石”。从你打开HTTPS网站时的绿色锁标，到企业签署电子合同时的数字签章，再到网银交易时的U盾验证，背后都离不开PKI的支撑。在数字化深入推进的今天，PKI不仅是信息安全技术，更是保障数字经济有序运行的核心基础设施。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title>crypto系列5-国产密码算法</title>
    <url>/2025/09/27/2025-20250927-crypto-005-sm/</url>
    <content><![CDATA[<h1 id="国产密码算法：自主可控的信息安全基石"><a href="#国产密码算法：自主可控的信息安全基石" class="headerlink" title="国产密码算法：自主可控的信息安全基石"></a>国产密码算法：自主可控的信息安全基石</h1><p>国产密码算法（简称“国密算法”）是由我国<strong>国家密码管理局</strong>制定标准、自主研发的密码算法体系，涵盖对称加密、非对称加密、哈希算法、签名算法等核心类型。其核心价值在于构建<strong>“自主可控、安全可靠”的密码保障体系</strong>，摆脱对国外算法的依赖，为金融、政务、能源等关键领域的信息安全提供底层支撑，是落实《中华人民共和国密码法》《网络安全法》的核心技术基础。</p>
<span id="more"></span>

<h2 id="一、国产密码算法的核心分类与技术细节"><a href="#一、国产密码算法的核心分类与技术细节" class="headerlink" title="一、国产密码算法的核心分类与技术细节"></a>一、国产密码算法的核心分类与技术细节</h2><p>国密算法体系已形成完整的技术闭环，覆盖信息加密、身份认证、数据完整性校验等全场景需求，关键算法均已纳入国家标准（GB&#x2F;T系列）。</p>
<h3 id="1-对称加密算法：高效加密海量数据"><a href="#1-对称加密算法：高效加密海量数据" class="headerlink" title="1. 对称加密算法：高效加密海量数据"></a>1. 对称加密算法：高效加密海量数据</h3><p>对称加密算法采用“加密和解密使用同一密钥”的模式，具有加密速度快、资源消耗低的特点，适用于大数据量（如文件、数据库、通信流量）的加密保护。</p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>标准号</th>
<th>核心特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SM4（祖冲之）</strong></td>
<td>GB&#x2F;T 32907-2016</td>
<td>- 分组密码，分组长度128位，密钥长度128位<br>- 加密强度与AES-128相当，抗攻击能力强<br>- 算法公开透明，可追溯性高</td>
<td>- 无线局域网加密（WAPI标准强制使用）<br>- 数据存储加密（如硬盘加密、数据库加密）<br>- 政务&#x2F;金融系统的敏感数据传输加密</td>
</tr>
<tr>
<td><strong>SM1（SCB2）</strong></td>
<td>不公开</td>
<td>- 分组密码，分组长度128位，密钥长度128位<br>- 算法细节不公开，仅通过硬件芯片实现</td>
<td>- 智能IC卡（社保卡、银行卡）<br>- 加密机、VPN等专用安全设备</td>
</tr>
</tbody></table>
<h3 id="2-非对称加密算法：安全的密钥分发与身份认证"><a href="#2-非对称加密算法：安全的密钥分发与身份认证" class="headerlink" title="2. 非对称加密算法：安全的密钥分发与身份认证"></a>2. 非对称加密算法：安全的密钥分发与身份认证</h3><p>非对称加密算法采用“公钥（公开）+私钥（保密）”的密钥对模式，公钥用于加密&#x2F;验证签名，私钥用于解密&#x2F;生成签名，解决了“对称加密密钥分发难”的问题，适用于小数据加密（如密钥）和身份认证场景。</p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>标准号</th>
<th>核心特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SM2（椭圆曲线）</strong></td>
<td>GB&#x2F;T 32918-2016</td>
<td>- 基于椭圆曲线密码（ECC），密钥长度256位<br>- 加密强度高于RSA-2048，且密钥更短、计算效率更高<br>- 支持加密、签名、密钥交换三大功能</td>
<td>- 数字证书签发（SSL&#x2F;TLS证书、电子签名证书）<br>- 电子政务&#x2F;电子商务的身份认证<br>- 银行U盾、电子签章的签名与加密</td>
</tr>
<tr>
<td><strong>SM9（标识密码）</strong></td>
<td>GB&#x2F;T 35276-2017</td>
<td>- 基于身份的密码算法（IBE），无需提前申请数字证书<br>- 以“用户标识”（如邮箱、手机号）作为公钥，简化密钥管理</td>
<td>- 物联网设备身份认证（设备标识直接作为公钥，无需存储证书）<br>- 企业内网单点登录（SSO）<br>- 移动端轻量级加密场景</td>
</tr>
</tbody></table>
<h3 id="3-哈希算法：数据完整性校验的核心"><a href="#3-哈希算法：数据完整性校验的核心" class="headerlink" title="3. 哈希算法：数据完整性校验的核心"></a>3. 哈希算法：数据完整性校验的核心</h3><p>哈希算法（散列算法）能将任意长度的数据映射为固定长度的“哈希值”，具有“不可逆、抗碰撞”特性——数据一旦被篡改，哈希值会发生显著变化，常用于数据完整性校验和数字签名的核心组件。</p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>标准号</th>
<th>核心特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SM3</strong></td>
<td>GB&#x2F;T 32905-2016</td>
<td>- 输出哈希值长度256位<br>- 抗碰撞能力强，安全性优于MD5、SHA-1，与SHA-256相当<br>- 算法公开，可通过第三方工具验证</td>
<td>- 数字签名的哈希运算（SM2签名需结合SM3生成消息摘要）<br>- 数据完整性校验（如文件传输后比对哈希值）<br>- 区块链交易哈希生成（部分国产区块链采用）</td>
</tr>
</tbody></table>
<h3 id="4-其他辅助算法与协议"><a href="#4-其他辅助算法与协议" class="headerlink" title="4. 其他辅助算法与协议"></a>4. 其他辅助算法与协议</h3><p>除核心算法外，国密体系还包括配套的密码协议和辅助标准，确保算法的工程化落地：</p>
<ul>
<li><strong>SM7</strong>：分组密码算法，主要用于RFID标签、智能终端等低成本、低功耗设备的加密保护；</li>
<li><strong>祖冲之序列密码算法</strong>：流密码算法，适用于实时通信场景（如语音、视频加密）；</li>
<li><strong>国密SSL&#x2F;TLS协议</strong>：基于SM2、SM3、SM4构建的加密通信协议，替代基于RSA、AES的国际SSL&#x2F;TLS协议，用于HTTPS网站、VPN等场景。</li>
</ul>
<h2 id="二、国产密码算法的应用场景：从关键领域到民生服务"><a href="#二、国产密码算法的应用场景：从关键领域到民生服务" class="headerlink" title="二、国产密码算法的应用场景：从关键领域到民生服务"></a>二、国产密码算法的应用场景：从关键领域到民生服务</h2><p>国密算法已从“政策强制”走向“广泛应用”，覆盖政务、金融、通信、能源等关键信息基础设施，以及民生服务的多个环节，成为信息安全的“标配”技术。</p>
<h3 id="1-政务领域：保障国家数据安全"><a href="#1-政务领域：保障国家数据安全" class="headerlink" title="1. 政务领域：保障国家数据安全"></a>1. 政务领域：保障国家数据安全</h3><p>政务系统是国密算法的“先行应用领域”，强制要求关键环节采用国密算法，落实“自主可控”要求：</p>
<ul>
<li><strong>电子政务平台</strong>：采用SM2实现公务员身份认证，SM4加密政务数据传输，SM3校验公文完整性；</li>
<li><strong>电子签章&#x2F;电子证照</strong>：基于SM2数字签名和SM3哈希算法，确保电子公文、电子身份证、电子营业执照的合法性与防篡改性（符合《电子签名法》要求）；</li>
<li><strong>政务云安全</strong>：政务云平台采用SM4加密存储敏感数据，SM2实现云资源访问的身份认证。</li>
</ul>
<h3 id="2-金融领域：守护金融交易安全"><a href="#2-金融领域：守护金融交易安全" class="headerlink" title="2. 金融领域：守护金融交易安全"></a>2. 金融领域：守护金融交易安全</h3><p>金融行业是国密算法应用最深入的领域之一，通过“国密改造”替代国外算法，保障支付、交易等核心环节安全：</p>
<ul>
<li><strong>银行核心系统</strong>：银行卡芯片采用SM1&#x2F;SM4加密，银行U盾使用SM2生成数字签名，确保转账、支付等操作的不可抵赖性；</li>
<li><strong>第三方支付</strong>：支付宝、微信支付等平台的“余额加密”“交易签名”采用SM4和SM2算法；</li>
<li><strong>金融通信</strong>：银行间数据交换（如银联系统）采用国密SSL&#x2F;TLS协议加密，防止交易数据被窃听或篡改。</li>
</ul>
<h3 id="3-通信与物联网领域：构建终端安全防线"><a href="#3-通信与物联网领域：构建终端安全防线" class="headerlink" title="3. 通信与物联网领域：构建终端安全防线"></a>3. 通信与物联网领域：构建终端安全防线</h3><p>随着5G和物联网的发展，国密算法成为终端设备安全的核心支撑：</p>
<ul>
<li><strong>无线通信</strong>：WAPI（我国自主无线局域网标准）强制使用SM4加密，替代WiFi的WEP&#x2F;WPA协议；</li>
<li><strong>物联网设备</strong>：智能电表、水表采用SM7加密设备数据，工业传感器通过SM9实现身份认证，防止设备被恶意控制；</li>
<li><strong>5G通信</strong>：5G核心网的用户身份认证、数据传输加密采用SM2和SM4算法，保障通信隐私。</li>
</ul>
<h3 id="4-民生服务：贴近日常生活的安全保障"><a href="#4-民生服务：贴近日常生活的安全保障" class="headerlink" title="4. 民生服务：贴近日常生活的安全保障"></a>4. 民生服务：贴近日常生活的安全保障</h3><p>国密算法已融入民生服务，为普通人的信息安全“保驾护航”：</p>
<ul>
<li><strong>社保卡</strong>：社保卡芯片采用SM1加密个人社保数据，防止信息泄露或伪造；</li>
<li><strong>健康码&#x2F;行程码</strong>：基于SM3生成健康码的唯一哈希值，确保码值不被篡改；</li>
<li><strong>HTTPS网站</strong>：政务服务网、银行官网等已完成“国密改造”，采用国密SSL证书（显示“GMSSL”标识），加密用户访问数据。</li>
</ul>
<h2 id="三、国产密码算法的合规要求与“国密改造”"><a href="#三、国产密码算法的合规要求与“国密改造”" class="headerlink" title="三、国产密码算法的合规要求与“国密改造”"></a>三、国产密码算法的合规要求与“国密改造”</h2><h3 id="1-核心合规政策：驱动算法落地的“指挥棒”"><a href="#1-核心合规政策：驱动算法落地的“指挥棒”" class="headerlink" title="1. 核心合规政策：驱动算法落地的“指挥棒”"></a>1. 核心合规政策：驱动算法落地的“指挥棒”</h3><p>我国通过多部法律法规和政策文件，明确国密算法的应用要求，形成“强制+引导”的合规体系：</p>
<ul>
<li>《中华人民共和国密码法》（2020年实施）：明确“关键信息基础设施应当使用国家密码标准和规范”，未合规使用将面临处罚；</li>
<li>《网络安全等级保护基本要求》（等保2.0）：三级及以上信息系统（如金融、政务系统）需采用国密算法进行加密、签名和哈希运算；</li>
<li>《金融业密码应用与安全性评估办法》：要求金融机构的核心系统必须通过“密码应用安全性评估”（简称“密评”），国密算法应用是核心评估指标。</li>
</ul>
<h3 id="2-“国密改造”：从“国外算法”到“国密算法”的替换流程"><a href="#2-“国密改造”：从“国外算法”到“国密算法”的替换流程" class="headerlink" title="2. “国密改造”：从“国外算法”到“国密算法”的替换流程"></a>2. “国密改造”：从“国外算法”到“国密算法”的替换流程</h3><p>“国密改造”是企业落实合规要求的核心工作，指将系统中原有的国外算法（如RSA、AES、SHA-256）替换为国产算法，典型流程包括：</p>
<ol>
<li><strong>资产梳理与风险评估</strong>：识别系统中使用密码算法的环节（如加密存储、身份认证、通信加密），评估替换对业务的影响；</li>
<li><strong>算法选型与方案设计</strong>：根据场景选择适配的国密算法（如“数据加密选SM4，签名选SM2，哈希校验选SM3”），设计兼容过渡方案（避免改造期间业务中断）；</li>
<li><strong>工程化实现</strong>：改造系统代码（如替换加密库为“国密算法库”）、升级硬件设备（如更换支持国密的服务器、加密机）、部署国密证书（如向CA申请SM2证书）；</li>
<li><strong>测试与验收</strong>：开展功能测试（确保算法替换后业务正常）、安全测试（验证加密强度与抗攻击能力），通过“密评”或等保测评；</li>
<li><strong>运维与优化</strong>：建立国密算法的密钥管理体系（如密钥生成、备份、销毁），定期监控算法运行状态。</li>
</ol>
<h2 id="四、国产密码算法的优势与发展趋势"><a href="#四、国产密码算法的优势与发展趋势" class="headerlink" title="四、国产密码算法的优势与发展趋势"></a>四、国产密码算法的优势与发展趋势</h2><h3 id="1-核心优势：自主可控与安全可靠"><a href="#1-核心优势：自主可控与安全可靠" class="headerlink" title="1. 核心优势：自主可控与安全可靠"></a>1. 核心优势：自主可控与安全可靠</h3><ul>
<li><strong>自主可控</strong>：算法设计、标准制定、实现代码均由我国自主完成，无“后门”风险，不受国外技术封锁或制裁影响；</li>
<li><strong>安全性能优异</strong>：SM2的256位密钥强度相当于RSA的2048位，SM3的抗碰撞能力优于SHA-1，且算法效率更高（尤其适用于移动端、物联网等资源受限场景）；</li>
<li><strong>政策与合规支撑</strong>：有明确的法律法规和标准体系保障，适配我国网络安全与数据安全的监管要求。</li>
</ul>
<h3 id="2-面临的挑战"><a href="#2-面临的挑战" class="headerlink" title="2. 面临的挑战"></a>2. 面临的挑战</h3><ul>
<li><strong>生态兼容性</strong>：部分老旧系统、国外硬件设备对国密算法支持不足，改造成本较高；</li>
<li><strong>人才缺口</strong>：掌握国密算法设计、工程实现、安全评估的复合型人才相对稀缺；</li>
<li><strong>国际认可度</strong>：国密算法在国际上的应用范围较窄，跨境业务中仍需兼容国际算法。</li>
</ul>
<h3 id="3-发展趋势"><a href="#3-发展趋势" class="headerlink" title="3. 发展趋势"></a>3. 发展趋势</h3><ul>
<li><strong>“算法+硬件”深度融合</strong>：推动国密算法与芯片、加密机、智能卡等硬件结合，形成“硬件级安全”（如国密安全芯片、可信计算模块TPM）；</li>
<li><strong>适配新兴技术场景</strong>：针对量子计算威胁，研发“抗量子国密算法”；针对AI、区块链，优化算法的并行计算效率与分布式部署能力；</li>
<li><strong>国际化推广</strong>：通过“一带一路”等合作机制，推动国密算法成为国际标准，扩大应用范围；</li>
<li><strong>生态体系完善</strong>：构建“算法库-硬件设备-应用方案-检测认证”的完整生态，降低企业“国密改造”的门槛。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>国产密码算法不仅是“技术工具”，更是我国<strong>网络空间安全战略</strong>的核心组成部分。从政务系统的公文加密到普通人的社保卡安全，从银行的支付交易到物联网设备的身份认证，国密算法已渗透到信息社会的每一个关键环节，为“自主可控的信息安全体系”筑牢根基。随着合规要求的深化和技术生态的完善，国产密码算法将从“强制应用”走向“主动选择”，成为数字化时代保障数据安全、维护国家网络主权的核心力量。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>关于国密算法，我接触过的主要是SM2&#x2F;3&#x2F;4&#x2F;9。客户一般用到的是SM2&#x2F;3&#x2F;4。<br>目前，常用的OpenSSL 3.0已经覆盖SM2&#x2F;3&#x2F;4算法， 而且针对TLS创建了一个NTLS的协议，国内阿里实现的Tongsuo库支持了国密的NTLS。<br>还有国密算法应用到了安全芯片的0008认证，对芯片的准入是一个基础的门槛，后面对SM2&#x2F;3&#x2F;4算法单独介绍一下，包括实现逻辑。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title>crypto系列6-国产哈希算法SM3</title>
    <url>/2025/09/30/2025-20250930-crypto-006-sm3/</url>
    <content><![CDATA[<h1 id="SM3算法：中国国家密码局哈希标准详解"><a href="#SM3算法：中国国家密码局哈希标准详解" class="headerlink" title="SM3算法：中国国家密码局哈希标准详解"></a>SM3算法：中国国家密码局哈希标准详解</h1><p>SM3算法是由<strong>国家密码管理局</strong>制定并发布的密码哈希函数标准，属于中国自主设计的商用密码算法体系（SM系列算法），主要用于数据完整性校验、数字签名、身份认证等场景，其安全性和性能经过严格评估，已广泛应用于金融、政务、通信等关键领域。</p>
<span id="more"></span>
<h2 id="一、SM3的基本定位与核心作用"><a href="#一、SM3的基本定位与核心作用" class="headerlink" title="一、SM3的基本定位与核心作用"></a>一、SM3的基本定位与核心作用</h2><p>哈希函数（Hash Function）的核心是将任意长度的输入数据（称为“消息”）映射为<strong>固定长度的输出值</strong>（称为“哈希值”或“摘要”），且满足三大核心特性：</p>
<ol>
<li><strong>单向性</strong>：从哈希值无法反推原始消息；</li>
<li><strong>抗碰撞性</strong>：不存在两条不同消息生成相同哈希值（强抗碰撞），也无法主动构造两条消息生成相同哈希值（弱抗碰撞）；</li>
<li><strong>雪崩效应</strong>：原始消息的微小变化（如1个比特的修改）会导致哈希值发生剧烈改变，确保篡改可被检测。</li>
</ol>
<p>SM3作为国家推荐标准（GB&#x2F;T 32905-2016《信息安全技术 SM3密码杂凑算法》），正是为满足上述特性设计，其输出哈希值固定为<strong>256比特（32字节）</strong>，可有效抵御当前已知的密码分析攻击（如生日攻击、差分攻击等）。</p>
<h2 id="二、SM3的算法流程"><a href="#二、SM3的算法流程" class="headerlink" title="二、SM3的算法流程"></a>二、SM3的算法流程</h2><p>SM3的处理过程分为4个核心步骤，整体逻辑与国际主流哈希算法（如SHA-256）有相似之处，但在压缩函数、常量设计等细节上体现自主创新：</p>
<p><img src="/images/2025/SM3_summary.png" alt="SM3_summary"></p>
<h3 id="1-消息预处理"><a href="#1-消息预处理" class="headerlink" title="1. 消息预处理"></a>1. 消息预处理</h3><p>对输入消息进行“补位”和“分块”，确保消息长度满足后续压缩要求：</p>
<ul>
<li><p><strong>步骤1：补位</strong><br>若消息长度为<code>L</code>比特，先在消息末尾添加1个“1”比特，再添加<code>k</code>个“0”比特，使得补位后的总长度满足 <code>L + 1 + k ≡ 448 mod 512</code>（即模512后余448）。<br><em>例：若消息长度为448比特，补1个“1”后长度为449，需补511个“0”，使总长度为449+511&#x3D;960 ≡ 448 mod 512</em>。</p>
</li>
<li><p><strong>步骤2：附加长度</strong><br>将原始消息的长度<code>L</code>（以64比特二进制数表示，不足64比特则高位补0）附加到补位后的消息末尾，最终消息总长度为<code>512的整数倍</code>，即被划分为<code>N个512比特的消息块</code>（记为M₀, M₁, …, Mₙ₋₁）。</p>
</li>
</ul>
<h3 id="2-消息扩展：生成68个消息字与64个扩展字"><a href="#2-消息扩展：生成68个消息字与64个扩展字" class="headerlink" title="2. 消息扩展：生成68个消息字与64个扩展字"></a>2. 消息扩展：生成68个消息字与64个扩展字</h3><p>对每个512比特的消息块Mᵢ，将其拆分为16个32比特的“基本消息字”（W₀~W₁₅），再通过特定变换生成后续的“扩展消息字”，最终得到132个32比特字（68个W字 + 64个W’字），为压缩函数提供输入：</p>
<ul>
<li><p><strong>W字生成（W₀~W₆₇）</strong>：<br>当0 ≤ j ≤ 15时，Wⱼ直接等于Mᵢ拆分后的第j个32比特字；<br>当16 ≤ j ≤ 67时，Wⱼ &#x3D; P₁(Wⱼ₋₄ ⊕ Wⱼ₋₅ ⊕ Wⱼ₋₆ ⊕ Wⱼ₋₁₄ ⊕ Wⱼ₋₁₅ ⊕ Wⱼ₋₁₆) ⊕ (Wⱼ₋₈ ≪ 15) ⊕ Wⱼ₁₆；<br>其中<code>P₁(X)</code>是SM3定义的置换函数（P₁(X) &#x3D; X ⊕ (X ≪ 15) ⊕ (X ≪ 23)），<code>≪ s</code>表示左移s比特。</p>
</li>
<li><p><strong>W’字生成（W’₀~W’₆₃）</strong>：<br>W’ⱼ &#x3D; Wⱼ ⊕ Wⱼ₄（0 ≤ j ≤ 63），用于压缩函数的轮运算。</p>
</li>
</ul>
<h3 id="3-压缩函数：迭代更新哈希值"><a href="#3-压缩函数：迭代更新哈希值" class="headerlink" title="3. 压缩函数：迭代更新哈希值"></a>3. 压缩函数：迭代更新哈希值</h3><p>压缩函数是SM3的核心，其作用是将当前消息块的扩展字与“中间哈希值”（初始为固定初始值）进行64轮迭代运算，生成新的中间哈希值，直至所有消息块处理完成：</p>
<ul>
<li><p><strong>初始哈希值（IV）</strong>：<br>SM3规定了固定的初始256比特哈希值，分为8个32比特寄存器（A~H），初始值为：<br>A&#x3D;7380166F, B&#x3D;4914B2B9, C&#x3D;172442D7, D&#x3D;DA8A0600,<br>E&#x3D;A96F30BC, F&#x3D;163138AA, G&#x3D;E38DEE4D, H&#x3D;B0FB0E4E（均为十六进制）。</p>
</li>
<li><p><strong>64轮迭代运算</strong>：<br>每轮迭代使用对应的Wⱼ和W’ⱼ，通过以下步骤更新A~H：  </p>
<ol>
<li>计算轮常量Tⱼ：当0 ≤ j ≤ 15时，Tⱼ&#x3D;79CC4519；当16 ≤ j ≤ 63时，Tⱼ&#x3D;7A879D8A（十六进制，用于增强抗攻击能力）；  </li>
<li>计算中间变量SS1 &#x3D; ((A ≪ 12) + E + (Tⱼ ≪ j)) ≪ 7；  </li>
<li>计算中间变量SS2 &#x3D; SS1 ⊕ (A ≪ 12)；  </li>
<li>计算中间变量TT1 &#x3D; FFⱼ(A,B,C) + D + SS2 + W’ⱼ；  </li>
<li>计算中间变量TT2 &#x3D; GGⱼ(E,F,G) + H + SS1 + Wⱼ；  </li>
<li>更新寄存器：D&#x3D;C, C&#x3D;B≪9, B&#x3D;A, A&#x3D;TT1, H&#x3D;G, G&#x3D;F≪19, F&#x3D;E, E&#x3D;P₀(TT2)；<br>其中<code>FFⱼ</code>和<code>GGⱼ</code>是轮函数（j≤15时为简单异或，j&gt;15时为复杂布尔运算），<code>P₀(X)</code>是置换函数（P₀(X)&#x3D;X⊕(X≪9)⊕(X≪17)）。</li>
</ol>
</li>
<li><p><strong>迭代更新</strong>：每个消息块处理完成后，将新生成的A~H与处理前的中间哈希值进行异或，得到新的中间哈希值，作为下一个消息块的输入。</p>
</li>
</ul>
<h3 id="4-输出最终哈希值"><a href="#4-输出最终哈希值" class="headerlink" title="4. 输出最终哈希值"></a>4. 输出最终哈希值</h3><p>当所有N个消息块均处理完成后，最终的中间哈希值（A~H拼接）即为SM3的输出结果——256比特（32字节）的哈希值，通常以64位十六进制字符串形式展示（1字节&#x3D;2位十六进制）。</p>
<h2 id="三、SM3的安全性与优势"><a href="#三、SM3的安全性与优势" class="headerlink" title="三、SM3的安全性与优势"></a>三、SM3的安全性与优势</h2><h3 id="1-安全性评估"><a href="#1-安全性评估" class="headerlink" title="1. 安全性评估"></a>1. 安全性评估</h3><p>SM3的设计充分考虑了当前密码分析技术，经过国内外密码学界多年验证，具备以下安全特性：</p>
<ul>
<li><strong>抗碰撞性</strong>：目前尚无公开方法能在多项式时间内构造碰撞（即找到两条不同消息生成相同哈希值），其抗碰撞强度与SHA-256相当（理论生日攻击复杂度为2¹²⁸）；</li>
<li><strong>抗差分攻击</strong>：压缩函数的轮函数和置换函数设计能有效抵御差分攻击，降低算法被破解的风险；</li>
<li><strong>合规性</strong>：作为国家密码标准，SM3已通过国家密码管理局的安全性审查，满足关键信息基础设施的密码应用要求（符合《密码法》和《信息安全技术 密码应用基本要求》）。</li>
</ul>
<h3 id="2-核心优势"><a href="#2-核心优势" class="headerlink" title="2. 核心优势"></a>2. 核心优势</h3><ul>
<li><strong>自主可控</strong>：完全由中国自主设计，避免依赖国外算法可能存在的“后门”或技术卡脖子风险；</li>
<li><strong>性能均衡</strong>：算法流程简洁，硬件实现（如芯片、FPGA）和软件实现（如编程语言库）均具备较高效率，适合高并发场景（如区块链交易验证、大规模数据校验）；</li>
<li><strong>场景适配</strong>：输出256比特哈希值，既能满足安全性需求，又不会因长度过长导致存储和传输成本过高，适配金融、政务、物联网等多领域。</li>
</ul>
<h2 id="四、SM3的典型应用场景"><a href="#四、SM3的典型应用场景" class="headerlink" title="四、SM3的典型应用场景"></a>四、SM3的典型应用场景</h2><p>SM3的特性使其在需要“数据完整性校验”和“身份认证”的场景中广泛应用：</p>
<ol>
<li><strong>数字签名</strong>：与SM2椭圆曲线公钥算法配合，构成“SM2+SM3”签名方案——将消息用SM3生成摘要后，再用私钥对摘要签名，接收方用公钥验签，确保消息未被篡改且来源可信（如电子合同、公文签署）；</li>
<li><strong>区块链</strong>：作为区块链的“哈希算法”，用于生成区块哈希（如中国自主区块链平台“长安链”采用SM3），确保区块数据不可篡改；</li>
<li><strong>数据校验</strong>：对文件、传输数据生成SM3哈希值，接收方重新计算哈希值并比对，验证数据是否在传输或存储过程中被篡改（如软件安装包校验、云存储数据完整性检查）；</li>
<li><strong>身份认证</strong>：将用户密码通过SM3哈希后存储（而非明文存储），登录时比对哈希值，保障用户密码安全（避免密码泄露风险）。</li>
</ol>
<h2 id="五、SM3与国际主流哈希算法（SHA-256）对比"><a href="#五、SM3与国际主流哈希算法（SHA-256）对比" class="headerlink" title="五、SM3与国际主流哈希算法（SHA-256）对比"></a>五、SM3与国际主流哈希算法（SHA-256）对比</h2><p>SM3常与国际标准SHA-256（SHA-2系列算法）比较，二者在安全性和应用场景上有相似之处，但存在关键差异：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>SM3</th>
<th>SHA-256</th>
</tr>
</thead>
<tbody><tr>
<td>制定机构</td>
<td>中国国家密码管理局</td>
<td>美国国家标准与技术研究院（NIST）</td>
</tr>
<tr>
<td>输出长度</td>
<td>256比特（32字节）</td>
<td>256比特（32字节）</td>
</tr>
<tr>
<td>消息块大小</td>
<td>512比特</td>
<td>512比特</td>
</tr>
<tr>
<td>迭代轮数</td>
<td>64轮</td>
<td>64轮</td>
</tr>
<tr>
<td>核心函数</td>
<td>自定义P₀、P₁置换函数，FFⱼ、GGⱼ轮函数</td>
<td>自定义Ch、Maj函数，Σ₀、Σ₁轮函数</td>
</tr>
<tr>
<td>主要应用场景</td>
<td>中国政务、金融、国企等合规场景</td>
<td>国际通用场景（如互联网、跨境业务）</td>
</tr>
<tr>
<td>合规性要求</td>
<td>符合中国《密码法》强制要求</td>
<td>符合国际NIST标准</td>
</tr>
</tbody></table>
<h2 id="六、SM3的实现与工具"><a href="#六、SM3的实现与工具" class="headerlink" title="六、SM3的实现与工具"></a>六、SM3的实现与工具</h2><h3 id="1-编程语言支持"><a href="#1-编程语言支持" class="headerlink" title="1. 编程语言支持"></a>1. 编程语言支持</h3><p>主流编程语言均已通过官方或第三方库支持SM3算法：</p>
<ul>
<li><strong>Python</strong>：可通过<code>pycryptodome</code>库（<code>Crypto.Hash.SM3</code>）或<code>gmssl</code>库（国密专用库）实现；</li>
<li><strong>Java</strong>：通过<code>BouncyCastle</code>加密库（需添加国密算法支持）或<code>gmssl-jdk</code>库；</li>
<li>**C&#x2F;C++**：可使用国家密码管理局发布的“SM3算法参考实现代码”，或开源库<code>OpenSSL</code>（1.1.1及以上版本支持SM3）；</li>
<li><strong>Go</strong>：标准库<code>crypto</code>无直接支持，需通过第三方库如<code>github.com/tjfoc/gmsm</code>。</li>
</ul>
<h3 id="2-常用工具"><a href="#2-常用工具" class="headerlink" title="2. 常用工具"></a>2. 常用工具</h3><ul>
<li><strong>命令行工具</strong>：<code>OpenSSL</code>（命令：<code>openssl dgst -sm3 文件名</code>）、<code>gmssl</code>（国密专用工具，命令：<code>gmssl sm3 文件名</code>）；</li>
<li><strong>在线工具</strong>：多个国密合规平台提供在线SM3哈希计算（如“国密算法在线测试平台”），适合快速验证小规模数据。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SM3作为中国自主可控的密码哈希标准，不仅在安全性上达到国际先进水平，更在合规性上满足国内关键领域的密码应用要求。随着《密码法》的实施和“自主可控”战略的推进，SM3已成为金融、政务、区块链等领域的核心密码算法之一，是保障数据安全和信息主权的重要技术支撑。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title>crypto系列7-国产对称算法SM4</title>
    <url>/2025/10/02/2025-20251002-crypto-007-sm4/</url>
    <content><![CDATA[<h1 id="SM4算法：中国国家密码局对称标准详解"><a href="#SM4算法：中国国家密码局对称标准详解" class="headerlink" title="SM4算法：中国国家密码局对称标准详解"></a>SM4算法：中国国家密码局对称标准详解</h1><p>SM4算法是中国自主设计的<strong>分组密码算法</strong>，主要用于数据加密保护，是国家密码标准（GB&#x2F;T 32907-2016）的核心组成部分。</p>
<span id="more"></span>

<h2 id="一、SM4算法核心特性"><a href="#一、SM4算法核心特性" class="headerlink" title="一、SM4算法核心特性"></a>一、SM4算法核心特性</h2><ol>
<li><strong>算法类型</strong>：属于分组密码，采用Feistel结构（轮函数迭代），加密和解密过程结构相同，仅轮密钥使用顺序相反。</li>
<li><strong>核心参数</strong>：<ul>
<li>分组长度：固定为<strong>128位</strong>，即每次处理16字节的数据。</li>
<li>密钥长度：固定为<strong>128位</strong>，确保高强度加密。</li>
<li>迭代轮数：共32轮，每轮通过S盒（非线性变换）和线性变换实现数据混淆与扩散。</li>
</ul>
</li>
<li><strong>安全等级</strong>：能有效抵抗差分攻击、线性攻击、代数攻击等主流密码分析方法，经国家密码管理局认证，可满足政务、金融等关键领域的安全需求。</li>
</ol>
<h2 id="二、SM4算法实现"><a href="#二、SM4算法实现" class="headerlink" title="二、SM4算法实现"></a>二、SM4算法实现</h2><p>SM4算法流程基于<strong>Feistel结构</strong>，核心分为<strong>密钥扩展</strong>和<strong>数据加密&#x2F;解密</strong>两部分，加密与解密流程结构完全一致，仅轮密钥使用顺序相反。</p>
<h3 id="A、核心前提：轮密钥扩展"><a href="#A、核心前提：轮密钥扩展" class="headerlink" title="A、核心前提：轮密钥扩展"></a>A、核心前提：轮密钥扩展</h3><p>128位初始密钥需先生成32个128位的轮密钥（<code>rk0</code>-<code>rk31</code>），供32轮迭代使用，步骤如下：</p>
<ol>
<li><strong>初始准备</strong>：将128位初始密钥拆分为4个32位字（<code>K0</code>-<code>K3</code>），与4个固定的32位系统参数（<code>FK0</code>-<code>FK3</code>）分别异或，得到初始密钥字（<code>K4</code>-<code>K7</code>）。</li>
<li><strong>迭代生成轮密钥</strong>：从<code>K8</code>开始，每生成1个密钥字需经过3步：<ul>
<li>对前1个密钥字（如<code>K7</code>）进行循环左移、S盒非线性变换、异或固定参数（<code>CK</code>）的复合操作，得到临时值<code>t</code>。</li>
<li>将<code>t</code>与前4个密钥字（如<code>K4</code>）异或，得到新密钥字（如<code>K8</code>）。</li>
<li>重复此过程，直至生成<code>K4</code>-<code>K39</code>，其中<code>K8</code>-<code>K39</code>即为32个轮密钥（<code>rk0</code>-<code>rk31</code>）。</li>
</ul>
</li>
</ol>
<h3 id="B、数据加密流程（128位明文→128位密文）"><a href="#B、数据加密流程（128位明文→128位密文）" class="headerlink" title="B、数据加密流程（128位明文→128位密文）"></a>B、数据加密流程（128位明文→128位密文）</h3><ol>
<li><strong>初始变换（IP）</strong>：将128位明文拆分为4个32位字（<code>X0</code>-<code>X3</code>），与第1个轮密钥<code>rk0</code>结合，进入首轮迭代。</li>
<li><strong>32轮迭代（Feistel结构）</strong>：每轮迭代对4个输入字（<code>Xi</code>-<code>Xi+3</code>）执行固定操作：<ul>
<li>对<code>Xi+3</code>进行循环左移、S盒变换、线性变换的复合操作，得到中间值<code>F</code>。</li>
<li>将<code>F</code>与<code>Xi</code>、轮密钥<code>rki</code>异或，得到新字<code>Xi+4</code>。</li>
<li>4个输入字依次右移（<code>Xi+1</code>→<code>Xi</code>，<code>Xi+2</code>→<code>Xi+1</code>，<code>Xi+3</code>→<code>Xi+2</code>，<code>Xi+4</code>→<code>Xi+3</code>），进入下一轮。</li>
</ul>
</li>
<li><strong>逆初始变换（IP⁻¹）</strong>：32轮迭代结束后，将最终4个输出字（<code>X32</code>-<code>X35</code>）按<code>X35</code>、<code>X34</code>、<code>X33</code>、<code>X32</code>的顺序拼接，得到128位密文。</li>
</ol>
<h3 id="C、数据解密流程（128位密文→128位明文）"><a href="#C、数据解密流程（128位密文→128位明文）" class="headerlink" title="C、数据解密流程（128位密文→128位明文）"></a>C、数据解密流程（128位密文→128位明文）</h3><p>解密流程与加密流程<strong>结构完全相同</strong>，唯一区别是轮密钥的使用顺序相反：</p>
<ul>
<li>加密时按<code>rk0</code>→<code>rk1</code>→…→<code>rk31</code>的顺序使用轮密钥。</li>
<li>解密时按<code>rk31</code>→<code>rk30</code>→…→<code>rk0</code>的顺序使用轮密钥。</li>
</ul>
<h2 id="三、安全性分析"><a href="#三、安全性分析" class="headerlink" title="三、安全性分析"></a>三、安全性分析</h2><ol>
<li><strong>密钥空间</strong>：128位密钥提供<code>2^128</code>种可能，远超暴力破解的计算能力（需约<code>10^38</code>年）。</li>
<li><strong>抗攻击能力</strong>：<ul>
<li><strong>差分攻击</strong>：最佳差分路径概率≤<code>2^-126</code>，需<code>2^126</code>次选择明文攻击，实际不可行。</li>
<li><strong>线性攻击</strong>：线性逼近概率≤<code>2^-64</code>，攻击复杂度超过<code>2^128</code>。</li>
<li><strong>侧信道攻击</strong>：硬件实现中通过冗余塔域（RTF）等技术防护，例如将S盒运算映射到AES的冗余塔域框架，降低功耗泄露风险。</li>
</ul>
</li>
<li><strong>国际认证</strong>：2021年成为ISO&#x2F;IEC国际标准（ISO&#x2F;IEC 18033-3:2021&#x2F;AMD1:2021），表明其设计通过国际密码学界审查。</li>
</ol>
<h2 id="四、与AES的对比"><a href="#四、与AES的对比" class="headerlink" title="四、与AES的对比"></a>四、与AES的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>SM4</th>
<th>AES-128</th>
</tr>
</thead>
<tbody><tr>
<td><strong>结构</strong></td>
<td>非平衡Feistel网络，32轮</td>
<td>SPN结构，10轮</td>
</tr>
<tr>
<td><strong>S盒设计</strong></td>
<td>自主构造的8×8置换表</td>
<td>GF(2⁸)求逆+仿射变换</td>
</tr>
<tr>
<td><strong>扩散机制</strong></td>
<td>线性变换L（循环移位+异或）</td>
<td>列混淆（MixColumns）矩阵乘法</td>
</tr>
<tr>
<td><strong>密钥扩展</strong></td>
<td>与加密流程相似，生成32个轮密钥</td>
<td>独立密钥扩展算法，生成11个轮密钥</td>
</tr>
<tr>
<td><strong>硬件优化</strong></td>
<td>边扩展边加密，节省存储资源</td>
<td>流水线架构，侧重吞吐率</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>抗差分&#x2F;线性攻击能力与AES相当</td>
<td>抗代数攻击能力更强</td>
</tr>
</tbody></table>
<p>SM4在资源受限设备（如物联网传感器）上表现更优，而AES在通用计算平台上性能略高。</p>
<h2 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景"></a>五、应用场景</h2><ol>
<li><strong>金融领域</strong>：银行卡交易加密、移动支付安全（如中国银联的SM4-GCM标准）。</li>
<li><strong>政务通信</strong>：公文传输加密、电子证照保护。</li>
<li><strong>物联网</strong>：智能家居设备间的通信加密（如华为鸿蒙系统的SM4集成）。</li>
<li><strong>VPN与云安全</strong>：虚拟专用网络数据加密、云端存储敏感字段保护。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>SM4算法通过<strong>S盒非线性混淆</strong>、<strong>线性变换全局扩散</strong>和<strong>密钥扩展的伪随机性</strong>，实现了高效且安全的对称加密。其设计既符合国际密码学标准，又满足国产化替代需求，在政务、金融、物联网等关键领域发挥核心作用。随着量子计算技术的发展，SM4的后量子安全性优化（如融合格密码）成为未来研究重点，但目前其128位密钥和32轮迭代足以抵御现有攻击手段。</p>
<p>SM4 算法处理固定长度为 128 位（16 字节）的数据块，使用 128 位（16 字节）的密钥。在实际应用中，对于长度超过 128 位的数据，需要使用分组密码的工作模式（如 CBC、CTR 等）进行处理。</p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>SM4算法配合不同模式用于具体的场景，比如IPSec的国密场景CBC(SM4)+SM3， 磁盘加密的XTS（SM4），NTLS（国密传输层安全协议）加密的GCM(SM4)等。</p>
<hr>
<p>行动，才不会被动!</p>
<p>欢迎关注个人公众号 微信 -&gt; 搜索 -&gt; fishmwei，沟通交流。</p>
<p><img src="/images/wx_gzh.png" alt="欢迎关注"></p>
<p>博客地址： <a href="https://fishmwei.github.io/">https://fishmwei.github.io</a></p>
<p>掘金主页： <a href="https://juejin.cn/user/2084329776486919">https://juejin.cn/user/2084329776486919</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>crypto</category>
      </categories>
  </entry>
</search>
